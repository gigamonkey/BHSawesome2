<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-4-9-arraylist-traversal">
  <title><c>ArrayList</c> traversals</title>

  <introduction>
    <idx>ArrayList traversal</idx>
    <idx>traversal</idx>
    <idx>loop</idx>
    <idx>enhanced for</idx>
    <idx>IndexOutOfBoundsException</idx>
    <idx>ConcurrentModificationException</idx>
    <p>
      We <term>traverse</term> an <c>ArrayList</c> when we use a loop to access
      it elements in order. Traversing an <c>ArrayList</c> is very similar to
      traversing an array; we use the same kinds of loops and just have to swap
      the <c>length</c> property of arrays for the <c>size()</c> method of
      <c>ArrayList</c> and use <c>get</c> and <c>set</c> methods instead of
      array access expressions with <c>[]</c>.
    </p>

    <p>
      Similarly, all the algorithms we learned about in <xref
      ref="topic-2-9-loop-algorithms" /> can be used with an <c>ArrayList</c>.
      Additionally we can write algorithms that remove elements from an
      <c>ArrayList</c> while we loop over it though as we’ll see we do need to
      exercise some care.
    </p>
  </introduction>

  <subsection>
    <title>The canonical <c>for</c> loop over an <c>ArrayList</c></title>

    <p>
      Recall the structure of the canonical <c>for</c> loop that runs <em>n</em>
      times:
    </p>

    <program>
      <![CDATA[
      for (int i = 0; i < n; i++) {
        // whatever
      }
      ]]>
    </program>

    <p>
      When we used that canonical structure to loop over an array we replaced
      <c>n</c> with <c>array.legnth</c> and in the body of the loop used
      <c>array[i]</c> to access the individual elements of the array.
    </p>

    <program>
      <![CDATA[
      for (int i = 0; i < array.length; i++) {
        // whatever with array[i]
      }
      ]]>
    </program>

    <p>
      Now we can apply the same pattern to loop over an <c>ArrayList</c> using
      <c>list.size()</c> in the loop condition <c>list.get(i)</c> and
      <c>list.set(i, value)</c> in the body of the loop to access the individual
      elements of the <c>ArrayList</c>.
    </p>

    <program>
      <![CDATA[
      for (int i = 0; i < list.size(); i++) {
        // whatever with list.get(i) and list.set(i, value)
      }
      ]]>
    </program>

    <p>
      Note that even though an <c>ArrayList</c> can grow and shrink via the
      <c>add</c> and <c>remove</c> methods, the <c>get</c> and <c>set</c>
      methods still require a valid index, i.e. greater than or equal to 0 and
      less than the size of the <c>ArrayList</c>. So if we try to use an index
      that is outside that range, the code will throw an
      <c>IndexOutOfBoundsException</c>, similar to the
      <c>ArrayIndexOutOfBoundsException</c> thrown if we use an invalid index in
      an array access expression..
    </p>

    <activity label="listForLoop">
      <statement>
        <p>
          The following code will throw an <c>IndexOutOfBoundsException</c>. Can
          you fix it?
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*;

          public class TestForLoop
          {
              public static void main(String[] args)
              {
                  ArrayList<Integer> myList = new ArrayList<Integer>();
                  myList.add(50);
                  myList.add(30);
                  myList.add(20);
                  int total = 0;
                  for (int i = 0; i <= myList.size(); i++)
                  {
                      total = total + myList.get(i);
                  }
                  System.out.println(total);
              }
          }
          ]]>
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "100";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }

              @Test
              public void fixedCode()
              {
                  boolean passed = checkCodeContains("fixed test in loop", "i < myList.size()");
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="enhanced-for-loop">
    <title>Enhanced <c>for</c> loop</title>

    <idx><h>list</h><h>for-each loop</h></idx>
    <p>
      Also as with arrays, we can use an enhanced <c>for</c> loop to traverse
      all of the items in an <c>ArrayList</c> when we only care about the values
      in the list and not their indexes. The type of the loop variable needs to
      be the same as the type parameter of the <c>ArrayList</c> but if the type
      parameter is a wrapper class like <c>Integer</c> we can (and usually
      should) use the primitive type for the loop variable and let auto-unboxing
      take care of it for us.
    </p>

    <program>
      <![CDATA[
      ArrayList<String> strings = new ArrayList<>();
      ArrayList<Integer> numbers = new ArrayList<>();

      // Loop variable is a String, the element type of strings
      for (String s : strings) {
        // do stuff with s
      }

      // Loop variable is an int, the unboxed version of the element type
      for (int n : numbers) {
        // do stuff with n
      }

      // Less stylish but this also works. n will probably be unboxed as needed in the body
      for (Integer n : numbers) {
        // do stuff with n
      }
      ]]>
    </program>


    <activity label="listForEachLoop">
      <statement>
        <p>
          What does the following code do? Guess before you run it. Then, add
          another enhanced for each loop that computes the product of all the
          elements in <c>numbers</c> by multiplying them. Print out the product
          after the new loop.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*; // import all classes in this package.

          public class Test1
          {
              public static void main(String[] args)
              {
                  ArrayList<Integer> numbers = new ArrayList<>();
                  numbers.add(50);
                  numbers.add(30);
                  numbers.add(20);

                  int total = 0;
                  for (int value : numbers) {
                      total += value;
                  }
                  System.out.println("Sum of all elements: " + total);

                  // Write a for-each loop that computes the product
                  // of all the elements in numbers and print out the product.

              }
          }
          ]]>
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testExpected() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "100";
                  boolean passed = output.contains(expect);
                  getResults(expect, output, "Prints out sum", passed);
                  assertTrue(passed);
              }

              @Test
              public void testProduct() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "30000";
                  boolean passed = output.contains(expect);
                  getResults(expect, output, "Prints out product", passed);
                  assertTrue(passed);
              }

              @Test
              public void countForLoops()
              {
                  String code = removeSpaces(getCode());
                  int count = countOccurences(code, "for(int");
                  boolean passed = count >= 2;
                  getResults("2", count + "", "Number of for each loops", passed);
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </activity>

    <p>
      One thing to watch out for with the enhanced <c>for</c> loop is that we
      can’t add or remove items from an <c>ArrayList</c> while we loop over it.
      We’ll see in a later section how to write loops that remove items from an
      <c>ArrayList</c> using a regular <c>for</c> loop, but with an enhanced for
      loop if the size of an <c>ArrayList</c> changes in any way, such as by a
      call to <c>add</c> or <c>remove</c>, while it is being looped over, the
      loop will immediately throw a <c>ConcurrentModificationException</c>.
    </p>

    <note>
      <p>
        If you’ve been paying very close attention you might wonder how it can
        be that <c>ArrayList</c> can be a regular class that we could have
        written ourselves yet it can be used with the special enhanced
        <c>for</c> loop syntax. The full resolution to that mystery is well
        beyond the scope of the AP curriculum but it happens that the way the
        enhanced <c>for</c> loop is defined in terms of an
        <term>interface</term> that any class can implement and <c>ArrayList</c>
        is one of the classes that does. So if you wanted to write your own
        class that you could loop over with an enhanced <c>for</c> loop, you
        could.
      </p>
    </note>


    <activity label="list_1" numbered="yes" adaptive="yes" indentation="show" language="java">
      <statement>
        <p>
          The following has the correct code for the method getScore plus at
          least one extra unneeded code statement. This method will calculate
          and return the score for a word game. The code should loop through all
          of the elements in wordList and if the length of the current word is 3
          it should add one to the score, if the length of the word is 4 it
          should add 2 to the score, and if the length is greater than 4 it
          should add 3 to the score. The method should return the score. Drag
          the needed blocks from the left into the correct order on the right.
          Check your solution by clicking on the Check button. You will be told
          if any of the blocks are in the wrong order or if you need to remove
          one or more blocks. There is one extra block that is not needed in a
          correct solution.
        </p>
      </statement>

      <blocks>
        <block order="9">
          <cline>public static int getScore(ArrayList&lt;String&gt;</cline>
          <cline>                            wordList)</cline>
          <cline>{</cline>
        </block>

        <block order="6">
          <cline>  int score = 0;</cline>
          <cline>  for (String word : wordList)</cline>
          <cline>  {</cline>
        </block>

        <block order="4">
          <cline>    if (word.length() == 3)</cline>
        </block>

        <block order="7">
          <cline>    {</cline>
          <cline>      score++;</cline>
          <cline>    }</cline>
        </block>

        <block order="3">
          <cline>    else if (word.length() == 4)</cline>
          <cline>    {</cline>
          <cline>      score = score + 2;</cline>
          <cline>    }</cline>
        </block>

        <block order="1">
          <cline>    else if (word.length() &gt; 4)</cline>
          <cline>    {</cline>
          <cline>      score = score + 3;</cline>
          <cline>    }</cline>
        </block>

        <block order="8">
          <cline>  } // end for</cline>
        </block>

        <block order="5">
          <cline>  return score;</cline>
          <cline>} // end method</cline>
        </block>

        <block order="2" correct="no">
          <cline>if (word.length == 3)</cline>
        </block>
      </blocks>
    </activity>
  </subsection>



  <subsection xml:id="while-loop">
    <title><c>while</c> loop</title>

    <p>
      And of course we can use a <c>while</c> loop to loop over an
      <c>ArrayList</c> though if we want to go element by element we’ll have to
      manage an index variable separately at which point a <c>for</c> loop might
      make more sense. But if we want to repeatedly modify an <c>ArrayList</c>
      until some condition is met a while loop can be just the thing. For
      example this code uses a <c>while</c> loop to remove all the elements from
      the beginning of an <c>ArrayList</c>, <c>numbers</c>, that are less than 100.
    </p>

    <program>
      <![CDATA[
      // numbers is an ArrayList<Integer>

      // Loop as long as there are elements in teh list and element 0 is < 100
      while (numbers.size() > 0 && numbers.get(0) < 100) {
        // Remove element 0
        numbers.remove(0);
      }
      ]]>
    </program>

    <p>
      After this code runs the list <c>numbers</c> is either empty or starts
      with a number greater than or equal to 100. There may be numbers less than
      100 later in the list but all the ones at the start will have been removed.
    </p>


    <activity label="listForEachLoopObj">
      <statement>
        <p>
          The code in this activity demonstrates using <c>while</c> loop and an
          object-oriented approach where the list is a field of the current
          object and an instance method rather than a class (static) method
          loops through the list.
        </p>

        <p>
          The code removes all instances of a name from a list. Set the found
          variable to the appropriate true or false values at line 13 and line
          20 to make the code work.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*;
          public class ListWorker
          {
             private ArrayList<String> nameList;

             public ListWorker(ArrayList<String> nameList)
             {
                 this.nameList = nameList;
             }

             public boolean removeName(String name)
             {
                 boolean found =   // true or false?
                 int index = 0;
                 while (index < nameList.size())
                 {
                     if (name.equals(nameList.get(index)))
                     {
                         nameList.remove(index);
                         found =    // true or false?
                     }
                     else
                     {
                         index++;
                     }
                 }
                 return found;
              }

              public static void main(String[] args)
              {
                  ArrayList<String> myList = new ArrayList<String>();
                  myList.add("Amun");
                  myList.add("Ethan");
                  myList.add("Donnie");
                  myList.add("Ethan");
                  ListWorker listWorker = new ListWorker(myList);
                  System.out.println(listWorker.nameList);
                  listWorker.removeName("Ethan");
                  System.out.println("After removing Ethan: "
                            + listWorker.nameList);
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "[Amun, Ethan, Donnie, Ethan]\nAfter removing Ethan: [Amun, Donnie]";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <p>
      Be careful when you remove items from a list as you loop through it.
      Notice how the method above only increments the index if an item was not
      removed from the list. This is because removing an item from a list will
      shift the remaining items to the left and if you increment the index in
      all cases you will skip the elements immediately after each element you
      remove. To see why, consider that those elements will be shifted into the
      position of the just removed element and if you increment the index, it
      will move to the next position, skipping the element that used to be at
      that position. Leaving the index unchanged after a remove allows the
      shifted-down element to be processed on the next time through the loop.
    </p>

    <activity label="qloopList_1">
      <statement>
        <p>
          Assume that <c>nums</c> has been created as an <c>ArrayList</c> object
          and it initially contains the following <c>Integer</c> values [0, 0,
          4, 2, 5, 0, 3, 0]. What will <c>nums</c> contain as a result of
          executing <c>numQuest</c>?
        </p>

        <program>
          <![CDATA[
          ArrayList<Integer> list1 = new ArrayList<Integer>();
          private ArrayList<Integer> nums;

          // precondition: nums.size() > 0;
          // nums contains Integer objects
          public void numQuest()
          {
             int k = 0;
             Integer zero = new Integer(0);
             while (k < nums.size())
             {
                if (nums.get(k).equals(zero))
                   nums.remove(k);
                k++;
             }
          }
          ]]>
        </program>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>[0, 4, 2, 5, 3]</p>
          </statement>

          <feedback>
            <p>
              Incrementing the index each time through the loop will miss when
              there are two zeros in a row.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>[3, 5, 2, 4, 0, 0, 0, 0]</p>
          </statement>

          <feedback>
            <p>
              This would be true if the code moved the zeros to the end, but
              that is not what it does.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>[0, 0, 0, 0, 4, 2, 5, 3]</p>
          </statement>

          <feedback>
            <p>
              This would be true if the code moved the zeros to the font, but
              that is not what it does.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>[4, 2, 5, 3]</p>
          </statement>

          <feedback>
            <p>
              This would be correct if k was only incremented when an item was
              not removed from the list.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      You can step through the code above by clicking on the following <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=import+java.util.*%3B%0A%0A%0Apublic+class+ListWorker+%7B%0A%0A+++private+List%3CInteger%3E+nums%3B%0A+++%0A+++public+ListWorker(List%3CInteger%3E+theNums)%0A+++%7B%0A++++++nums+%3D+theNums%3B%0A+++%7D%0A%0A+++//+precondition%3A+nums.size()+%3E+0%3B%0A+++//+nums+contains+Integer+objects%0A+++public+void+numQuest()%0A+++%7B%0A++++++int+k+%3D+0%3B%0A++++++Integer+zero+%3D+new+Integer(0)%3B%0A++++++while+(k+%3C+nums.size())%0A++++++%7B%0A+++++++++if+(nums.get(k).equals(zero))%0A++++++++++++nums.remove(k)%3B%0A+++++++++k%2B%2B%3B%0A++++++%7D%0A+++%7D%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++List%3CInteger%3E+numList+%3D+new+ArrayList%3CInteger%3E()%3B%0A++++++numList.add(0)%3B%0A++++++numList.add(0)%3B%0A++++++numList.add(4)%3B%0A++++++numList.add(2)%3B%0A++++++numList.add(5)%3B%0A++++++numList.add(0)%3B%0A++++++numList.add(3)%3B%0A++++++numList.add(0)%3B%0A++++++System.out.println(numList)%3B%0A++++++ListWorker+listW+%3D+new+ListWorker(numList)%3B%0A++++++listW.numQuest()%3B%0A++++++System.out.println(numList)%3B%0A+++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=11">Example</url>.
    </p>

    <activity label="listInsertParsons" numbered="yes" adaptive="yes" indentation="show" language="java">
      <statement>
        <p>
          The following has the correct code for a method called insertInOrder
          plus at least one extra unneeded code statement. This method should
          add the passed name in alphabetic order to a private list field called
          nameList. Drag the needed blocks from the left into the correct order
          on the right. Check your solution by clicking on the Check button. You
          will be told if any of the blocks are in the wrong order or if you
          need to remove one or more blocks. There is one extra block that is
          not needed in a correct solution.
        </p>
      </statement>

      <blocks>
        <block order="8">
          <cline>public void insertInOrder(String name)</cline>
          <cline>{</cline>
        </block>

        <block order="7">
          <cline>  int index = 0;</cline>
        </block>

        <block order="6">
          <cline>  while (index &lt; nameList.size() &amp;&amp;</cline>
          <cline>     nameList.get(index).compareTo(name)</cline>
          <cline>                             &lt; 0)</cline>
          <cline>  {</cline>
        </block>

        <block order="4">
          <cline>    index++;</cline>
        </block>

        <block order="3">
          <cline>  } // end while</cline>
        </block>

        <block order="5">
          <cline>  nameList.add(index,name);</cline>
        </block>

        <block order="1">
          <cline>} // end method</cline>
        </block>

        <block order="2" correct="no">
          <cline>nameList.add(name);</cline>
        </block>
      </blocks>
    </activity>
  </subsection>



  <subsection xml:id="arraylist-of-student-objects">
    <title>Traversing an ArrayList of Student Objects</title>

    <p>
      You can put any kind of objects into an <c>ArrayList</c>. For example,
      here is an <c>ArrayList</c> of <c>Student</c>s. Let's write some loops
      that traverse the <c>ArrayList</c> to print out each <c>Student</c> by
      implicitly calling its <c>toString()</c> method. We'll also write a method
      that filters the <c>ArrayList</c> to print out only the students who have
      a GPA higher than 3.5 for the honor roll.
    </p>

    <p>Method calls can be chained together like the following:</p>

    <program>
      // get the name of the 0's student
      String name = students.get(0).getName();
      // get the GPA of the student at index i
      double gpa = students.get(i).getGPA();
    </program>

    <activity label="StudentListLoops">
      <statement>
        <p>
          Write the methods <c>printRoster()</c> and <c>honorRoll()</c> for the
          <c>ArrayList</c> of <c>Student</c> objects below.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*;

          public class Roster
          {
              private ArrayList<Student> list = new ArrayList<Student>();

              public Roster()
              {
                  list.add(new Student("Skyler", 123456, 3.4));
                  list.add(new Student("Ayanna", 234567, 4.0));
                  list.add(new Student("Lin", 345678, 3.6));
                  list.add(new Student("Sunil", 456789, 3.0));
              }

              // Write a method to print the info for each student on the list
              // with each student's info on a new line using a for or for-each loop,
              // implicitly calling the toString() method of the Student class.
              public void printRoster()
              {

              }

              // Write a honorRoll() method to print the names of students
              // with a GPA greater than 3.5 on the list using an indexed for loop with index i
              // and chaining get(i) with the getGPA() and getName() methods of the Student class.
              public void honorRoll()
              {

              }


              // main method for testing
              public static void main(String[] args)
              {
                  Roster r = new Roster();
                  System.out.println("Roster:");
                  r.printRoster();
                  System.out.println("Honor Roll:");
                  r.honorRoll();
              }
          }

          class Student
          {
              private String name;
              private int id;
              private double gpa;


              public Student(String name, int id, double gpa)
              {
                  this.name = name;
                  this.id = id;
                  this.gpa = gpa;
              }

              // toString() method
              public String toString()
              {
                  return id + ": " + name + ": " + gpa;
              }

              public String getName()
              {
                  return name;
              }

              public double getGPA()
              {
                  return gpa;
              }

          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "Roster:\n123456: Skyler: 3.4\n234567: Ayanna: 4.0\n345678: Lin: 3.6\n456789: Sunil: 3.0\nHonor Roll:\nAyanna\nLin\n";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }

              @Test
              public void loopCode()
              {
                  boolean passed = checkCodeContains("for loop", "for");
                  assertTrue(passed);
              }

              @Test
              public void chain()
              {
                  boolean passed = checkCodeContains("chaining list.get(i).getGPA()", "list.get(i).getGPA()");
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="coding-challenge-frq-word-pairs">
    <title>Coding Challenge: FRQ Word Pairs</title>

    <p>
      This challenge is based on the <url
      href="https://secure-media.collegeboard.org/ap/pdf/ap18-frq-computer-science-a.pdf#page=7">2018
      Free Response Question #2 WordPair</url>. We encourage you to work in
      pairs on this challenge.
    </p>

    <p>
      You are given a class called <c>WordPair</c> that can store pairs of
      words.
    </p>

    <program>
      class WordPair
      {
          private String word1;
          private String word2;

          public WordPair(String word1, String word2)
          {
              this.word1 = word1;
              this.word2 = word2;
          }

          public String getFirst()
          {
              return word1;
          }

          public String getSecond()
          {
              return word2;
          }

          public String toString()
          {
              return "(" + word1 + ", " + word2 + ")";
          }
      }
    </program>

    <p>
      First, see if you can create an <c>ArrayList</c> of <c>WordPair</c>
      objects below. Look at the <c>StudentList</c> example above for help.
    </p>

    <activity label="ArrayListWordPair1">
      <statement>
        <p>Create an Arraylist of WordPair objects.</p>
      </statement>

      <program interactive="activecode">

        <code>
          import java.util.*;

          public class WordPairTest
          {
              public static void main(String[] args)
              {
                  // Create an ArrayList of WordPair objects called pairs

                  pairs.add(new WordPair("hi", "there"));
                  pairs.add(new WordPair("hi", "bye"));
                  System.out.println(pairs);
              }
          }

          class WordPair
          {
              private String word1;
              private String word2;

              public WordPair(String word1, String word2)
              {
                  this.word1 = word1;
                  this.word2 = word2;
              }

              public String getFirst()
              {
                  return word1;
              }

              public String getSecond()
              {
                  return word2;
              }

              public String toString()
              {
                  return "(" + word1 + ", " + word2 + ")";
              }
          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("WordPairTest");
              }

              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "[(hi, there), (hi, bye)]";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }

              @Test
              public void hasArrayList()
              {
                  boolean passed = checkCodeContains("ArrayList declaration", "ArrayList<WordPair>");
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </activity>

    <figure align="left">
      <image source="Unit4-Data-Collections/Figures/wordpairs.png" width="34%" />
    </figure>

    <p>
      In this FRQ, you are given an array of words and you will create pairs of
      them by taking the first word and pairing it with all the other words,
      then taking the second word and pairing it with all but the first one, and
      so on. For example, if the word array is [“Hi”, “there”, “Tyler”, “Sam”],
      this figure shows how the word pairs are formed.
    </p>

    <p>
      In the class <c>WordPairsList</c> below, you will write the constructor
      which takes the array of words and pairs them up as shown in the figure.
      You will need nested loops to pair each element with the rest of the
      elements in the list.
    </p>

    <p>Here is the pseudocode for the constructor method.</p>

    <p>
      <ul>
        <li>
          <p>
            Initialize the <c>allPairs</c> list to an empty <c>ArrayList</c> of
            <c>WordPair</c> objects.
          </p>
        </li>

        <li>
          <p>
            Loop through the <c>words</c> array for the first word in the word
            pair (for loop from index <c>i = 0</c> to <c>length-1</c>)
          </p>

          <p>
            <ul>
              <li>
                <p>
                  Loop through the rest of the word array starting from index
                  <c>i + 1</c> for the second word in the word pair (for loop
                  from index <c>j = i + 1</c> to <c>length</c>)
                </p>

                <p>
                  <ul>
                    <li>
                      <p>
                        Add the new <c>WordPair</c> formed from the <c>i</c>th
                        word and the <c>j</c>th word to the <c>allPairs</c>
                        <c>ArrayList</c>.
                      </p>
                    </li>
                  </ul>
                </p>
              </li>
            </ul>
          </p>
        </li>
      </ul>
    </p>

    <project label="challenge-WordPairs">
      <statement>
        <p>
          FRQ WordPairs Challenge: Complete the constructor for
          <c>WordPairsList</c> below which will add pairs of words from a given
          array to the <c>ArrayList</c>. Then, complete the method
          <c>numMatches()</c> as described below this exercise.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*;

          public class WordPairsList
          {
              private ArrayList<WordPair> allPairs;

              public WordPairsList(String[] words)
              {
                  // WRITE YOUR CODE HERE
                  // initialize allPairs to an empty ArrayList of WordPair objects

                  // nested loops through the words array to add each pair to allPairs

              }

              public int numMatches()
              {
                  // Write the code for the second part described below
                  return 0;
              }

              public String toString()
              {
                  return allPairs.toString();
              }

              public static void main(String[] args)
              {
                  String[] words = {"Hi", "there", "Tyler", "Sam"};
                  WordPairsList list = new WordPairsList(words);
                  System.out.println(list);
                  // For second part below, uncomment this test:
                  // System.out.println("The number of matched pairs is: " +
                  // list.numMatches());
              }
          }

          class WordPair
          {
              private String word1;
              private String word2;

              public WordPair(String word1, String word2)
              {
                  this.word1 = word1;
                  this.word2 = word2;
              }

              public String getFirst()
              {
                  return word1;
              }

              public String getSecond()
              {
                  return word2;
              }

              public String toString()
              {
                  return "(" + word1 + ", " + word2 + ")";
              }
          }
          ]]>
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("WordPairsList");
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect =
                          "[(Hi, there), (Hi, Tyler), (Hi, Sam), (there, Tyler), (there, Sam), (Tyler, Sam)]";

                  boolean passed = output.contains(expect);

                  String[] lines = output.split("\n");
                  if (lines.length > 1) output = lines[0];

                  getResults(expect, output, "Part 1 - Add all word pairs from main()", passed);
                  assertTrue(passed);
              }

              /* //remove test because instructions say to add a matched pair.
              @Test
              public void test2()
              {
                  String output = getMethodOutput("main");
                  String expect = "The number of matched pairs is: 0";

                  boolean passed = output.contains(expect);
                  String[] lines = output.split("\n");
                  if (lines.length > 1) output = lines[1];

                  getResults(expect, output, "Part 2 - call to numMatches from main()", passed);
                  assertTrue(passed);
              }
              */

              @Test
              public void test3()
              {
                  String[] words = {"Hi", "Hi", "Test", "Test"};
                  WordPairsList list = new WordPairsList(words);
                  String output = list.toString();
                  String expect = "[(Hi, Hi), (Hi, Test), (Hi, Test), (Hi, Test), (Hi, Test), (Test, Test)]";

                  boolean passed =
                          getResults(
                                  expect,
                                  output,
                                  "Part 1 - Add all word pairs with {\"Hi\", \"Hi\", \"Test\", \"Test\"}");
                  assertTrue(passed);
              }

              @Test
              public void test4()
              {
                  String[] words = {"Hi", "Hi", "Test", "Test"};
                  WordPairsList list = new WordPairsList(words);
                  String output = "The number of matched pairs is: " + list.numMatches();
                  String expect = "The number of matched pairs is: 2";

                  boolean passed =
                          getResults(
                                  expect,
                                  output,
                                  "Part 2 - numMatches() with {\"Hi\", \"Hi\", \"Test\", \"Test\"}");
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </project>

    <p>
      In the next part of the FRQ challenge, you are asked to write a method
      called <c>numMatches</c> that counts and returns the number of pairs where
      the first word is the same as the second word. For example, if the word
      array is <c>["hi","bye","hi"]</c>, the pairs generated would be
      <c>["hi","bye"]</c>, <c>["hi","hi"]</c>, and <c>["bye","hi"]</c>. In the
      second pair <c>["hi","hi"]</c>, the first word is the same as the second
      word, so <c>numMatches</c> would return 1.
    </p>

    <p>
      For this method, you will need a loop that goes through the
      <c>ArrayList</c> <c>allPairs</c> and for each <c>WordPair</c> in
      <c>allPairs</c>, it checks to see if its first word (using the
      <c>getFirst</c> method) equals the second word (using the <c>getSecond</c>
      method). If there is a match, it increments a counter which it returns at
      the end of the method. To test this method, add another “there” into the
      words array and then uncomment the call to <c>numMatches</c>.
    </p>
  </subsection>

  <subsection xml:id="summary-50">
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 4.9.A.1) Traversing an <c>ArrayList</c> is when iteration or
            recursive statements are used to access all or an ordered sequence
            of the elements in an <c>ArrayList</c>.
          </p>
        </li>

        <li>
          <p>
            <c>ArrayList</c>s can be traversed with an enhanced <c>for</c> loop,
            a <c>while</c> loop, or a regular <c>for</c> loop using an index.
          </p>
        </li>

        <li>
          <p>
            (AP 4.9.A.2) Deleting elements during a traversal of an
            <c>ArrayList</c> requires the use of special techniques to avoid
            skipping elements (since <c>remove</c> moves all the elements above
            the removed index down.)
          </p>
        </li>

        <li>
          <p>
            (AP 4.9.A.3) Attempting to access an index value outside of its
            range will result in an <c>IndexOutOfBoundsException</c>. (The
            indices for an <c>ArrayList</c> start at 0 and end at the number of
            elements − 1).
          </p>
        </li>

        <li>
          <p>
            (AP 4.9.A.4) Changing the size of an <c>ArrayList</c> while
            traversing it using an enhanced <c>for</c> loop can result in a
            <c>ConcurrentModificationException</c>. Therefore, when using an
            enhanced <c>for</c> loop to traverse an <c>ArrayList</c>, you should
            not add or remove elements.
          </p>
        </li>
      </ul>
    </p>
  </subsection>
</section>
