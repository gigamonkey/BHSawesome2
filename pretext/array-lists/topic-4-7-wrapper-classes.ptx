<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-4-7-wrapper-classes">
  <title>Wrapper classes</title>

  <introduction>
    <idx>wrapper classes</idx>
    <idx>Integer</idx>
    <idx>Double</idx>
    <idx>wrapper</idx>
    <idx><h>integer</h><h>minimum</h></idx>
    <idx><h>integer</h><h>maximum</h></idx>

    <p>
      As we discussed in the previous section, one of the limitations of the
      <c>ArrayList</c> class (which is actually a limitation of Java’s generic
      types more generally) is that the element type of an <c>ArrayList</c> must
      be a reference type. So we can make an <c>ArrayList&lt;String&gt;</c> but
      not an <c>ArrayList&lt;int&gt;</c>. So what are we supposed to do if we
      want to make a growable, shrinkable collection of <c>int</c> or
      <c>double</c> values?
    </p>

    <p>
      Java’s solution to this problem is to define <term>wrapper classes</term>,
      classes that exist to provide a reference type that wraps up a single
      value of a given primitive type. These types are defined in the
      <c>java.lang</c> pacakge and have names that are the capitalized,
      unabbreviated names of the corresponding primitive types: <c>Integer</c>,
      <c>Double</c>, and <c>Boolean</c>.
    </p>

    <p>
      As reference types, these types can be used as the element type of an
      <c>ArrayList</c>: <c>ArrayList&lt;Integer&gt;</c>,
      <c>ArrayList&lt;Double&gt;</c>, and <c>ArrayList&lt;Boolean&gt;</c>. As
      we’ll see Java provides a bit of extra support for these types,
      automatically converting between wrapper types and the corresponding
      primitive values in many contexts.
    </p>

    <p>
      There are also a few <c>static</c> utility methods and constants defined
      in the wrapper classes related to the corresponding primitive type.
    </p>

  </introduction>

  <subsection>
    <title>Using wrapper classes with <c>ArrayList</c></title>

    <p>
      The main use of wrapper types is as type parameter in an <c>ArrayList</c>
      declaration. If what we really want is a list of <c>int</c> values we can
      declare an <c>ArrayList&lt;Integer&gt;</c>.
    </p>


    <p>
      Once we’ve declared an <c>ArrayList</c> with a wrapper class for an
      element type, how do we create instances of the wrapper class to put in
      it?
    </p>

    <p>
      There are three ways, but in fact we almost only ever need one of them.
      The oldest, and worst, way is to construct a new instance of the wrapper
      class with a the constructor that takes a single value of the
      corresponding primitive type. These constructors exist but have been
      <term>deprecated</term> which means they still exist because removing them
      would break old code but they are now considered a mistake.
    </p>

    <program>
      <![CDATA[
      ArrayList<Integer> integers = new ArrayList<>();
      ArrayList<Double> doubles = new ArrayList<>();

      // BAD: don't do this. But it does work
      integers.add(new Integer(42));
      doubles.add(new Double(3.14));
      ]]>
    </program>

    <p>
      Slightly better is to use the <c>static</c> utility methods,
      <c>valueOf</c>, defined in the wrapper classes that take a primitive value
      and return a wrapped instance.
    </p>

    <program>
      <![CDATA[
      // Slightly better: also works. But also not necessary as we'll see
      integers.add(Integer.valueOf(42));
      doubles.add(Double.valueOf(3.14));
      ]]>
    </program>

    <p>
      The advantage of the <c>valueOf</c> methods compared to the constructors
      is that the methods don’t have to create a new object each time. This can
      save a lot of memory by reusing the same object for the same commonly
      wrapped primitive value. For example, making an array list containing a
      million zeros obtained with with <c>Integer.valueOf(0)</c> would use only
      one object to represent all the zeros whereas if we made them with <c> new
      Integer(0)</c> Java would have to allocate a million different objects,
      each holding the same <c>0</c> value, using a million times as much
      memory.
    </p>

    <p>
      But the right way to do this is to ignore the wrapper types and let a
      feature of Java called <term>autoboxing</term> take care of it for us.
    </p>

    <program>
      <![CDATA[
      // The right way
      integers.add(42);
      doubles.add(3.14);
      ]]>
    </program>

    <p>
      <term>Autoboxing</term> is the automatic conversion that the Java compiler
      makes between primitive types and their corresponding object wrapper
      classes. The Java compiler applies autoboxing when a primitive value is
      passed as a parameter to a method that expects an object of the
      corresponding wrapper class or assigned to a variable of the corresponding
      wrapper class. So when we call <c>add</c> on an
      <c>ArrayList&lt;Integer&gt;</c> the compiler knows <c>add</c> expects an
      <c>Integer</c>. If it sees that we’re passing an <c>int</c> it
      automatically gets an instance of <c>Integer</c>to wrap it, basically as
      if we had written a call to <c>Integer.valueOf</c>.
    </p>

    <p>
      An automatic conversion going in the other direction called
      <term>unboxing</term> happens when a value of a wrapper type is passed as
      a parameter or assigned to a variable that expects the corresponding
      primitive type. This means we can write code like this:
    </p>

    <program>
      <![CDATA[
      int i = integer.get(0);
      double d = doubles.get(0);
      ]]>
    </program>

    <p>
      The values actally returned by <c>get</c> in those two lines are
      <c>Integer</c> and <c>Double</c> but Java unwraps them and assigns the
      underlying value to the primitive variables <c>i</c> and <c>d</c>.
    </p>

    <p>
      Thanks to autoboxing and unboxing we almost never need to use the wrapper
      types anywhere except as the type parameters when declaring an
      <c>ArrayList</c>. For the most part we can just use primitive values and
      everything will work out fine. Unfortunately they are a few edge cases
      where it doesn’t which we’ll discuss below.
    </p>

    <activity label="qArrayListInteger">
      <statement>
        <p>
          Which of the following is the correct way to create an ArrayList of
          integers?
        </p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>ArrayList[int] numbers = new ArrayList&lt;&gt;();</p>
          </statement>

          <feedback>
            <p>
              The square brackets [] are only used with arrays, not ArrayLists.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>ArrayList&lt;String&gt; numbers = new ArrayList&lt;&gt;();</p>
          </statement>

          <feedback>
            <p>
              String is not the correct type since this is for an array of
              integers.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>ArrayList&lt;int&gt; numbers = new ArrayList&lt;&gt;();</p>
          </statement>

          <feedback>
            <p>
              ArrayLists cannot hold primitive types like <c>int</c>. You must
              use the wrapper class <c>Integer</c>.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>
              ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();
            </p>
          </statement>

          <feedback>
            <p>
              The wrapper class <c>Integer</c> is used to hold integers in an
              <c>ArrayList</c>.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="WrapperClasses">
      <statement>
        <p>
          Drag the definition from the left and drop it on the correct word on
          the right. Click the "Check Me" button to see if you are correct.
        </p>
      </statement>

      <feedback>
        <p>Review the vocabulary.</p>
      </feedback>

      <cardsort>
        <match>
          <premise order="1">
            automatic conversion from the primitive type to the wrapper object
          </premise>

          <response>autoboxing</response>
        </match>

        <match>
          <premise order="2">
            automatic conversion from the wrapper object to the primitive type
          </premise>

          <response>unboxing</response>
        </match>

        <match>
          <premise order="3">Integer</premise>
          <response>wrapper class</response>
        </match>

        <match>
          <premise order="4">int</premise>
          <response>primitive type</response>
        </match>

        <match>
          <premise order="5">Integer.MAX_VALUE + 1</premise>
          <response>overflow</response>
        </match>

        <match>
          <premise order="6">Integer.MIN_VALUE - 1</premise>
          <response>underflow</response>
        </match>
      </cardsort>
    </activity>

    <activity label="qalAdd1">
      <statement>
        <p>
          Here’s an example of code that uses autoxboxing to add values to an
          <c>ArrayList&lt;Integer&gt;</c>. What will print when the following
          code executes?
        </p>

        <program>
          <![CDATA[
          ArrayList<Integer> list1 = new ArrayList<>();
          list1.add(1);
          list1.add(2);
          list1.add(3);
          list1.add(2, 4);
          list1.add(5);
          System.out.println(list1);
          ]]>
        </program>

        <p>
          You can step through the code above by clicking on this <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=import+java.util.*%3B%0A%0Apublic+class+ClassNameHere+%7B%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++%0A++++++List%3CInteger%3E+list1+%3D+new+ArrayList%3CInteger%3E()%3B%0A++++++list1.add(new+Integer(1))%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(2)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(new+Integer(3))%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(2,4)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(new+Integer(5))%3B%0A++++++System.out.println(list1)%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Java
          Visualizer</url>.
        </p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>[1, 2, 3, 4, 5]</p>
          </statement>

          <feedback>
            <p>
              This would be true if all the <c>add</c> method calls were
              <c>add(value)</c>, but at least one is not.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>[1, 4, 2, 3, 5]</p>
          </statement>

          <feedback>
            <p>This would be true if <c>add(2, 4)</c> was <c>add(1, 4)</c> instead</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>[1, 2, 4, 3, 5]</p>
          </statement>

          <feedback>
            <p>
              The <c>add(2, 4)</c> will put the 4 at index 2, but first move the
              3 to index 3.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>[1, 2, 4, 5]</p>
          </statement>

          <feedback>
            <p>
              This would be true if the <c>add(2, 4)</c> replaced what was at
              index 2, but it actually moves the value currently at index 2 to
              index 3.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection>
    <title>An autoboxing subtlety</title>

    <p>
      As mentioned above, there are a few times when we can’t completely ignore
      what’s going on with autoboxing and unboxing. If we stick strictly within
      the AP curriculum we won’t hit them but we don’t have to go very far
      outside the bounds to run into one.
    </p>

    <p>
      The AP curriculum covers the <c>ArrayList</c> method <c>E remove(int)</c>
      which takes an <c>int</c> argument specifying the index of the element to
      remove. That’s fine. But there’s another <c>remove</c> method, <c>boolean
      remove(Object)</c> that takes any reference type as an argument
      <c>ArrayList</c> and either removes the first object in the list that is
      <c>equals</c> to it and returns <c>true</c> or returns <c>false</c> if
      there was no such object to remove.
    </p>

    <p>
      The subtlety is this. What happens if we have an
      <c>ArrayList&lt;Integer&gt;</c> and then call <c>remove(42)</c>? Should it
      call <c>remove(int)</c>, and remove the element at index <c>42</c> or
      should it autobox <c>42</c> and remove the first element of the list whose
      value is an <c>Integer</c> wrapping the value <c>42</c>?
    </p>

    <p>
      As it happens, Java goes with <c>remove(int)</c>. Which means the calls to
      <c>remove</c> below behave very differently:
    </p>

    <program>
      <![CDATA[
      ArrayList<Integer> nums = new ArrayList<>();
      nums.add(10);
      nums.add(20);
      nums.add(30);

      nums.remove(Integer.valueOf(0))
      nums.remove(0);
      nums.remove(Integer.valueOf(20))
      nums.remove(20);
      ]]>
    </program>

    <p>
      The first call to <c>remove</c> does nothing and returns false because
      there’s no <c>0</c> in the list. The second call removes the first element
      of the list, <c>10</c>, because the argument is treated as the index 0,
      not a value. The third call successfully removes the <c>20</c> from the
      list. And the fourth call crashes with an <c>IndexOutOfBoundsException</c>
      because 20, as an index, is way too big for the list which now only has
      one element in it.
    </p>

    <activity label="listRem">
      <statement>
        <p>
          Remember that the <c>remove(int index)</c> method removes a value from
          an <c>ArrayList</c> at a specific position decreasing the size of the
          list by one and shifting down the items that were at higher indexes in
          the array by one position. It also returns the item that was removed.
        </p>

        <p>
          What will the following code print out? Try to guess before you run
          it. Were you surprised? Read the note below.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*; // import all classes in this package.

          public class listRem
          {
              public static void main(String[] arts)
              {
                  ArrayList<Integer> list1 = new ArrayList<>();
                  list1.add(1);
                  list1.add(2);
                  list1.add(3);
                  System.out.println(list1);
                  list1.remove(1);
                  System.out.println(list1);
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("listRem");
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect = "[1, 2, 3]\n[1, 3]";

                  boolean passed = getResults(expect, output, "main()", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <activity label="qListRem">
      <statement>
        <p>What will print when the following code executes?</p>

        <program>
          <![CDATA[
          ArrayList<Integer> list1 = new ArrayList<>();
          list1.add(1);
          list1.add(2);
          list1.add(3);
          list1.remove(2);
          System.out.println(list1);
          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>[2, 3]</p>
          </statement>

          <feedback>
            <p>This would be true if it was <c>remove(0)</c></p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>[1, 2, 3]</p>
          </statement>

          <feedback>
            <p>
              The <c>remove</c> will remove a value from the list, so this can't
              be correct.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>[1, 2]</p>
          </statement>

          <feedback>
            <p>The 3 (at index 2) is removed</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>[1, 3]</p>
          </statement>

          <feedback>
            <p>This would be true if it was <c>remove(1)</c></p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      You can step through the code above by clicking on the following <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=import+java.util.*%3B%0A%0Apublic+class+ClassNameHere+%7B%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++List%3CInteger%3E+list1+%3D+new+ArrayList%3CInteger%3E()%3B%0A++++++list1.add(new+Integer(1))%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(new+Integer(2))%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(new+Integer(3))%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.remove(2)%3B%0A++++++System.out.println(list1)%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">RemoveExample</url>.
    </p>

        <activity label="qListRem1">
      <statement>
        <p>What will print when the following code executes?</p>

        <program>
          <![CDATA[
          ArrayList<Integer> list1 = new ArrayList<>();
          list1.add(1);
          list1.add(2);
          list1.add(3);
          list1.set(2, 4);
          list1.add(2, 5);
          list1.add(6);
          System.out.println(list1);
          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>[1, 2, 3, 4, 5]</p>
          </statement>

          <feedback>
            <p>
              The <c>set</c> will replace the item at index 2 so this can not be
              right.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>[1, 2, 4, 5, 6]</p>
          </statement>

          <feedback>
            <p>
              The <c>add</c> with an index of 2 and a value of 5 adds the 5 at
              index 2 not 3. Remember that the first index is 0.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>[1, 2, 5, 4, 6]</p>
          </statement>

          <feedback>
            <p>
              The <c>set</c> will change the item at index 2 to 4. The add of 5
              at index 2 will move everything else to the right and insert 5.
              The last <c>add</c> will be at the end of the list.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>[1, 5, 2, 4, 6]</p>
          </statement>

          <feedback>
            <p>
              The <c>add</c> with an index of 2 and a value of 5 adds the 5 at
              index 2 not 1. Remember that the first index is 0.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      You can step through the code above by clicking on the following <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=import+java.util.*%3B%0A%0Apublic+class+ClassNameHere+%7B%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++%0A++++++ArrayList%3CInteger%3E+list1+%3D+new+ArrayList%3CInteger%3E()%3B%0A++++++list1.add(1)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(2)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(3)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.set(2,4)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(2,5)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(6)%3B%0A++++++System.out.println(list1)%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Example1</url>.
    </p>
  </subsection>





  <subsection xml:id="summary-48">
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            The <c>Integer</c> class and <c>Double</c> class are <term>wrapper
            classes</term> that create objects from primitive types.
          </p>
        </li>

        <li>
          <p>
            (AP 4.7.A.1) The <c>Integer</c> class and <c>Double</c> class are
            part of the <c>java.lang</c> package.
          </p>
        </li>

        <li>
          <p>
            (AP 4.7.A.1) An <c>Integer</c> object is immutable, meaning once an
            <c>Integer</c> object is created, its attributes cannot be changed.
            A <c>Double</c> object is immutable, meaning once a <c>Double</c>
            object is created, its attributes cannot be changed.
          </p>
        </li>

        <li>
          <p>
            (AP 4.7.A.2) <term>Autoboxing</term> is the automatic conversion
            that the Java compiler makes between primitive types and their
            corresponding object wrapper classes. This includes converting an
            <c>int</c> to an <c>Integer</c> and a <c>double</c> to a
            <c>Double</c>. The Java compiler applies autoboxing when a primitive
            value is:
          </p>

          <p>
            <ul>
              <li>
                <p>
                  passed as a parameter to a method that expects an object of
                  the corresponding wrapper class
                </p>
              </li>

              <li>
                <p>assigned to a variable of the corresponding wrapper class</p>
              </li>
            </ul>
          </p>
        </li>

        <li>
          <p>
            (AP 4.7.A.3) <term>Unboxing</term> is the automatic conversion that
            the Java compiler makes from the wrapper class to the primitive
            type. This includes converting an <c>Integer</c> to an <c>int</c>
            and a <c>Double</c> to a <c>double</c>. The Java compiler applies
            unboxing when a wrapper class object is:
          </p>

          <p>
            <ul>
              <li>
                <p>
                  passed as a parameter to a method that expects a value of the
                  corresponding primitive type
                </p>
              </li>

              <li>
                <p>
                  assigned to a variable of the corresponding primitive type
                </p>
              </li>
            </ul>
          </p>
        </li>

        <li>
          <p>
            (AP 4.7.A.4) The following class <c>Integer</c> method—including
            what it does and when it is used—is part of the Java Quick
            Reference: <c>static int parseInt(String s)</c> returns the
            <c>String</c> argument as a signed <c>int</c>.
          </p>
        </li>

        <li>
          <p>
            (AP 4.7.A.5) The following class <c>Double</c> method—including what
            it does and when it is used—is part of the Java Quick Reference:
            <c>static double parseDouble(String s)</c> returns the <c>String</c>
            argument as a signed <c>double</c>.
          </p>
        </li>
      </ul>
    </p>
  </subsection>
</section>
