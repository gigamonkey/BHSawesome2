<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-4-8-arraylists">
  <title><c>ArrayList</c> and its methods</title>

  <introduction>
    <idx>arraylist</idx>
    <idx>ArrayList</idx>
    <idx><h>arraylist</h><h>definition</h></idx>
    <figure>
      <caption>A couple of lists</caption>
      <image source="Unit4-Data-Collections/Figures/lists.jpg" width="54%" />
    </figure>

    <p>
      Unlike arrays which are built into Java the language and are used with
      special syntax such as array initializers like <c>new int[] { 1, 2, 3
      }</c> and array access expressions like <c>nums[0]</c>, and even unlike
      the <c>String</c> class which gets some special support from the language,
      <c>ArrayList</c> is a class that we could write ourselves if it didn’t
      exist. In other words <c>ArrayList</c> is a new class abstraction that
      hides some of the messy details of using an array to represent a
      collection of values when we want to be able to change the number of
      values in the collection over time.
    </p>

    <p>
      Thus to learn how to use it we just need to learn about its public API—the
      constructors and methods the class provides. The whole API is quite large
      and is fully documented in the <url
      href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/ArrayList.html">class’s
      Javadocs</url>. But for our purposes we only need to know a handful of
      methods which we’ll cover in this chapter.
    </p>

    <note>
      <p>
        An <c>ArrayList</c> is often called just a list. Prior to 2020 the AP
        CSA curriculum included <term>interfaces</term> which are somewhat like
        classes and the interface <c>List</c> was often used to declare a
        variable that would refer to an <c>ArrayList</c>. Interfaces are no
        longer on the exam, but if you see <c>List</c> being used in an old exam
        question just assume it’s an <c>ArrayList</c>. You will also see
        references to <c>List</c> if you read the <c>ArrayList</c> javadocs.
      </p>
    </note>
  </introduction>

  <activity label="qloopList">
    <statement>
      <p>
        Which of the following is a reason to use an ArrayList instead of an
        array?
      </p>
    </statement>

    <choices>
      <choice>
        <statement>
          <p>An ArrayList will always use less memory than an array.</p>
        </statement>

        <feedback>
          <p>
            No, The underlying array in an <c>ArrayList</c> is actually usually
            bigger than the number of values stored in the <c>ArrayList</c>. It
            is expanded as needed by making a new bigger array, usually twice
            the size of the old array, and copying values from the old array
            into the new one.
          </p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>
            An ArrayList can store objects, but arrays can only store primitive
            types.
          </p>
        </statement>

        <feedback>
          <p>No, arrays can store both primitive and reference types while
          <c>ArrayList</c>s can only store reference types. We’ll see in the
          next section how to use <term>wrapper classes</term> to make
          <c>ArrayList</c> that hold <c>int</c> and <c>double</c> values.</p>
        </feedback>
      </choice>

      <choice>
        <statement>
          <p>
            An ArrayList has faster access to the last element than an array.
          </p>
        </statement>

        <feedback>
          <p>
            No, an <c>ArrayList</c> is implemented using an array so the time to
            access an element of an array list is essentially the same same as
            the time to access the element of the underlying array.
          </p>
        </feedback>
      </choice>

      <choice correct="yes">
        <statement>
          <p>
            An ArrayList resizes itself as necessary as items are added, but an
            array does not.
          </p>
        </statement>

        <feedback>
          <p>
            An <c>ArrayList</c> can grow or shrink as needed.
          </p>
        </feedback>
      </choice>
    </choices>
  </activity>

  <subsection xml:id="import-java-util-arraylist">
    <title>import java.util.ArrayList</title>

    <idx>import</idx>
    <idx>java.util</idx>
    <p>
      Recall from <xref ref="packages" /> that classes in Java are organized
      into packages. The standard Java classes we have used until now,
      <c>String</c> and <c>Math</c>, are in the special package <c>java.lang</c>
      whose classes are always available in any Java program so we’ve been able
      to refer to them without doing anything special.
    </p>

    <p>
      <c>ArrayList</c>, on the other hand, is in a different package, called
      <c>java.util</c>. That means that if we want to use <c>ArrayList</c> in a
      program we need to either <term>import</term> it or (much more rarely)
      refer to it by its full name which includes the package as a prefix:
      <c>java.util.ArrayList</c>. But rather than type that out all the time
      we’ll almost always use an <c>import</c> statement.
    </p>

    <p>
      Import statements have to come before the class definition in a Java
      source file and serve to tell Java which class we mean when we use a short
      name like <c>ArrayList</c>. To import just one class we use a single
      <c>import</c> of the fully-qualified name of the class like this:
    </p>

    <program>
      // Import just the ArrayList class from java.util
      import java.util.ArrayList;
    </program>

    <idx>package</idx>
    <idx><h>statement</h><h>import</h></idx>
    <p>
      Anywhere <c>ArrayList</c> is used in a class containing that import
      statement it will be taken to mean <c>java.util.ArrayList</c>.
    </p>

    <p>
      Another option is to import all the classes in a package with a “wildcard”
      import:
    </p>

    <program>
      // Import everything in java.util including ArrayList
      import java.util.*;
    </program>

    <p>
      This import statement will also cause, <c>ArrayList</c> to refer
      <c>java.util.ArrayList</c>. But many other names of classes defined in the
      <c>java.util</c> package will also be available whether you use them or
      not. (One that you have probably used by now is <c>Scanner</c> which can
      be used to read input a user types at the command line.) Using wildcard
      imports can cause conflicts if you import all the classes from two
      different packages and they have class names in common but usually that’s
      not a problem, at least with packages that are part of Java itself.
    </p>

    <note>
      <p>
        Don’t worry about adding import statements on the AP CSA exam. Any that
        you need will be provided for you.
      </p>
    </note>

    <activity label="qlib_1">
      <statement>
        <p>Which of the following is true about import statements?</p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>You can only have one import statement in a source file.</p>
          </statement>

          <feedback>
            <p>You can have an many import statements as you need.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>You must specify the class to import.</p>
          </statement>

          <feedback>
            <p>You can use * to import all classes at the specified level.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>
              Import statements must be before other code in a Java source file.
            </p>
          </statement>

          <feedback>
            <p>
              Import statements have to be the first Java statements in a source
              file.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              You must import java.lang.String to use the short name of String.
            </p>
          </statement>

          <feedback>
            <p>
              You do not have to import any classes that are in the java.lang
              package.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="declaring-and-creating-arraylists">
    <title>Declaring <c>ArrayList</c> variables</title>

    <p>
      Just like when we declare an array and have to specify what kind of array
      it is in terms of what kind of values it can hold (e.g. <c>String[]</c> vs
      <c>int[]</c>), when we declare an <c>ArrayList</c> we also need to specify
      what kind of values it will hold. The syntax is slightly different from
      the array declaration syntax and is actually an example of a feature of
      Java called <term>generic types</term>. Generic types are not otherwise
      covered in the AP curriculum but are an important part of real-world Java
      programming.
    </p>

    <p>
      To declare an <c>ArrayList</c> variable we write the type of the variable
      as <c>ArrayList&lt;Type&gt; name</c> where <em>Type</em>, called a
      <term>type parameter</term>, is the type of the objects we want to store
      in the <c>ArrayList</c>.
    </p>

    <p>
      For example a variable whose type is an <c>ArrayList</c> meant to hold
      <c>String</c> values is declared as <c>ArrayList&lt;String&gt;</c> as
      shown in the code below.
    </p>

    <program>
      <![CDATA[
      ArrayList<String> shoppingList;
      ]]>
    </program>

    <p>
      If you look at the <c>ArrayList</c> javadocs you’ll see the class listed
      as <c>ArrayList&lt;E&gt;</c>. The <c>E</c> is the name for the type
      parameter and tells us that we need to provide an actual type like
      <c>String</c> when we declare an <c>ArrayList</c>. If you look at the
      Javadocs for <c>ArrayList</c> methods (or at the <url
      href="https://apcentral.collegeboard.org/media/pdf/ap-computer-science-a-java-quick-reference.pdf">AP
      CSA Java Quick Reference Sheet</url>) you’ll see the <c>E</c> again as the
      type of method parameters and return types. That means that those methods
      take parameters and return values of whatever specific type you specified
      when you declared a particular <c>ArrayList</c>.
    </p>

    <p>
      For example the <c>add</c> method has the signature <c>boolean add(E
      e)</c> which means if you’ve declared an <c>ArrayList&lt;String&gt;</c>
      then, for that <c>ArrayList</c>, it’s as if the <c>add</c> method had the
      signature <c>boolean add(String e)</c> which makes sure that no code can
      add anything other than a <c>String</c> to that <c>ArrayList</c>.
    </p>

    <p>
      Similarly the <c>get</c> method has the signature <c>E get(int index)</c>
      which means that the values returned by <c>get</c> from the same
      <c>ArrayList</c> will be of type <c>String</c> so we can safely use
      <c>String</c> methods on them.
    </p>

    <note>
      <p>
        It is legal to declare a variable to just be of type <c>ArrayList</c>,
        with no type parameter, but you’ll get a warning from the compiler about
        <term>raw types</term>. That raw types are allowed at all is due to the
        history of how generic types were added to Java and a desire to add the
        feature to the language without breaking older Java code. These days you
        should always specify the type of objects you intend to store in an
        <c>ArrayList</c> as it allows the compiler to find errors that would
        otherwise not be detected until run time.
      </p>
    </note>
  </subsection>

  <subsection>
    <title><c>ArrayList</c> constructors</title>
    <p>
      As with other reference types, declaring a <c>ArrayList</c> variable
      doesn’t actually create an object; it just creates a variable that can
      hold a reference to an <c>ArrayList</c> or the special reference
      <c>null</c>.
    </p>

    <p>
      To actually create a <c>ArrayList</c> we must invoke a constructor. The
      main <c>ArrayList</c> constructor takes no arguments and returns an empty
      <c>ArrayList</c>. There are two ways to invoke the constructor: <c>new
      ArrayList&lt;String&gt;()</c> with a type parameter or <c>new
      ArrayList&lt;&gt;()</c> without the type parameter. The latter way is
      generally preferred; in most contexts, such as when initializing a
      variable declaration Java will <term>infer</term> the necessary type
      parameter so you don’t have to specify it twice:
    </p>

    <program>
      <![CDATA[
      ArrayList<String> strings = new ArrayList<>();
      ]]>
    </program>

    <p>
      Another useful constructor, though not officially part of the AP
      curriculum, is the copy constructor that takes another <c>ArrayList</c>
      and makes a new <c>ArrayList</c> containing the same values:
    </p>

    <program>
      <![CDATA[
      ArrayList<String> copyOfStrings = new ArrayList<>(strings);
      ]]>
    </program>

    <p>
      The type parameter of an <c>ArrayList</c> can be any reference type
      including classes that we write, such as the <c>Student</c> or
      <c>Person</c>, classes that other programmers have written such as
      <c>Turtle</c>, or even arrays like <c>int[]</c> though it is a bit odd to
      mix <c>ArrayList</c>s and arrays that way.
    </p>

    <p>
      However the type parameter cannot be a primitve type so we cannot make an
      <c>ArrayList&lt;int&gt;</c> or <c>ArrayList&lt;double&gt;</c>. In the next
      section we’ll discuss how to use wrapper classes to work around that
      limitation.
    </p>

    <program>
      <![CDATA[
      // An ArrayList of Students:
      ArrayList<Student> roster = new ArrayList<>();
      // An ArrayList of Turtles:
      ArrayList<Turtle> turtles = new ArrayList<>();
      // An ArrayList of arrays of int
      ArrayList<int[]> arrays = new ArrayList<>();
      ]]>
    </program>

    <activity label="ArrayListCreateStr">
      <statement>
        <p>
          The code below uses the <c>size</c> method which will discuss in a
          moment to show how many elements are in an <c>ArrayList</c>. Notice
          that a newly constructed <c>ArrayList</c> is empty and thus has a size
          of 0.
        </p>

        <p>
          The following code also has a bug that leads to a
          <c>NullPointerException</c>. Change the list2 declaration so that it
          creates a new <c>ArrayList</c> to remove the
          <c>NullPointerException</c>.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*; // import needed for ArrayList

          public class ArrayListCreateStr
          {
              public static void main(String[] args)
              {
                  ArrayList<String> nameList = new ArrayList<String>();
                  System.out.println("The size of nameList is: " + nameList.size());
                  ArrayList<String> list2 = null;
                  System.out.println("The size of list2 is: " + list2.size());
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("ArrayListCreateStr");
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect = "The size of nameList is: 0\nThe size of list2 is: 0";

                  boolean passed = getResults(expect, output, "main()", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>


  </subsection>

  <subsection xml:id="arraylist-methods">
    <title><c>ArrayList</c> methods</title>

    <idx><h>arraylist</h><h>size</h></idx>
    <idx><h>arraylist</h><h>add</h></idx>
    <idx><h>arraylist</h><h>get</h></idx>
    <idx><h>arraylist</h><h>set</h></idx>
    <idx><h>arraylist</h><h>remove</h></idx>
    <idx><h>arraylist</h><h>removing an item</h></idx>
    <idx><h>arraylist</h><h>getting an item</h></idx>
    <idx><h>arraylist</h><h>setting an item</h></idx>

    <p>
      The following are the <c>ArrayList</c> methods that you need to know for
      the AP CSA exam. These are included on the <url
      href="https://apcentral.collegeboard.org/media/pdf/ap-computer-science-a-java-quick-reference.pdf">AP
      CSA Java Quick Reference Sheet</url> that you will receive during the exam
      so you do not need to memorize them. As we discussed above the <c>E</c> in
      the method headers is a placeholder for the specific type used when we
      declare an specific <c>ArrayList</c>.
    </p>

    <p>
      <ul>
        <li>
          <p>
            <c>int size()</c> returns the number of elements in the list. An
            empty list has size 0.
          </p>
        </li>

        <li>
          <p>
            <c>boolean add(E obj)</c> appends <c>obj</c> to the end of the
            list and returns <c>true</c>
          </p>
        </li>

        <li>
          <p>
            <c>E get(int index)</c> returns the item in the list at the position
            <c>index</c>. The <c>index</c> must be a valid index into the list.
            As with array and <c>String</c> indexes, index of the first item in
            an <c>ArrayList</c> is <c>0</c> and the last valid index is one less
            than the <c>size()</c> of the list.
          </p>
        </li>

        <li>
          <p>
            <c>E set(int index, E obj)</c> replaces the item at position
            <c>index</c> with <c>obj</c> which must be a valid index into the
            list.
          </p>
        </li>

        <li>
          <p>
            <c>E remove(int index)</c> removes the item at the index
            <c>index</c> and shifts remaining items to the left (to a lower
            index), returning the removed item. The <c>index</c> argument must
            be a valid index into the list.
          </p>
        </li>

        <li>
          <p>
            <c>void add(int index, E obj)</c> moves any objects at positions
            greater than or equal to <c>index</c> to the right (to a higher
            indexes) and inserts <c>obj</c> at the position <c>index</c>. The
            <c>index</c> argument must be a valid index or exactly the
            <c>size()</c> of the list in which case the item is added at the end
            of the list.
          </p>
        </li>

      </ul>
    </p>

    <note>
      <p>
        Java is unfortunately all over the map when it comes to how to get the
        number of items in different data structures. With an array, we use the
        <c>length</c> <em>field</em> to get the number of items in the array
        while with a <c>String</c> we use the <c>length()</c> <em>method</em> to
        get the number of characters in the <c>String</c>. And with an
        <c>ArrayList</c> we use the <c>size()</c> method to get the number of
        items in the list. Mixing these up is a common mistake for new Java
        programmers. However you will not be penalized if you mix them up on the
        AP exam.
      </p>
    </note>

    <activity label="listAdd">
      <statement>
        <p>
          The code below demonstrates using the <c>add</c> method to add values
          to the end of a list and the <c>size</c> method to get the size after
          addingn several items.
        </p>
        <p>
          Can you add another item to the shopping list and print out the new
          list and its new size?
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*;

          public class Shopping
          {
              public static void main(String[] args)
              {
                  ArrayList<String> shoppingList = new ArrayList<>();
                  System.out.println("Size: " + shoppingList.size());
                  shoppingList.add("carrots");
                  System.out.println(shoppingList);
                  shoppingList.add("bread");
                  System.out.println(shoppingList);
                  shoppingList.add("chocolate");
                  System.out.println(shoppingList);
                  System.out.println("Size: " + shoppingList.size());
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("Shopping");
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect =
                          "Size: 0\n"
                              + "[carrots]\n"
                              + "[carrots, bread]\n"
                              + "[carrots, bread, chocolate]\n"
                              + "Size: 3";

                  boolean passed = !output.equals(expect);

                  passed = getResults(expect, output, "Changed code", passed);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <activity label="StudentArrayList">
      <statement>
        <p>
          An example of an <c>ArrayList</c> of <c>Student</c> objects. Add a new
          student with your name and info.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*;

          public class StudentList
          {
              // main method for testing
              public static void main(String[] args)
              {
                  ArrayList<Student> roster = new ArrayList<>();
                  roster.add(new Student("Skyler", "skyler@sky.com", 123456));
                  roster.add(new Student("Ayanna", "ayanna@gmail.com", 789012));

                  System.out.println(roster);
              }
          }

          class Student
          {
              private String name;
              private String email;
              private int id;

              public Student(String initName, String initEmail, int initId)
              {
                  name = initName;
                  email = initEmail;
                  id = initId;
              }

              // toString() method
              public String toString()
              {
                  return id + ": " + name + ", " + email;
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("StudentList");
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect = "[123456: Skyler, skyler@sky.com, 789012: Ayanna, ayanna@gmail.com]";

                  boolean passed = getResults(expect, output, "main()", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <activity label="listGetSet">
      <statement>
        <p>
          You can get the object at an index using <c>obj = listName.get(index)</c>
          and set the object at an index using <c>listName.set(index,obj)</c>. Both
          methods require that the index argument refer to an existing element of
          the list, i.e. the index must be greater than or equal to 0 and less than
          the <c>size()</c> of the list.
        </p>

        <p>
          These methods are the <c>ArrayList</c> equivalents of the array access
          expressions (<c>array[idx]</c>) we use to access elements of arrays.
        </p>

        <p>
          Try to guess what the code below will print before running it. Can you
          get the last element in the nameList to print it out? Can you set the
          first element in the list to your name and print out the list?
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*; // import all classes in this package.

          public class listGetSet
          {
              public static void main(String[] args)
              {
                  ArrayList<String> nameList = new ArrayList<>();
                  nameList.add("Diego");
                  nameList.add("Grace");
                  nameList.add("Deja");
                  System.out.println(nameList);
                  System.out.println(nameList.get(0));
                  System.out.println(nameList.get(1));
                  nameList.set(1, "John");
                  System.out.println(nameList);
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("listGetSet");
              }

              @Test
              public void test1()
              {
                  boolean passed =
                          checkCodeContainsRegex("nameList.set(0, \"Your name\")", "nameList.set(0, ");
                  assertTrue(passed);
              }

              @Test
              public void test2()
              {
                  String output = getMethodOutput("main");
                  String searchString = "Deja";

                  boolean passed =
                          output.contains("\n" + searchString)
                                  || output.matches("\\s+" + searchString + "\\s+");

                  passed = getResults("true", "" + passed, "Prints last item in list (Deja)", passed);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>



    <activity label="qListRem2">
      <statement>
        <p>What will print when the following code executes?</p>

        <program>
          <![CDATA[
          List<String> list1 = new ArrayList<String>();
          list1.add("Anaya");
          list1.add("Layla");
          list1.add("Sharrie");
          list1.set(1, "Destini");
          list1.add(1, "Sarah");
          System.out.println(list1);
          ]]>
        </program>

        <p>
          You can step through the code by clicking on the following <url
          href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=import+java.util.*%3B%0A%0Apublic+class+ClassNameHere+%7B%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++%0A++++++List%3CString%3E+list1+%3D+new+ArrayList%3CString%3E()%3B%0A++++++list1.add(%22Anaya%22)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(%22Layla%22)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(%22Sharrie%22)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.set(1,+%22Destini%22)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(1,+%22Sarah%22)%3B%0A++++++System.out.println(list1)%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Example2</url>.
        </p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>["Sarah", "Destini", "Layla", "Sharrie"]</p>
          </statement>

          <feedback>
            <p>Remember that the first index is 0 not 1.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>["Sarah", "Destini", "Anaya", "Layla", "Sharrie"]</p>
          </statement>

          <feedback>
            <p><c>set</c> changes the value and the first index is 0 not 1.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>["Anaya", "Sarah", "Sharrie"]</p>
          </statement>

          <feedback>
            <p>
              <c>add</c> at index 1 adds the new value at that index but moves
              right any existing values.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>["Anaya", "Sarah", "Destini", "Sharrie"]</p>
          </statement>

          <feedback>
            <p>
              The list is first ["Anaya", "Layla", "Sharrie"] and then changes
              to ["Anaya", Destini", "Sharrie"] and then to ["Anaya", "Sarah",
              "Destini", "Sharrie"]
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>




    <activity label="listAddInt2">
      <statement>
        <p>
          Remember that there are two different <c>add</c> methods in the
          <c>ArrayList</c> class. The <c>add(obj)</c> method adds the passed
          object to the end of the list while <c>add(index,obj)</c> method adds
          the passed object at the passed index, but first moves over any
          existing values to higher indices to make room for the new object.
        </p>

        <p>
          What will the code below print out? Try figuring it out before running
          it.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*; // import all classes in this package.

          public class listAddInt2 {

              public static void main(String[] arts) {
                  ArrayList<String> list = new ArrayList<>();

                  list.add("foo");
                  System.out.println(list);

                  list.add("bar");
                  System.out.println(list);

                  list.add(1, "baz");
                  System.out.println(list);

                  list.add(1, "quux");
                  System.out.println(list);

                  System.out.println(list.size());
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("listAddInt2");
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect = "[foo]\n[foo, bar]\n[foo, baz, bar]\n[foo, quux, baz, bar]\n4\n";

                  boolean passed = getResults(expect, output, "main()", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <activity label="qalAdd2">
      <statement>
        <p>What will print when the following code executes?</p>

        <program>
          <![CDATA[
          ArrayList<String> list1 = new ArrayList<String>();
          list1.add("Anaya");
          list1.add("Layla");
          list1.add("Sharrie");
          list1.add(1, "Sarah");
          System.out.println(list1);
          ]]>
        </program>

        <p>
          You can step through the code by clicking on the following <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=import+java.util.*%3B%0A%0Apublic+class+ClassNameHere+%7B%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++%0A++++++List%3CString%3E+list1+%3D+new+ArrayList%3CString%3E()%3B%0A++++++list1.add(%22Anaya%22)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(%22Layla%22)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(%22Sharrie%22)%3B%0A++++++System.out.println(list1)%3B%0A++++++list1.add(1,+%22Sarah%22)%3B%0A++++++System.out.println(list1)%3B%0A++++++%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=0">Java
          Visualizer</url>.
        </p>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>["Anaya", "Sarah", "Layla", "Sharrie"]</p>
          </statement>

          <feedback>
            <p>
              The <c>add(1, "Sarah")</c> will move any current items to the
              right and then put "Sarah" at index 1.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>["Anaya", "Layla", "Sharrie", "Sarah"]</p>
          </statement>

          <feedback>
            <p>This would be true if the last one was <c>add("Sarah")</c></p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>["Sarah", "Anaya", "Layla", "Sharrie"]</p>
          </statement>

          <feedback>
            <p>This would be true if the last one was <c>add(0, "Sarah")</c></p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>["Anaya", "Layla", "Sarah", "Sharrie"]</p>
          </statement>

          <feedback>
            <p>This would be true if the last one was <c>add(2, "Sarah")</c></p>
          </feedback>
        </choice>
      </choices>
    </activity>


  </subsection>

  <subsection xml:id="comparing-arrays-and-arraylists">
    <title>When to use an array vs an <c>ArrayList</c>?</title>

    <p>
      Suppose we need to store a collection of values. How do we decide when to
      use an array vs an <c>ArrayList</c>? Often the choice is obvious: if we
      want to store a collection of values that can grow or shrink we definitely
      want to use an <c>ArrayList</c>.
    </p>

    <p>
      And even if we don’t think we need to grow or shrink our collection an
      <c>ArrayList</c> is often still a good choice. While you need to know how
      to use arrays to be a competent Java programmer (and to do well on the AP
      exam) in day-to-day programming you can get pretty far just using
      <c>ArrayList</c> when you need a collection of values.
    </p>

    <p>
      That said, arrays have some advantages: precisely because they are
      relatively limited, they are also very efficient. And because they have
      special syntax in the language they can be easier to use.
    </p>

    <p>
      For instance, if we were writing a chess game and wanted to represent the
      chess board we could use a two-dimensional array of <c>Piece</c> objects
      like this:
    </p>

    <program>
      <![CDATA[
      Piece[][] board = new Piece[8][8];
      board[0][0] = new Piece("black", "rook");
      ]]>
    </program>

    <p>
      Simply constructing the array allocates memory to hold sixty-four
      <c>Piece</c> objects and then we can set an element with the simple array
      access expression <c>board[0][0]</c>.
    </p>

    <p>
      Compare that to what we have to do to use nested <c>ArrayList</c>s.
    </p>

    <program>
      <![CDATA[
      ArrayList<ArrayList<Piece>> board = new ArrayList<>();

      // Need to make all the nested ArrayLists and fill them out
      for (int i = 0; i < 8; i++) {
        ArrayList<Piece> row = new ArrayList<>();
        for (int j = 0; j < 8; j++) {
          row.add(null);
        }
        board.add(row);
      }

      // To set an particular square we get the row and then set the column.
      board.get(0).set(0, new Piece("black", "rook"));
      ]]>
    </program>

    <p>
      Pretty much everything about the <c>ArrayList</c> version, from the type
      of the variable to the code we have to write to initialize things and then
      the code to access elements of the nested <c>ArrayList</c>s is way more
      complicated with no real benefit since the size of the chess board is
      never going to change.
    </p>

    <p>
      The other place arrays have some advantages are in dealing with primitive
      values since an <c>ArrayList</c> can really only hold reference types.
      We’ll look at that issue in more detail in the next section.
    </p>

    <p>
      Here is a comparison of how to access and change elements in an array vs
      an <c>ArrayList</c>. Note that <c>ArrayList</c>s have a method
      <c>size()</c> instead of a <c>length</c> property, and <c>ArrayList</c>s
      use <c>get</c>/<c>set</c> methods instead of the index operator
      (<c>[]</c>).
    </p>

    <table>
      <tabular row-headers="yes">
        <col top="minor" />
        <col top="minor" />
        <col top="minor" />
        <row header="yes" left="minor">
          <cell bottom="minor" right="minor">Operation</cell>
          <cell bottom="minor" right="minor">array</cell>
          <cell bottom="minor" right="minor">ArrayList</cell>
        </row>

        <row left="minor">
          <cell bottom="minor" right="minor">length/size</cell>
          <cell bottom="minor" right="minor">array.length</cell>
          <cell bottom="minor" right="minor">list.size()</cell>
        </row>

        <row left="minor">
          <cell bottom="minor" right="minor">Access</cell>
          <cell bottom="minor" right="minor">value = array[index];</cell>
          <cell bottom="minor" right="minor">value = list.get(index);</cell>
        </row>

        <row left="minor">
          <cell bottom="minor" right="minor">Modify</cell>
          <cell bottom="minor" right="minor">array[index] = value;</cell>
          <cell bottom="minor" right="minor">list.set(index,value);</cell>
        </row>
      </tabular>
    </table>

    <p>
      Note that the <c>ArrayList</c> methods <c>add</c> and <c>remove</c> do not
      have a simple equivalent in arrays because they change the number of
      elements in the list and may shift the positions of other elements.
    </p>

    <p>
      Here is a <url
      href="https://drive.google.com/file/d/1EzkHa3TNlbHOKVeZReQIf4HzuwwXsCAV/view?usp=sharing">comparison
      handout</url> of the basic operations to access one- and two-dimensional
      arrays, <c>ArrayList</c>s, and <c>String</c>s made by AP CSA teacher Sam
      Procopio of Bishop Blanchet High School.
    </p>

    <activity label="array-to-arraylist">
      <statement>
        <p>
          Rewrite the following code that uses an array to use an
          <c>ArrayList</c> instead. In the comments write why you think an
          <c>ArrayList</c> is a better data structure to use than an array for
          this problem.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          import java.util.*;

          public class ToDoList
          {
              public static void main(String[] args)
              {
                  // Rewrite this code to use an ArrayList instead of an array
                  String[] toDoList = new String[3];
                  toDoList[0] = "Do homework";
                  toDoList[1] = "Help make dinner";
                  toDoList[2] = "Call grandma";

                  // changing element 1
                  toDoList[1] = "Order pizza";

                  System.out.println(toDoList.length + " things to do!");
                  System.out.println("Here's the first thing to do: " + toDoList[0]);

                  // remove item 0 and move everything down
                  //  (this can be done in one method call with ArrayList)
                  toDoList[0] = toDoList[1];
                  toDoList[1] = toDoList[2];
                  toDoList[2] = "";

                  System.out.println("Here's the next thing to do: " + toDoList[0]);

                  // Why is an ArrayList better than an array for a toDoList?
                  // Answer:
              }
          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("ToDoList");
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect =
                          "3 things to do!\n"
                              + "Here's the first thing to do: Do homework\n"
                              + "Here's the next thing to do: Order pizza";

                  boolean passed = getResults(expect, output, "Output is the same");
                  assertTrue(passed);
              }

              @Test
              public void test2()
              {
                   boolean passed = checkCodeContains("ArrayList<String>");
                   assertTrue(passed);
              }
              @Test
              public void contains2()
              {
                   boolean passed = checkCodeContains(".add");
                   assertTrue(passed);
              }

              @Test
              public void test3()
              {
                  String expect = "[*]";

                  boolean passed = checkCodeNotContains(expect);
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </activity>

    <p>
      Although it is not on the AP exam, you can convert an array to a
      <c>List</c> using the static method <c>asList</c> from the <c>Arrays</c>
      helper class: <c>Arrays.asList(arrayname)</c>. Note that <c>ArrayList</c>
      has a <c>toString</c> method that is automatically called to print the
      list in a nice format.
    </p>

    <activity label="ArrayListFromArray">
      <statement>
        <p>Example code creating an ArrayList from an array.</p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          import java.util.*;

          public class ArrayListFromArray
          {
              public static void main(String[] args)
              {
                  String[] names = {"Dakota", "Madison", "Brooklyn"};
                  ArrayList<String> namesList = new ArrayList<>(Arrays.asList(names));
                  System.out.println(namesList);
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("ArrayListFromArray");
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect = "[Dakota, Madison, Brooklyn]";

                  boolean passed = getResults(expect, output, "main()", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>



  <subsection xml:id="summary-49">
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            <term>ArrayLists</term> are re-sizable lists that allow adding and
            removing items to change their size during run time.
          </p>
        </li>

        <li>
          <p>
            (AP 4.8.A.4) The <c>ArrayList</c> class is part of the
            <c>java.util</c> package. An <c>import</c> statement can be used to
            make this class available for use in the program.(import
            <c>java.util.ArrayList</c> or <c>java.util.*</c>).
          </p>
        </li>

        <li>
          <p>
            (AP 4.8.A.1) An <c>ArrayList</c> object is <term>mutable</term> in
            size and contains object references. (Mutable means that it can
            change by adding and removing items from it.
          </p>
        </li>

        <li>
          <p>
            (AP 4.8.A.2) The <c>ArrayList</c> constructor <c>ArrayList()</c>
            constructs an empty list (of size 0).
          </p>
        </li>

        <li>
          <p>
            (AP 4.8.A.3) Java allows the generic type <c>ArrayList&lt;E&gt;</c>,
            where the generic type <c>E</c> specifies the type of the elements.
            (Without it, the type will be <c>Object</c>). When
            <c>ArrayList&lt;E&gt;</c> is specified, the types of the reference
            parameters and return type when using its methods are type <c>E</c>.
          </p>
        </li>

        <li>
          <p>
            (AP 4.8.A.3) <c>ArrayList&lt;E&gt;</c> is preferred over
            <c>ArrayList</c> (which creates an list of type <c>Object</c>). For
            example, <c>ArrayList&lt;String&gt; names = new
            ArrayList&lt;String&gt;();</c> allows the compiler to find errors
            that would otherwise be found at run time.
          </p>
        </li>

        <li>
          <p>
            <c>ArrayList</c>s cannot hold primitive types like <c>int</c> or
            <c>double</c>, so you must use the wrapper classes <c>Integer</c> or
            <c>Double</c> to put numerical values into an <c>ArrayList</c>.
            However autoboxing usually takes care of that for you.
          </p>
        </li>

        <li>
          <p>
            (AP 4.8.A.6) The indices for an <c>ArrayList</c> start at <c>0</c>
            and end at the number of elements <c>- 1</c>.
          </p>
        </li>

        <li>
          <p>
            (AP 4.8.A.5) The following ArrayList methods, including what they do
            and when they are used, are part of the Java Quick Reference:
          </p>

          <p>
            <ul>
              <li>
                <p>
                  <term>int size()</term> : Returns the number of elements in
                  the list
                </p>
              </li>

              <li>
                <p>
                  <term>boolean add(E obj)</term> : Appends obj to end of list;
                  returns true
                </p>
              </li>

              <li>
                <p>
                  <term>void add(int index, E obj)</term> : Inserts obj at
                  position index (0 &lt;= index &lt;= size), moving elements at
                  position index and higher to the right (adds 1 to their
                  indices) and adds 1 to size
                </p>
              </li>

              <li>
                <p>
                  <term>remove(int index)</term> — Removes element from position
                  index, moving elements at position index + 1 and higher to the
                  left (subtracts 1 from their indices) and subtracts 1 from
                  size; returns the element formerly at position index
                </p>
              </li>

              <li>
                <p>
                  <term>E get(int index)</term> : Returns the element at
                  position index in the list
                </p>
              </li>

              <li>
                <p>
                  <term>E set(int index, E obj)</term> : Replaces the element at
                  position index with obj; returns the element formerly at
                  position index
                </p>
              </li>
            </ul>
          </p>
        </li>
      </ul>
    </p>
  </subsection>
</section>
