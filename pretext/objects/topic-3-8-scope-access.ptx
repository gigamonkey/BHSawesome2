<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-3-8-scope-access">
  <title>Some odds and ends</title>

  <introduction>
    <idx>scope</idx>
    <idx>access</idx>
    <idx>local variable</idx>
    <p>
      Now that we know about classes and objects we know enough to talk about a
      few odds and ends that are important but don’t really fit in anywhere
      else.
    </p>

    <p>
      To start with, we’ll finally get to understand what the <c>static</c>
      keyword, which we’ve been using without a lot of explanation, is actually
      for. We’ll learn about how the <term>scope</term> of variables controls
      where we can refer to what variables, about how to use the <c>final</c>
      modifier to make some variables immutable, and how to use the <term>access
      modifiers</term> <c>public</c> and <c>private</c> to control what code can
      access the variables and methods in our classes,
    </p>

  </introduction>

  <subsection xml:id="class-methods-vs-instance-methods">
    <title>Class methods vs. instance methods</title>

    <p>
      In <xref ref="topic-1-9-method-signatures" /> when we first learned to
      write methods we made all our methods <c>static</c>. Then in <xref
      ref="topic-3-5-methods" /> we learned about instance methods. As you may
      have already figured out the important difference between <c>static</c>
      and instance methods is that instance methods must be invoked on a
      specific object—an instance of the class—in order to be able to access the
      instance variables stored in that object.
    </p>

    <p>
      Methods declared with the <c>static</c> modifier, on the other hand don’t
      have access to instance variables because they are not invoked on any
      particular object. They are also called <term>class methods</term> because
      we can think of them as belonging to the class as a whole, rather than to
      any specific instance of the class.
    </p>

    <p>
      Within a class we can call <c>static</c> methods defined in that class by
      their simple name, even from instance methods. But code in <c>static</c>
      methods will not have access to <c>this</c> so won’t be able to reference
      instance variables or call non-<c>static</c> methods without being given
      an instance to call them on.
    </p>

    <p>
      To call static methods from a different class, we call them on the class
      itself, as we first saw in <xref ref="topic-1-11-Math" /> when we learned
      how to call the <c>static</c>methods in the <c>Math</c> class. Class
      methods are called using the class name followed by the dot (.) operator
      and the method name, example, <c>Math.sqrt(25);</c> calls the <c>sqrt</c>
      method in the <c>Math</c> class.
    </p>

    <p>
      The following flowchart shows the difference between calling class
      (static) methods and instance methods. Static methods are called using the
      class name, for example, <c>Math.sqrt(25);</c>. Instance methods are
      called using an object of the class, for example,
      <c>yertle.forward();</c>. Traditionally, class names are capitalized, and
      object variables are lowercase.
    </p>

    <figure align="center">
      <caption>Calling static vs. instance methods</caption>

      <image source="Unit1-Using-Objects-and-Methods/Figures/calling-static-vs-instance-methods.png" width="63%">
        <shortdescription>Calling static vs. instance methods</shortdescription>
      </image>
    </figure>

    <activity label="staticmethods">
      <statement>
        <p>
          Note that the static method <c>printStatic</c> has errors in it
          because it cannot access the instance variables and methods. Fix
          <c>printStatic</c> by giving it a <c>Person</c> parameter and then
          accessing the instance variables and methods of that object. Then fix
          the method call to <c>printStatic</c> in <c>main</c> to pass in an
          object as an argument.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private String email;

              // constructor
              public Person(String initName, String initEmail) {
                  name = initName;
                  email = initEmail;
              }

              // instance method
              public void print() {
                  System.out.println(name + ": " + email);
              }

              // static method
              public static void printStatic() {
                  System.out.println("Static methods cannot access instance variables.");
                  // The following lines will cause errors

                  // TODO: Fix this by giving this method a Person parameter
                  // and acces the name of that Person and call print on that object.
                  System.out.println(name);
                  print();
              }

              public static void main(String[] args) {
                  Person p = new Person("Jana", "jana@gmail.com");

                  // Call p's instance method to print
                  p.print();

                  // Call printStatic with the class name
                  // Note this has errors.
                  // TODO: Fix the errors by passing the object p as an argument
                  Person.printStatic();
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() {
                  String target = "printStatic(p)";
                  boolean passed = checkCodeContains(target, target);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String target = "printStatic(Person";
                  boolean passed = checkCodeContains(target, target);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <p>
      This example also shows how instance methods easily share data variables
      without the need for parameters. Whereas, static methods cannot directly
      access the instance methods. They are often used for utility methods, like
      Math operations, that do not need access to the instance variables of an
      object.
    </p>
  </subsection>

  <subsection xml:id="class-variables">
    <title>Class variables</title>

    <p>
      Like class methods, <term>class variables</term> are declared with the
      <c>static</c> modifier before the variable type. Class variables belong to
      the class as a whole rather than to a specific object so each
      <c>static</c> variable is shared by all instances of the class. Class
      variables that are declared <c>public</c> can be accessed by code outside
      of the class by using the class name and the dot operator. <c>Math.PI</c>
      is an example of such a variable. Within a class all code can access
      <c>static</c> variables by their simple name.
    </p>

    <p>
      In the following class <c>Person</c>, there is a <c>static</c> variable
      called <c>personCounter</c> that is incremented each time the
      <c>Person</c> constructor is called to initialize a new <c>Person</c>
      object. The static method <c>printCounter</c> prints out its value. You
      can also watch how it works in the <url
      href="http://www.pythontutor.com/visualize.html#code=%20public%20class%20Person%20%0A%20%20%7B%0A%20%20%20%20%20//%20instance%20variables%20%0A%20%20%20%20%20private%20String%20name%3B%0A%20%20%20%20%20private%20String%20email%3B%0A%20%20%20%20%20private%20String%20phoneNumber%3B%0A%20%20%20%20%20%0A%20%20%20%20%20//%20Static%20counter%20variable%0A%20%20%20%20%20public%20static%20int%20personCounter%20%3D%200%3B%0A%20%20%20%20%20%0A%20%20%20%20%20//%20static%20method%20to%20print%20out%20counter%0A%20%20%20%20%20public%20static%20void%20printPersonCounter%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20System.out.println%28%22Person%20counter%3A%20%22%20%2B%20personCounter%29%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20%0A%20%20%20%20%20//%20constructor%3A%20construct%20a%20Person%20copying%20in%20the%20data%20into%20the%20instance%20variables%0A%20%20%20%20%20public%20Person%28String%20initName,%20String%20initEmail,%20String%20initPhone%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20name%20%3D%20initName%3B%0A%20%20%20%20%20%20%20%20email%20%3D%20initEmail%3B%0A%20%20%20%20%20%20%20%20phoneNumber%20%3D%20initPhone%3B%0A%20%20%20%20%20%20%20%20personCounter%2B%2B%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20%0A%20%20%20%20%20//%20toString%28%29%20method%0A%20%20%20%20%20public%20String%20toString%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20return%20%20name%20%2B%20%22%3A%20%22%20%2B%20email%20%2B%20%22%20%22%20%2B%20phoneNumber%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20%0A%20%20%20%20%20//%20main%20method%20for%20testing%0A%20%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20//%20call%20the%20constructor%20to%20create%20a%20new%20person%0A%20%20%20%20%20%20%20%20Person%20p1%20%3D%20new%20Person%28%22Sana%22,%20%22sana%40gmail.com%22,%20%22123-456-7890%22%29%3B%0A%20%20%20%20%20%20%20%20Person%20p2%20%3D%20new%20Person%28%22Jean%22,%20%22jean%40gmail.com%22,%20%22404%20899-9955%22%29%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20Person.printPersonCounter%28%29%3B%0A%20%20%20%20%20%7D%0A%20%20%7D%0A%20%20&amp;cumulative=false&amp;curInstr=1&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">Java
      visualizer</url> by clicking the CodeLens button below.
    </p>

    <activity label="PersonClassStaticCounter">
      <statement>
        <p>
          What will the following code print out? Try adding another Person
          object and see what happens. Try the CodeLens button to run the code
          step by step.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private String email;
              private String phoneNumber;

              // Static counter variable
              public static int personCounter = 0;

              // static method to print out counter
              public static void printPersonCounter() {
                  System.out.println("Person counter: " + personCounter);
              }

              // constructor: construct a Person copying in the data into the instance
              // variables
              public Person(String initName, String initEmail, String initPhone) {
                  name = initName;
                  email = initEmail;
                  phoneNumber = initPhone;
                  personCounter++;
              }

              // toString() method
              public String toString() {
                  return name + ": " + email + " " + phoneNumber;
              }

              // main method for testing
              public static void main(String[] args) {
                  // call the constructor to create a new person
                  Person p1 = new Person("Sana", "sana@gmail.com", "123-456-7890");
                  Person p2 = new Person("Jean", "jean@gmail.com", "404 899-9955");

                  Person.printPersonCounter();
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "Person counter: 2";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <p>
      Another common use for static variables is the keep track of a minimum or
      maximum value or an average of the values in a collection of objects.
    </p>

    <activity label="staticTrace">
      <statement>
        <p>
          Consider the class Temperature below which has a static variable. What
          is the output of the main method below?
        </p>

        <program>
          <![CDATA[
          public class Temperature {
              private double temperature;
              public static double maxTemp = 0;

              public Temperature(double t) {
                  temperature = t;
                  if (t > maxTemp) {
                      maxTemp = t;
                  }
              }

              public static void main(String[] args) {
                  Temperature t1 = new Temperature(75);
                  Temperature t2 = new Temperature(100);
                  Temperature t3 = new Temperature(65);
                  System.out.println("Max Temp: " + Temperature.maxTemp);
              }
          }
          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement id="staticTrace_opt_a">
            <p>Max Temp: 0</p>
          </statement>

          <feedback id="staticTrace_opt_a">
            <p>
              maxTemp is changed in each call to the Temperature() constructor.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="staticTrace_opt_b">
            <p>
              There is a compiler error because the static variable maxTemp
              cannot be used inside a non-static constructor.
            </p>
          </statement>

          <feedback id="staticTrace_opt_b">
            <p>
              Non-static methods and constructors can use any instance or static
              variables in the class.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="staticTrace_opt_c">
            <p>Max Temp: 100</p>
          </statement>

          <feedback id="staticTrace_opt_c">
            <p>
              Yes, maxTemp is initialized to 0 and then changed to 75 and then
              100 by the constructor calls.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="staticTrace_opt_d">
            <p>Max Temp: 75</p>
          </statement>

          <feedback id="staticTrace_opt_d">
            <p>
              maxTemp will be changed to 100 by the second constructor call
              since 100 &gt; 75.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="staticTrace_opt_e">
            <p>Max Temp: 65</p>
          </statement>

          <feedback id="staticTrace_opt_e">
            <p>
              maxTemp will not be changed to 65 by the third constructor call
              because 67 is not &gt; 100.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      You can see this code in action in the <url
      href="http://www.pythontutor.com/visualize.html#code=public%20class%20Temperature%20%0A%7B%0A%20%20%20private%20double%20temperature%3B%0A%20%20%20public%20static%20double%20maxTemp%20%3D%200%3B%0A%20%20%20%0A%20%20%20public%20Temperature%28double%20t%29%0A%20%20%20%7B%0A%20%20%20%20%20%20%20temperature%20%3D%20t%3B%0A%20%20%20%20%20%20%20if%20%28t%20%3E%20maxTemp%29%0A%20%20%20%20%20%20%20%20%20%20%20maxTemp%20%3D%20t%3B%0A%20%20%20%7D%0A%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%7B%0A%20%20%20%20%20%20%20Temperature%20t1%20%3D%20new%20Temperature%2875%29%3B%0A%20%20%20%20%20%20%20Temperature%20t2%20%3D%20new%20Temperature%28100%29%3B%0A%20%20%20%20%20%20%20Temperature%20t3%20%3D%20new%20Temperature%2865%29%3B%0A%20%20%20%20%20%20%20System.out.println%28%22Max%20Temp%3A%20%22%20%2B%20Temperature.maxTemp%29%3B%0A%20%20%20%7D%0A%7D&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">Java
      visualizer</url>.
    </p>

    <activity label="TemperatureBugs">
      <statement>
        <p>
          Fix the bugs in the following code. Static methods should only access
          static variables.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          public class Temperature {
              private double temperature;
              public static double maxTemp = 0;

              public Temperature(double t) {
                  temperature = t;
                  if (t > maxTemp) {
                      maxTemp = t;
                  }
              }

              // This static method should print out the static variable
              public static printMax() {
                  System.out.println(temperature);
              }

              public static void main(String[] args) {
                  Temperature t1 = new Temperature(75);
                  Temperature t2 = new Temperature(100);
                  Temperature.printMax();
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testCodeContains1() {

                  boolean passed =
                          checkCodeContains("static printMax() header", "public static void printMax()");
                  assertTrue(passed);
              }

              @Test
              public void testCodeContains2() {
                  String code = getCode();
                  boolean passed =
                          code.contains("System.out.println(maxTemp);")
                                  || code.contains("System.out.println(Temperature.maxTemp);");
                  getResults("true", "" + passed, "printMax method returns the right value", passed);
                  assertTrue(passed);
              }

              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "100.0";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="class-method-and-block-level-scope">
    <title>Scope: class, method, and block level</title>

    <p>
      The <term>scope</term> of a variable is defined the textual part of a
      program where a variable can be referred to. The scope of a variable is
      determined by where you declare the variable when you write your programs.
      Roughly speaking each set of curly braces (<c>{}</c>) encloses a scope.
      Thus scopes can be nested within each other.
    </p>

    <p>
      The largest scope is called <term>class scope</term> and consists of the
      whole body of a class between the opening and closing <c>{}</c>’s of the
      class. So all static and non-static variables declared at the top-level of
      a class are in class scope and can be referred to any code anywhere else
      in the same class. (Note, however, that being in scope is not the only
      requirement; code in a static method can’t access an instance variable in
      the same class not because it’s not in scope but because instance
      variables can’t be accessed by static code.)
    </p>

    <p>
      The next smaller scope, <term>method scope</term>, is defined by the body
      of a method or constructor. It includes the parameter declarations even
      though they are outside the curly braces the define the body of a method
      or constructor. This is why variables defined as method parameters or
      declared within the body of a method can only be referred to by code
      within that same method. It’s also why two different methods can have
      parameters with the same name without conflict because each method defines
      its own scope.
    </p>

    <p>
      Finally we have <term>block scope</term> which is defined by control
      constructs within methods and constructors that have their own bodies such
      as <c>for</c> and <c>while</c> loop and <c>if</c> statements. The curly
      braces that mark the bodies of <c>while</c> loops and <c>if</c> statements
      create a block scope in which new variables can be declared that can only
      be referred to within those curly braces. And <c>for</c> loops define a
      scope that includes both the body within the curly braces but also the
      initializer, condition, and updater in the loop header. This is why when
      we write a loop like this we can only refer to <c>i</c> within the loop:
    </p>

    <program>
      <![CDATA[
      for (int i = 0; i < 10; i++) {
        System.out.println(i);
      }
      // can't access i here, out of scope
      ]]>
    </program>

    <p>
      Block scopes can be nested within each other. For instance in the nested
      loops below, the code of the inner loop can refer to the variable <c>i</c>
      defined in the outer loop but code outside the inner loop can’t refer to
      <c>j</c>.
    </p>

    <program>
      <![CDATA[
      for (int i = 0; i < 10; i++) {
        for (int j = i; j < 10; j++) {
          System.out.println("i: " + i + "; j: " + j);
        }
        // can't access j here, out of scope
      }
      // can't access i here, out of scope
      ]]>
    </program>

    <p>The image below shows the three basic levels of scope.</p>

    <figure align="center">
      <caption>Class, method, and block scope</caption>

      <image source="Unit3-Class-Creation/Figures/scopeDiagram.png" width="89%">
        <shortdescription>Scope Levels</shortdescription>
      </image>
    </figure>

    <note>
      <p>
        Java inherits its basic scope model from Algol 60, invented in the
        1960s. In most languages in that lineage variables in a nested scope
        with the same name as a variable defined in an enclosing scope
        <term>shadow</term> the variable, meaning that within the inner scope
        the name refers to the variable declared in the the inner scope and the
        variable from the outer scope is not accessible. This is sometimes
        convenient but can also lead to subtle bugs.
      </p>

      <p>
        Java’s designers, under the assumption that eliminating the bugs caused
        by accidentally shadowing variables is worth the slight inconvenience of
        having to pick all unique names for variables within a single method
        scope, disallowed shadowing of method and block scoped variables.
      </p>

      <p>
        Java does allow locally scoped variables shadow to shadow class scoped
        variables which is why we can define constructors with parameter names
        that are the same as the names of instance variables and then use the
        <c>this.x = x</c> to set the instance variable to the value of a
        parameter with the same name.
      </p>
    </note>

    <activity label="name_class_scope">
      <statement>
        <p>
          Click on all the variable declarations that are at class scope.
        </p>
      </statement>

      <feedback>
        <p>
          Remember that the instance variables declared at the top of the class
          have class scope.
        </p>
      </feedback>

      <areas>
        <cline><area correct="no">public class Name</area></cline>
        <cline><area correct="no">{</area></cline>
        <cline>    <area correct="yes">private String first;</area></cline>
        <cline>    <area correct="yes">public String last;</area></cline>
        <cline />
        <cline>    <area correct="no">public Name(String theFirst, String theLast)</area></cline>
        <cline>    <area correct="no">{</area></cline>
        <cline>        <area correct="no">String firstName = theFirst;</area></cline>
        <cline>        <area correct="no">first = firstName;</area></cline>
        <cline>        <area correct="no">last = theLast;</area></cline>
        <cline>    <area correct="no">}</area></cline>
        <cline><area correct="no">}</area></cline>
      </areas>
    </activity>

    <activity label="name_method_scope">
      <statement>
        <p>
          Click on all the variable declarations that are at Method Level Scope.
        </p>
      </statement>

      <feedback>
        <p>
          Remember that the parameter variables and the local variables declared
          inside a method have Method Level Scope.
        </p>
      </feedback>

      <areas>
        <cline><area correct="no">public class Name</area></cline>
        <cline><area correct="no">{</area></cline>
        <cline>    <area correct="no">private String first;</area></cline>
        <cline>    <area correct="no">public String last;</area></cline>
        <cline />
        <cline>    public Name(<area correct="yes">String theFirst</area>, <area correct="yes">String theLast</area>)</cline>
        <cline>    <area correct="no">{</area></cline>
        <cline>        <area correct="yes">String firstName = theFirst;</area></cline>
        <cline>        <area correct="no">first = firstName;</area></cline>
        <cline>        <area correct="no">last = theLast;</area></cline>
        <cline>    <area correct="no">}</area></cline>
        <cline><area correct="no">}</area></cline>
      </areas>
    </activity>

    <activity label="PersonScope">
      <statement>
        <p>
          Try the following code to see that you cannot access the variables
          outside of their scope levels in the toString() method. Explain to
          someone sitting next to you why you can’t access these. Try to fix the
          errors by either using variables that are in scope or moving the
          variable declarations so that the variables have larger scope.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          public class Person {
              private String name;
              private String email;

              public Person(String initName, String initEmail) {
                  name = initName;
                  email = initEmail;
              }

              public String toString() {
                  for (int i = 0; i < 5; i++) {
                      int id = i;
                  }
                  // Can you access the blockScope variables i or id?
                  System.out.println("i at the end of the loop is " + i);
                  System.out.println("The last id is " + id);

                  // Can toString() access parameter variables in Person()?
                  return initName + ": " + initEmail;
              }

              // main method for testing
              public static void main(String[] args) {
                  // call the constructor to create a new person
                  Person p1 = new Person("Sana", "sana@gmail.com");
                  System.out.println(p1);
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testCodeContains() {
                  boolean passed =
                          checkCodeContains("returning instance variables", "return  name + \": \" + email;");
                  assertTrue(passed);
              }

              @Test
              public void testCodeContains2() {
                  boolean passed =
                          checkCodeContains("declaration and initialization of id to 0", "int id = 0;");
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <activity label="PersonLocalVar">
      <statement>
        <p>
          In this example, the local variable is used instead of the instance
          variable of the same name. What will the code print out? Try it with
          the CodeLens button.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              private String name;
              private String email;

              public Person(String initName, String initEmail) {
                  name = initName;
                  email = initEmail;
              }

              public String toString() {
                  String name = "unknown";
                  // The local variable name here will be used,
                  //  not the instance variable name.
                  return name + ": " + email;
              }

              // main method for testing
              public static void main(String[] args) {
                  // call the constructor to create a new person
                  Person p1 = new Person("Sana", "sana@gmail.com");
                  System.out.println(p1);
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "unknown: sana@gmail.com";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="final-keyword">
    <title>The <c>final</c> keyword</title>

    <p>
      The keyword <term>final</term> is used for a few things in Java but the
      only one we need to know about is as a modifier in a variable declaration.
      When we include <c>final</c> before the type in a variable declaration it
      tells Java that we want the variable to be immutable. Thus if we declare a
      variable to be <c>final</c> and later write code that tries to assign a
      new value to the variable, the compiler will give us an error.
    </p>

    <p>
      There are two main ways to use <c>final</c> variables. Perhaps the
      simplest is when we want to define a constant value in which case we
      usually combine it with <c>static</c> to make a <c>static final</c>
      variable. For instance the variable <c>PI</c> is a <c>public static
      final</c> variable in the <c>Math</c> class which means it can be
      referenced by code anywhere as <c>Math.PI</c> . And since it’s
      <c>final</c> we don’t have to worry about some code accidentally
      redefining <m>π</m>. Constants defined this way are typicall given all
      uppercase names.
    </p>

    <p>
      The other main way to use <c>final</c> is when we are defining a class
      whose instances are immutable. If we declare all the class’s instance
      variables to be <c>final</c> then the instances will be immutable. As a
      convinence we can declare variables as <c>final</c> without providing an
      initial value as long as they are initialized in every constructor. For
      instance, if we wanted our <c>Address</c> class to have immutable
      instances we might write it like this:
    </p>

    <program>
      class Address {
          private final String street;
          private final String city;
          private final String state;
          private final String zipcode;

          public Address(String street, String city, String state, String zipcode) {
              this.street = street;
              this.city = city;
              this.state = state;
              this.zipcode = zipcode;
          }

          public String getStreet() {
            return street;
          }
          public String getCity() {
            return city;
          }
          public String getState() {
            return state;
          }
          public String getZipcode() {
            return zipcode;
          }
      }
    </program>

    <p>
      In a class like this, with no setters defined, as long as the instance
      variables are <c>private</c>, the instances would effectively be immutable
      even without the <c>final</c> modifiers because there’s no code in the
      class that ever changes them and code outside the class can’t. But it can
      still be useful to mark variables as <c>final</c> both to make your intent
      clear (even to yourself) and also to get help from the compiler if you
      forget and write some code that tries to change the value of something
      that’s not supposed to change.
    </p>

    <activity label="finalPi">
      <statement>
        <p>
          Try the following code and notice the syntax error when we try to
          change the constant PI. Put the comment symbols // in front of that
          line to remove the error and run it again.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class TestFinal {
              // A static final variable for PI
              public static final double PI = 3.14;

              public static void main(String[] args) {
                  System.out.println(PI);
                  PI = 4.2; // This will cause a syntax error
              }
          }
        </code>

        <tests>
          // should pass if/when they run code
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "3.14";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="acessibility">
    <title>Accessibility: <c>public</c> and <c>private</c></title>

    <p>
      In <xref ref="classes" /> we covered the main uses of the <c>public</c>
      and <c>private</c> <term>accessibility modifiers</term>. These modifiers
      are another way to control what code is allowed to use a variable or
      method. In particular, they control whether variables, constructors, and
      methods in one class can be accessed or invoked by code in other classes.
    </p>

    <p>
      This is a bit different from the scope of variables because code in
      different classes are never in the same scope. This is about whether some
      code can use <c>obj.foo</c> or <c>obj.bar()</c> to access a variable named
      <c>foo</c> or to invoke a method named <c>bar</c> defined in whatever
      class <c>obj</c> is an instance of.
    </p>

    <p>
      The basics are <c>public</c> members are can accessible to code in any
      class and <c>private</c> members are only accessibel to code within the
      same class.
    </p>

    <p>
      The short version of how to use these two modifiers, which are a good set
      of rules for basic Java programming and everything you need to know for
      the AP exam is:
    </p>

    <p>
      <ul>
        <li>Instance variables should always be marked <c>private</c>.</li>
        <li>Constructors are always <c>public</c>.</li>
        <li>Methods are always <c>public</c>.</li>
      </ul>
    </p>

    <p>
      In reality things are, of course, a bit more complicated.
    </p>

    <p>
      The first rule is basically always true. It is far better to keep instance
      variables <c>private</c> and then write getters and setters as appropriate
      both to keep fine grained control over what code can modify instances of
      your class but also to not tie yourself down to a particular set of
      variables as the way you want to hold the data that makes up instances of
      a class.
    </p>

    <p>
      The rule also applies to <c>static</c> variables unless they are also
      <c>final</c> in which case they can be made <c>public</c> if they are
      meant to defined a value that is useful outside of the class, like
      <c>Math.PI</c>.
    </p>

    <p>
      Constructors and methods, however, require more judgement. Often as we
      break up big methods into smaller methods we will write methods that
      shouldn’t be used directly by code outside the class; those methods should
      be declared <c>private</c> so we know they are only used within the class.
      And sometimes, though less commonly, we will have constructors that are
      only meant to be used internally. Those constructors can also be made
      <c>private</c>. Though do note if a class doesn’t have <em>any</em>
      <c>public</c> constructors, there will be no way for any code outside the
      class to make instances of it.
    </p>

  </subsection>

  <subsection xml:id="coding-challenge-debugging">
    <title>Coding Challenge: Debugging</title>

    <project label="challenge-scope-debug">
      <statement>
        <p>
          Debug the following program that has scope violations. You may need to
          add methods or use methods that are in the class Fraction
          appropriately. Then, add comments that label the variable declarations
          as class, method, or block scope.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class TesterClass {
              public static void main(String[] args) {
                  Fraction f1 = new Fraction();
                  Fraction f2 = new Fraction(1, 2);
                  System.out.println(f1);
                  System.out.println(f2.numerator / f2.denominator);
              }
          }

          /** Class Fraction */
          class Fraction {
              //  instance variables
              private int numerator;
              private int denominator;

              // constructor: set instance variables to default values
              public Fraction() {
                  int d = 1;
                  numerator = d;
                  denominator = d;
              }

              // constructor: set instance variables to init parameters
              public Fraction(int initNumerator, int initDenominator) {
                  numerator = initNumerator;
                  denominator = initDenominator;
              }

              public String toString() {
                  // if the denominator is 1, then just return the numerator
                  if (denominator == d) {
                      int newNumerator = 1;
                  }
                  return newNumerator + "/" + denominator;
              }
          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              public RunestoneTests() {
                  super("TesterClass");
              }

              @Test
              public void test1() {
                  String orig =
                          "public class TesterClass\n"
                                  + "{\n"
                                  + "   public static void main(String[] args)\n"
                                  + "   {\n"
                                  + "      Fraction f1 = new Fraction();\n"
                                  + "      Fraction f2 = new Fraction(1,2);\n"
                                  + "      System.out.println(f1);\n"
                                  + "      System.out.println(f2.numerator / f2.denominator);\n"
                                  + "   }\n"
                                  + " }\n\n"
                                  + "/** Class Fraction */\n"
                                  + "class Fraction\n"
                                  + "{\n"
                                  + "   //  instance variables\n"
                                  + "   private int numerator;\n"
                                  + "   private int denominator;\n\n"
                                  + "   // constructor: set instance variables to default values\n"
                                  + "   public Fraction()\n"
                                  + "   {\n"
                                  + "      int d = 1;\n"
                                  + "      numerator = d;\n"
                                  + "      denominator = d;\n"
                                  + "   }\n\n"
                                  + "   // constructor: set instance variables to init parameters\n"
                                  + "   public Fraction(int initNumerator, int initDenominator)\n"
                                  + "   {\n"
                                  + "      numerator = initNumerator;\n"
                                  + "      denominator = initDenominator;\n"
                                  + "   }\n\n"
                                  + "   public String toString()\n"
                                  + "   {\n"
                                  + "     // if the denominator is 1, then just return the numerator\n"
                                  + "     if (denominator == d) {\n"
                                  + "        int newNumerator = 1;\n"
                                  + "     }\n"
                                  + "     return newNumerator + \"/\" + denominator;\n"
                                  + "   }\n"
                                  + "}\n";

                  boolean passed = codeChanged(orig);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String expect = "1\n1/2";
                  String actual = getMethodOutput("main");

                  boolean passed = getResults(expect, actual, "Testing main()");
                  assertTrue(passed);
              }

              @Test
              public void test3() {
                  String code = getCodeWithoutComments();
                  int count = countOccurences(code, "private");
                  boolean passed = (count >= 2);
                  getResults(
                          "2 private vars",
                          count + " private vars",
                          "Keep the instance variables private! Use other Fraction methods.",
                          passed);
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </project>
  </subsection>

    <subsection xml:id="coding-challenge-static-song-and-counter">
    <title>Coding Challenge: Static Song and counter</title>

    <p>
      In <xref ref="topic-1-9-method-signatures"/>, we wrote a class with
      methods to print out the song <url
      href="https://www.youtube.com/watch?v=QPwEZ8Vv2YQ">The Ants Go
      Marching</url>. Here’s the song with three verses, where the chorus is the
      last two lines of each verse:
    </p>

    <program>
      Verse 1:
      The ants go marching one by one, hurrah, hurrah
      The ants go marching one by one, hurrah, hurrah
      The ants go marching one by one
      The little one stops to suck a thumb
      And they all go marching down to the ground
      To get out of the rain, BOOM! BOOM! BOOM! BOOM!

      Verse 2:
      The ants go marching two by two, hurrah, hurrah
      The ants go marching two by two, hurrah, hurrah
      The ants go marching two by two
      The little one stops to tie a shoe
      And they all go marching down to the ground
      To get out of the rain, BOOM! BOOM! BOOM! BOOM!

      Verse 3:
      The ants go marching three by three, hurrah, hurrah
      The ants go marching three by three, hurrah, hurrah
      The ants go marching three by three
      The little one stops to climb a tree
      And they all go marching down to the ground
      To get out of the rain, BOOM! BOOM! BOOM! BOOM!
    </program>

    <p>
      Let’s create a class to print out the song with two methods
      <c>chorus()</c> and <c>verse</c>, where the verse takes two parameters for
      the numbers and the action. Notice that this is a class where there are no
      instance variables and we don’t really need to generate multiple objects.
      With students or pets, it makes sense to have multiple objects. With a
      class printing out a song, we can just make the methods static and have
      just one copy of them.
    </p>

    <p>
      <ol>
        <li>
          <p>
            Create a class called <c>Song</c> with two static methods:
            <c>chorus()</c> and <c>verse()</c>. The chorus method prints out the
            last two lines of each verse. The verse method takes two parameters,
            a number and an action, and prints out the verse with the number and
            action.
          </p>
        </li>

        <li>
          <p>
            Add a public static variable called <term>numVerses</term> to the
            class that keeps track of the number of verses. Increment this
            variable in the method verse and print it out at the beginning of
            the verse.
          </p>
        </li>
      </ol>
    </p>

    <project label="antsong-static-challenge">
      <statement>
        <p>
          This class should print out the <url
          href="https://www.youtube.com/watch?v=QPwEZ8Vv2YQ">The Ants Go
          Marching</url> Song using two static methods: <c>chorus()</c> and
          <c>verse()</c>. The chorus method should print out the last two lines
          of each verse. The verse method should take two parameters, a number
          and an action, and print out the verse with the number and action. Add
          a public static variable called <term>numVerses</term> that keeps
          track of the number of verses. Increment this variable in the method
          verse and print it out at the beginning of the verse.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Song {
              // Add a public static variable called numVerses

              // Add a static chorus method

              // Add a static verse method with two parameters

              public static void main(String args[]) {
                  // Print out the static variable numVerses
                  // and call the static methods to print out the Song for 3 verses

              }
          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @After
              public void tearDown() {
                  super.tearDown();
                  // Song.numVerses = 0;

              }

              @Test
              public void checkCodeContains1() {
                  // check verse 1
                  boolean passed =
                          checkCodeContains(
                                  "verse(...) method header with two String parameters",
                                  "public static void verse(String *, String *)");

                  assertTrue(passed);
              }

              @Test
              public void checkCodeContains2() {
                  // check static
                  String code = getCode();
                  int actual = countOccurences(code, "Song.verse(");
                  String expected = "3";

                  boolean passed = actual >= 3;
                  getResults(
                          expected,
                          "" + actual,
                          "Checking that code contains three calls to verse(...) method using"
                                  + " ClassName.staticMethod(...) syntax",
                          passed);
                  assertTrue(passed);
              }

              @Test
              public void checkCodeContains3() {
                  // check static
                  String code = getCode();
                  int actual = countOccurences(code, "public static int numVerses = 0");
                  String expected = "1";

                  boolean passed = actual >= 1;
                  getResults(
                          expected,
                          "" + actual,
                          "Checking that code declares variable numVerses according to instructions and sets"
                                  + " it to zero",
                          passed);

                  assertTrue(passed);
              }

              @Test
              public void checkCodeContains4() {
                  // check static
                  String code = getCode();
                  boolean increment = code.contains("numVerses++");
                  String expected = "increments: true\n";
                  String actual = "increments: " + increment + "\n";

                  String anytext = "[\\s\\S]*";
                  String regex = "System.out.print[ln]*\\([\"a-zA-Z0-9 +]*numVerses[\"a-zA-Z0-9 +]*\\);";
                  boolean printed = code.matches(anytext + regex + anytext);
                  expected += "prints: true";
                  actual += "prints: " + printed;

                  boolean passed = increment && printed;
                  getResults(expected, actual, "Checking that code increments and prints numVerses", passed);

                  assertTrue(passed);
              }

              @Test
              public void testVerses() throws IOException {
                  String output = getMethodOutput("main").replaceAll(" his ", " a ").replaceAll("\n\n", "\n");
                  String[] actualArray = output.split("\n");

                  boolean passed = true;
                  String error = "";
                  String expect = "No errors";
                  String actual = "No errors";

                  int j = 0;

                  for (int i = 0; i < actualArray.length; i++) {
                      while (j < expectedArray.length && expectedArray[j].length() < 2) j++;
                      while (i < expectedArray.length && actualArray[i].length() < 2) i++;

                      if (j < expectedArray.length && actualArray[i].length() > 1) {
                          /*
                           * System.out.println(expectedArray[j]);
                           * System.out.println(actualArray[i]);
                           * System.out.println();
                           */
                          if (actualArray[i].matches("[\\s\\S]*[0-9]+[\\s\\S]*")) {
                              continue;
                          }

                          String compAct = removeSpaces(actualArray[i].toLowerCase());
                          String compExp = removeSpaces(expectedArray[j].toLowerCase());

                          if (!compAct.equals(compExp)) {
                              expect = expectedArray[j].trim();
                              actual = actualArray[i].trim() + "\n(Error on line " + (i + 1) + " of output)";
                              passed = false;
                              error =
                                      "\n"
                                              + "There may be more than one error! Did you forget a line?\n"
                                              + "(check spelling, new lines, and punctuation carefully)";
                              break;
                          }
                      }

                      j++;
                  }

                  getResults(expect, actual, "Checking output from main" + error, passed);
                  assertTrue(passed);
              }

              private static String expectedOutput =
                      "The ants go marching one by one, hurrah, hurrah\n"
                              + "The ants go marching one by one, hurrah, hurrah\n"
                              + "The ants go marching one by one\n"
                              + "The little one stops to suck a thumb\n"
                              + "And they all go marching down to the ground\n"
                              + "To get out of the rain, BOOM! BOOM! BOOM! BOOM!\n"
                              + "\n"
                              + "The ants go marching two by two, hurrah, hurrah\n"
                              + "The ants go marching two by two, hurrah, hurrah\n"
                              + "The ants go marching two by two\n"
                              + "The little one stops to tie a shoe\n"
                              + "And they all go marching down to the ground\n"
                              + "To get out of the rain, BOOM! BOOM! BOOM! BOOM!\n"
                              + "\n"
                              + "The ants go marching three by three, hurrah, hurrah\n"
                              + "The ants go marching three by three, hurrah, hurrah\n"
                              + "The ants go marching three by three\n"
                              + "The little one stops to climb a tree\n"
                              + "And they all go marching down to the ground\n"
                              + "To get out of the rain, BOOM! BOOM! BOOM! BOOM!";
              private static String[] expectedArray = expectedOutput.replaceAll("\n\n", "\n").split("\n");
          }
          ]]>
        </tests>

      </program>
    </project>
  </subsection>

  <subsection xml:id="summary-34">
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 3.7.A.1) Class methods cannot access or change the values of
            instance variables or call instance methods without being passed an
            instance of the class via a parameter.
          </p>
        </li>

        <li>
          <p>
            (AP 3.7.A.2) Class methods can access or change the values of class
            variables and can call other class methods.
          </p>
        </li>

        <li>
          <p>
            (AP 3.7.B.1) Class variables belong to the class, with all objects
            of a class sharing a single copy of the class variable. Class
            variables are designated with the <term>static</term> keyword before
            the variable type.
          </p>
        </li>

        <li>
          <p>
            (AP 3.7.B.2) Class variables that are designated <c>public</c> are
            accessed outside of the class by using the class name and the dot
            operator, since they are associated with a class, not objects of a
            class.
          </p>
        </li>

        <li>
          <p>
            (AP 3.7.B.3) When a variable is declared <c>final</c>, its value
            cannot be modified.
          </p>
        </li>

        <li>
          <p>
            <term>Scope</term> is defined as where a variable is accessible or
            can be used.
          </p>
        </li>

        <li>
          <p>
            (AP 3.8.A.1) <term>Local variables</term> are variables declared in
            the headers or bodies of blocks of code. Local variables can only be
            accessed in the block in which they are declared.
          </p>
        </li>

        <li>
          <p>
            (AP 3.8.A.1) Parameters to constructors or methods are also
            considered local variables. These variables may only be used within
            the constructor or method and cannot be declared to be <c>public</c>
            or <c>private</c>.
          </p>
        </li>

        <li>
          <p>
            (AP 3.8.A.2) When there is a local variable or parameter with the
            same name as an instance variable, the variable name will refer to
            the local variable instead of the instance variable within the body
            of the constructor or method.
          </p>
        </li>
      </ul>
    </p>
  </subsection>

  <subsection xml:id="ap-practice-22">
    <title>AP Practice</title>

    <activity label="AP5-8-1">
      <statement>
        <p>
          Consider the following class definitions. Which of the following best
          explains why the class will not compile?
        </p>

        <program>
          public class Party {
              private int boxesOfFood;
              private int numOfPeople;

              public Party(int people, int foodBoxes) {
                  numOfPeople = people;
                  boxesOfFood = foodBoxes;
              }

              public void orderMoreFood(int additionalFoodBoxes) {
                  int updatedAmountOfFood = boxesOfFood + additionalFoodBoxes;
                  boxesOfFood = updatedAmountOfFood;
              }

              public void eatFoodBoxes(int eatenBoxes) {
                  boxesOfFood = updatedAmountOfFood - eatenBoxes;
              }
          }
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>The class is missing an accessor method.</p>
          </statement>

          <feedback>
            <p>There is a scope violation.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              The instance variables boxesOfFood and numOfPeople should be
              designated public instead of private.
            </p>
          </statement>

          <feedback>
            <p>
              There is a scope violation. Instance variables are usually
              private.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The return type for the Party constructor is missing.</p>
          </statement>

          <feedback>
            <p>
              There is a scope violation. Constructors do not have return types.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>
              The variable updatedAmountOfFood is not defined in eatFoodBoxes
              method.
            </p>
          </statement>

          <feedback>
            <p>
              There is a scope violation. The updatedAmountOfFood variable is a
              local variable in another method.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The Party class is missing a constructor</p>
          </statement>

          <feedback>
            <p>There is a scope violation.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="AP5-8-2">
      <statement>
        <p>Consider the following class definition.</p>

        <program>
          public class Movie {
              private int currentPrice;
              private int movieRating;

              public Movie(int p, int r) {
                  currentPrice = p;
                  movieRating = r;
              }

              public int getCurrentPrice() {
                  int currentPrice = 16;
                  return currentPrice;
              }

              public void printPrice() {
                  System.out.println(getCurrentPrice());
              }
          }
        </program>

        <p>
          Which of the following reasons explains why the printPrice method is
          “broken” and only ever prints out a value of 16?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP5-8-2_opt_a">
            <p>
              The private variables currentPrice and movieRating are not
              properly initialized.
            </p>
          </statement>

          <feedback id="AP5-8-2_opt_a">
            <p>The constructor will initialize them.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP5-8-2_opt_b">
            <p>
              The private variables currentPrice and movieRating should have
              been declared public.
            </p>
          </statement>

          <feedback id="AP5-8-2_opt_b">
            <p>Instance variables should be private.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP5-8-2_opt_c">
            <p>The printPrice method should have been declared as private.</p>
          </statement>

          <feedback id="AP5-8-2_opt_c">
            <p>Methods are usually public.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP5-8-2_opt_d">
            <p>
              currentPrice is declared as a local variable in the
              getCurrentPrice method and set to 16, and will be used instead of
              the instance variable currentPrice.
            </p>
          </statement>

          <feedback id="AP5-8-2_opt_d">
            <p>Correct!</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP5-8-2_opt_e">
            <p>The currentPrice instance variable does not have a value.</p>
          </statement>

          <feedback id="AP5-8-2_opt_e">
            <p>Accessor methods are usually public.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>
</section>
