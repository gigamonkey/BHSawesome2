<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-3-8-scope-access">
  <title>Scope and Access</title>

  <introduction>
    <idx>scope</idx>
    <idx>access</idx>
    <idx>local variable</idx>
    <p>
      The <term>scope</term> of a variable is defined as where a variable is
      accessible or can be used. The scope is determined by where you declare
      the variable when you write your programs. When you declare a variable,
      look for the closest enclosing curly braces (<c>{}</c>) – this is its
      scope.
    </p>
  </introduction>
  <subsection xml:id="class-methods-vs-instance-methods">
    <title>Class Methods vs. Instance Methods</title>

    <p>
      In lessons 1.9 and 1.10, we learned how to call <term>class methods</term>
      (also called <term>static methods</term>). Class methods are called using
      the class name followed by the dot (.) operator and the method name,
      example, <c>Math.sqrt(25);</c> calls the <c>sqrt</c> method in the
      <c>Math</c> class to find the square root of 25. Class methods use the
      keyword <c>static</c> in their method signature. They do not access or
      change the attributes of an object.
    </p>

    <p>
      In this lesson, we will learn more about <term>instance methods</term>
      which are always called using an object of the class. They are not static
      methods. They access and change the attributes of the object they are
      called on, for example <c>yertle.forward()</c> changes the <c>Turtle</c>
      object yertle’s position.
    </p>

    <p>
      The following flowchart shows the difference between calling class
      (static) methods and instance methods. Static methods are called using the
      class name, for example, <c>Math.sqrt(25);</c>. Instance methods are
      called using an object of the class, for example,
      <c>yertle.forward();</c>. Traditionally, class names are capitalized, and
      object variables are lowercase.
    </p>

    <figure align="center">
      <caption>Calling static vs. instance methods</caption>

      <image source="Unit1-Using-Objects-and-Methods/Figures/calling-static-vs-instance-methods.png" width="63%">
        <shortdescription>Calling static vs. instance methods</shortdescription>
      </image>
    </figure>
  </subsection>

  <subsection xml:id="class-methods">
    <title>Class Methods</title>

    <p>
      Class methods belong to the class and not to any object of the class. They
      are called with the class name and the dot operator, like
      <c>ClassName.methodName();</c>, for example the Math methods like
      <c>Math.random();</c>. There is only one copy of a class variable or
      method for the whole class. For example, the main method is a class
      (static) method because there should only be 1 main method. If the method
      is in the same class, you can call it with or without the class name from
      other static methods in the class: <c>Classname.methodName();</c> or
      <c>staticMethodName();</c> or even with an object of the class:
      <c>objectName.methodName();</c>.
    </p>

    <program>
      // Calling class methods
      // ClassName.methodName();
      int x = Math.sqrt(9);

       // If the method is in the same class,
       // you can call it with or without the class name
       // from other static methods in the class
       ClassName.methodName();
       methodName();
    </program>

    <p>
      Let’s revisit the following flowchart to compare three different ways of
      calling methods. Class (static) methods are called using the class name.
      Instance methods can only be called using an object of the class. If you
      are calling the instance method from the main method or from another
      class, you must first create an object of that class and then call its
      methods using <c>object.methodName()</c>. If you are calling the method
      from within the same class, you can just call the method using
      <c>methodName()</c> which will refer to the current object.
    </p>

    <figure align="center">
      <caption>Comparing Method Calls to Static and Instance Methods</caption>

      <image source="Unit3-Class-Creation/Figures/FlowChartCallingMethods.png" width="98%">
        <shortdescription>
          Comparing method calls to static and instance methods
        </shortdescription>
      </image>
    </figure>

    <p>
      When writing class methods, they can be public or private. The static
      keyword is placed right after the public/private modifier and right before
      the type of variables and methods in their declarations.
    </p>

    <program>
      public class ClassName
      {
        // static class variable
        public static type variableName;

        // static class method
        public static returnType methodName(parameters)
        {
              // implementation not shown
        }
      }
    </program>

    <p>
      Class (static) methods can access or change the values of class (static)
      variables and can call other class (static) methods. However, they cannot
      access or change the values of (non-static) instance variables or call
      (nont-static) instance methods without being passed an instance of the
      class via a parameter. For example, the main method which is static can
      call other static methods directly with or without the classname, but it
      cannot call instance methods without first creating an object. Try this
      below to see “non-static variable or method cannot be referenced from a
      static context” errors.
    </p>

    <activity label="staticmethods">
      <statement>
        <p>
          Note that the static method printStatic has errors in it because it
          cannot access the instance variables and methods. Fix the printStatic
          method by giving it the Person object as a parameter and using this
          object to call its instance variables and methods. Also fix the method
          call to printStatic in main to pass in the object as an argument.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private String email;

              // constructor
              public Person(String initName, String initEmail) {
                  name = initName;
                  email = initEmail;
              }

              // instance method
              public void print() {
                  System.out.println(name + ": " + email);
              }

              // static method
              public static void printStatic() {
                  System.out.println("Static methods cannot print out non-static variables.");
                  // The following lines will cause errors

                  // TODO: Fix this by giving it the Person object as a parameter
                  // Use the object to print out the name and call its instance methods.
                  System.out.println(name);
                  print();
              }

              public static void main(String[] args) {
                  Person p = new Person("Jana", "jana@gmail.com");

                  // Call p's instance method to print
                  p.print();

                  // Call printStatic with the class name
                  // Note this has errors.
                  // TODO: Fix the errors by giving it the object p as an arguments
                  Person.printStatic();
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() {
                  String target = "printStatic(p)";
                  boolean passed = checkCodeContains(target, target);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String target = "printStatic(Person";
                  boolean passed = checkCodeContains(target, target);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <p>
      This example also shows how instance methods easily share data variables
      without the need for parameters. Whereas, static methods cannot directly
      access the instance methods. They are often used for utility methods, like
      Math operations, that do not need access to the instance variables of an
      object.
    </p>
  </subsection>

  <subsection xml:id="class-variables">
    <title>Class Variables</title>

    <p>
      <term>Class variables</term> belong to the class, with all objects of a
      class sharing a single copy of the class variable. Class variables are
      designated with the <c>static</c> keyword before the variable type. Class
      variables that are designated <c>public</c> are accessed outside of the
      class by using the class name and the dot operator, since they are
      associated with a class, not objects of a class.
    </p>

    <p>
      In the following class <c>Person</c>, there is a <c>static</c> variable
      called <c>personCounter</c> that is incremented each time the
      <c>Person</c> constructor is called to initialize a new <c>Person</c>
      object. The static method <c>printCounter</c> prints out its value. You
      can also watch how it works in the <url
      href="http://www.pythontutor.com/visualize.html#code=%20public%20class%20Person%20%0A%20%20%7B%0A%20%20%20%20%20//%20instance%20variables%20%0A%20%20%20%20%20private%20String%20name%3B%0A%20%20%20%20%20private%20String%20email%3B%0A%20%20%20%20%20private%20String%20phoneNumber%3B%0A%20%20%20%20%20%0A%20%20%20%20%20//%20Static%20counter%20variable%0A%20%20%20%20%20public%20static%20int%20personCounter%20%3D%200%3B%0A%20%20%20%20%20%0A%20%20%20%20%20//%20static%20method%20to%20print%20out%20counter%0A%20%20%20%20%20public%20static%20void%20printPersonCounter%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20System.out.println%28%22Person%20counter%3A%20%22%20%2B%20personCounter%29%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20%0A%20%20%20%20%20//%20constructor%3A%20construct%20a%20Person%20copying%20in%20the%20data%20into%20the%20instance%20variables%0A%20%20%20%20%20public%20Person%28String%20initName,%20String%20initEmail,%20String%20initPhone%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20name%20%3D%20initName%3B%0A%20%20%20%20%20%20%20%20email%20%3D%20initEmail%3B%0A%20%20%20%20%20%20%20%20phoneNumber%20%3D%20initPhone%3B%0A%20%20%20%20%20%20%20%20personCounter%2B%2B%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20%0A%20%20%20%20%20//%20toString%28%29%20method%0A%20%20%20%20%20public%20String%20toString%28%29%20%0A%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20return%20%20name%20%2B%20%22%3A%20%22%20%2B%20email%20%2B%20%22%20%22%20%2B%20phoneNumber%3B%0A%20%20%20%20%20%7D%0A%20%20%20%20%20%0A%20%20%20%20%20//%20main%20method%20for%20testing%0A%20%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20//%20call%20the%20constructor%20to%20create%20a%20new%20person%0A%20%20%20%20%20%20%20%20Person%20p1%20%3D%20new%20Person%28%22Sana%22,%20%22sana%40gmail.com%22,%20%22123-456-7890%22%29%3B%0A%20%20%20%20%20%20%20%20Person%20p2%20%3D%20new%20Person%28%22Jean%22,%20%22jean%40gmail.com%22,%20%22404%20899-9955%22%29%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20Person.printPersonCounter%28%29%3B%0A%20%20%20%20%20%7D%0A%20%20%7D%0A%20%20&amp;cumulative=false&amp;curInstr=1&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">Java
      visualizer</url> by clicking the CodeLens button below.
    </p>

    <activity label="PersonClassStaticCounter">
      <statement>
        <p>
          What will the following code print out? Try adding another Person
          object and see what happens. Try the CodeLens button to run the code
          step by step.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private String email;
              private String phoneNumber;

              // Static counter variable
              public static int personCounter = 0;

              // static method to print out counter
              public static void printPersonCounter() {
                  System.out.println("Person counter: " + personCounter);
              }

              // constructor: construct a Person copying in the data into the instance
              // variables
              public Person(String initName, String initEmail, String initPhone) {
                  name = initName;
                  email = initEmail;
                  phoneNumber = initPhone;
                  personCounter++;
              }

              // toString() method
              public String toString() {
                  return name + ": " + email + " " + phoneNumber;
              }

              // main method for testing
              public static void main(String[] args) {
                  // call the constructor to create a new person
                  Person p1 = new Person("Sana", "sana@gmail.com", "123-456-7890");
                  Person p2 = new Person("Jean", "jean@gmail.com", "404 899-9955");

                  Person.printPersonCounter();
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "Person counter: 2";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <p>
      Another common use for static variables is the keep track of a minimum or
      maximum value or an average of the values in a collection of objects.
    </p>

    <activity label="staticTrace">
      <statement>
        <p>
          Consider the class Temperature below which has a static variable. What
          is the output of the main method below?
        </p>

        <program>
          <![CDATA[
          public class Temperature {
              private double temperature;
              public static double maxTemp = 0;

              public Temperature(double t) {
                  temperature = t;
                  if (t > maxTemp) {
                      maxTemp = t;
                  }
              }

              public static void main(String[] args) {
                  Temperature t1 = new Temperature(75);
                  Temperature t2 = new Temperature(100);
                  Temperature t3 = new Temperature(65);
                  System.out.println("Max Temp: " + Temperature.maxTemp);
              }
          }
          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement id="staticTrace_opt_a">
            <p>Max Temp: 0</p>
          </statement>

          <feedback id="staticTrace_opt_a">
            <p>
              maxTemp is changed in each call to the Temperature() constructor.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="staticTrace_opt_b">
            <p>
              There is a compiler error because the static variable maxTemp
              cannot be used inside a non-static constructor.
            </p>
          </statement>

          <feedback id="staticTrace_opt_b">
            <p>
              Non-static methods and constructors can use any instance or static
              variables in the class.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="staticTrace_opt_c">
            <p>Max Temp: 100</p>
          </statement>

          <feedback id="staticTrace_opt_c">
            <p>
              Yes, maxTemp is initialized to 0 and then changed to 75 and then
              100 by the constructor calls.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="staticTrace_opt_d">
            <p>Max Temp: 75</p>
          </statement>

          <feedback id="staticTrace_opt_d">
            <p>
              maxTemp will be changed to 100 by the second constructor call
              since 100 &gt; 75.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="staticTrace_opt_e">
            <p>Max Temp: 65</p>
          </statement>

          <feedback id="staticTrace_opt_e">
            <p>
              maxTemp will not be changed to 65 by the third constructor call
              because 67 is not &gt; 100.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      You can see this code in action in the <url
      href="http://www.pythontutor.com/visualize.html#code=public%20class%20Temperature%20%0A%7B%0A%20%20%20private%20double%20temperature%3B%0A%20%20%20public%20static%20double%20maxTemp%20%3D%200%3B%0A%20%20%20%0A%20%20%20public%20Temperature%28double%20t%29%0A%20%20%20%7B%0A%20%20%20%20%20%20%20temperature%20%3D%20t%3B%0A%20%20%20%20%20%20%20if%20%28t%20%3E%20maxTemp%29%0A%20%20%20%20%20%20%20%20%20%20%20maxTemp%20%3D%20t%3B%0A%20%20%20%7D%0A%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%7B%0A%20%20%20%20%20%20%20Temperature%20t1%20%3D%20new%20Temperature%2875%29%3B%0A%20%20%20%20%20%20%20Temperature%20t2%20%3D%20new%20Temperature%28100%29%3B%0A%20%20%20%20%20%20%20Temperature%20t3%20%3D%20new%20Temperature%2865%29%3B%0A%20%20%20%20%20%20%20System.out.println%28%22Max%20Temp%3A%20%22%20%2B%20Temperature.maxTemp%29%3B%0A%20%20%20%7D%0A%7D&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">Java
      visualizer</url>.
    </p>

    <activity label="TemperatureBugs">
      <statement>
        <p>
          Fix the bugs in the following code. Static methods should only access
          static variables.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          public class Temperature {
              private double temperature;
              public static double maxTemp = 0;

              public Temperature(double t) {
                  temperature = t;
                  if (t > maxTemp) {
                      maxTemp = t;
                  }
              }

              // This static method should print out the static variable
              public static printMax() {
                  System.out.println(temperature);
              }

              public static void main(String[] args) {
                  Temperature t1 = new Temperature(75);
                  Temperature t2 = new Temperature(100);
                  Temperature.printMax();
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testCodeContains1() {

                  boolean passed =
                          checkCodeContains("static printMax() header", "public static void printMax()");
                  assertTrue(passed);
              }

              @Test
              public void testCodeContains2() {
                  String code = getCode();
                  boolean passed =
                          code.contains("System.out.println(maxTemp);")
                                  || code.contains("System.out.println(Temperature.maxTemp);");
                  getResults("true", "" + passed, "printMax method returns the right value", passed);
                  assertTrue(passed);
              }

              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "100.0";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="final-keyword">
    <title>final keyword</title>

    <p>
      The keyword <term>final</term> can be used in front of a variable
      declaration to make it a constant value that cannot be modified. Constants
      are traditionally capitalized.
    </p>

    <program>
      final double PI = 3.14
    </program>

    <activity label="finalPi">
      <statement>
        <p>
          Try the following code and notice the syntax error when we try to
          change the constant PI. Put the comment symbols // in front of that
          line to remove the error and run it again.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class TestFinal {
              // A static final variable for PI
              public static final double PI = 3.14;

              public static void main(String[] args) {
                  System.out.println(PI);
                  PI = 4.2; // This will cause a syntax error
              }
          }
        </code>

        <tests>
          // should pass if/when they run code
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "3.14";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="class-method-and-block-level-scope">
    <title>Class, Method, and Block Level Scope</title>

    <p>
      Java has 3 levels of scope that correspond to different types of
      variables:
    </p>

    <p>
      <ul>
        <li>
          <p>
            <term>Class Level Scope</term> for <term>instance variables</term>
            inside a class.
          </p>
        </li>

        <li>
          <p>
            <term>Method Level Scope</term> for <term>local variables</term>
            (including <term>parameter variables</term>) inside a method.
          </p>
        </li>

        <li>
          <p>
            <term>Block Level Scope</term> for <term>loop variables</term> and
            other local variables defined inside of blocks of code with { }.
          </p>
        </li>
      </ul>
    </p>

    <p>The image below shows these 3 levels of scope.</p>

    <figure align="center">
      <caption>Class, Method, and Block Level Scope</caption>

      <image source="Unit3-Class-Creation/Figures/scopeDiagram.png" width="89%">
        <shortdescription>Scope Levels</shortdescription>
      </image>
    </figure>

    <activity label="name_class_scope">
      <statement>
        <p>
          Click on all the variable declarations that are at Class Level Scope.
        </p>
      </statement>

      <feedback>
        <p>
          Remember that the instance variables declared at the top of the class
          have Class Scope.
        </p>
      </feedback>

      <areas>
        <cline><area correct="no">public class Name</area></cline>
        <cline><area correct="no">{</area></cline>
        <cline>    <area correct="yes">private String first;</area></cline>
        <cline>    <area correct="yes">public String last;</area></cline>
        <cline />
        <cline>    <area correct="no">public Name(String theFirst, String theLast)</area></cline>
        <cline>    <area correct="no">{</area></cline>
        <cline>        <area correct="no">String firstName = theFirst;</area></cline>
        <cline>        <area correct="no">first = firstName;</area></cline>
        <cline>        <area correct="no">last = theLast;</area></cline>
        <cline>    <area correct="no">}</area></cline>
        <cline><area correct="no">}</area></cline>
      </areas>
    </activity>

    <activity label="name_method_scope">
      <statement>
        <p>
          Click on all the variable declarations that are at Method Level Scope.
        </p>
      </statement>

      <feedback>
        <p>
          Remember that the parameter variables and the local variables declared
          inside a method have Method Level Scope.
        </p>
      </feedback>

      <areas>
        <cline><area correct="no">public class Name</area></cline>
        <cline><area correct="no">{</area></cline>
        <cline>    <area correct="no">private String first;</area></cline>
        <cline>    <area correct="no">public String last;</area></cline>
        <cline />
        <cline>    public Name(<area correct="yes">String theFirst</area>, <area correct="yes">String theLast</area>)</cline>
        <cline>    <area correct="no">{</area></cline>
        <cline>        <area correct="yes">String firstName = theFirst;</area></cline>
        <cline>        <area correct="no">first = firstName;</area></cline>
        <cline>        <area correct="no">last = theLast;</area></cline>
        <cline>    <area correct="no">}</area></cline>
        <cline><area correct="no">}</area></cline>
      </areas>
    </activity>
  </subsection>

  <subsection xml:id="local-variables">
    <title>Local Variables</title>

    <p>
      <term>Local variables</term> are variables declared in the headers or
      bodies of blocks of code. Local variables can only be accessed in the
      block in which they are declared. Local variables that are declared inside
      a method are usually declared at the top of the method. These variables
      can only be used within the method and do not exist outside of the method.
    </p>

    <p>
      Parameter variables are also considered local variables that only exist
      for that method or constructor. These variables may only be used within
      the constructor or method and cannot be declared to be <c>public</c> or
      <c>private</c>.It’s good practice to declare any variables that are used
      by just one method as local variables in that method.
    </p>

    <p>
      Instance variables at class scope are shared by all the methods in the
      class and can be marked as public or private with respect to their access
      outside of the class. They have class scope regardless of whether they are
      public or private.
    </p>

    <p>
      Another way to look at scope is that a variable’s scope is where it lives
      and exists. You cannot use the variable in code outside of its scope. The
      variable does not exist outside of its scope.
    </p>

    <activity label="PersonScope">
      <statement>
        <p>
          Try the following code to see that you cannot access the variables
          outside of their scope levels in the toString() method. Explain to
          someone sitting next to you why you can’t access these. Try to fix the
          errors by either using variables that are in scope or moving the
          variable declarations so that the variables have larger scope.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          public class Person {
              private String name;
              private String email;

              public Person(String initName, String initEmail) {
                  name = initName;
                  email = initEmail;
              }

              public String toString() {
                  for (int i = 0; i < 5; i++) {
                      int id = i;
                  }
                  // Can you access the blockScope variables i or id?
                  System.out.println("i at the end of the loop is " + i);
                  System.out.println("The last id is " + id);

                  // Can toString() access parameter variables in Person()?
                  return initName + ": " + initEmail;
              }

              // main method for testing
              public static void main(String[] args) {
                  // call the constructor to create a new person
                  Person p1 = new Person("Sana", "sana@gmail.com");
                  System.out.println(p1);
              }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testCodeContains() {
                  boolean passed =
                          checkCodeContains("returning instance variables", "return  name + \": \" + email;");
                  assertTrue(passed);
              }

              @Test
              public void testCodeContains2() {
                  boolean passed =
                          checkCodeContains("declaration and initialization of id to 0", "int id = 0;");
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <p>
      If there is a local variable with the same name as an instance variable,
      the variable name will refer to the local variable instead of the instance
      variable, as seen below. We’ll see in the next lesson, that we can
      distinguish between the local variable and the instance variable using the
      keyword <c>this</c> to refer to this object’s instance variables.
    </p>

    <activity label="PersonLocalVar">
      <statement>
        <p>
          In this example, the local variable is used instead of the instance
          variable of the same name. What will the code print out? Try it with
          the CodeLens button.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              private String name;
              private String email;

              public Person(String initName, String initEmail) {
                  name = initName;
                  email = initEmail;
              }

              public String toString() {
                  String name = "unknown";
                  // The local variable name here will be used,
                  //  not the instance variable name.
                  return name + ": " + email;
              }

              // main method for testing
              public static void main(String[] args) {
                  // call the constructor to create a new person
                  Person p1 = new Person("Sana", "sana@gmail.com");
                  System.out.println(p1);
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "unknown: sana@gmail.com";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="coding-challenge-debugging">
    <title>Coding Challenge: Debugging</title>

    <project label="challenge-scope-debug">
      <statement>
        <p>
          Debug the following program that has scope violations. You may need to
          add methods or use methods that are in the class Fraction
          appropriately. Then, add comments that label the variable declarations
          as class, method, or block scope.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class TesterClass {
              public static void main(String[] args) {
                  Fraction f1 = new Fraction();
                  Fraction f2 = new Fraction(1, 2);
                  System.out.println(f1);
                  System.out.println(f2.numerator / f2.denominator);
              }
          }

          /** Class Fraction */
          class Fraction {
              //  instance variables
              private int numerator;
              private int denominator;

              // constructor: set instance variables to default values
              public Fraction() {
                  int d = 1;
                  numerator = d;
                  denominator = d;
              }

              // constructor: set instance variables to init parameters
              public Fraction(int initNumerator, int initDenominator) {
                  numerator = initNumerator;
                  denominator = initDenominator;
              }

              public String toString() {
                  // if the denominator is 1, then just return the numerator
                  if (denominator == d) {
                      int newNumerator = 1;
                  }
                  return newNumerator + "/" + denominator;
              }
          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              public RunestoneTests() {
                  super("TesterClass");
              }

              @Test
              public void test1() {
                  String orig =
                          "public class TesterClass\n"
                                  + "{\n"
                                  + "   public static void main(String[] args)\n"
                                  + "   {\n"
                                  + "      Fraction f1 = new Fraction();\n"
                                  + "      Fraction f2 = new Fraction(1,2);\n"
                                  + "      System.out.println(f1);\n"
                                  + "      System.out.println(f2.numerator / f2.denominator);\n"
                                  + "   }\n"
                                  + " }\n\n"
                                  + "/** Class Fraction */\n"
                                  + "class Fraction\n"
                                  + "{\n"
                                  + "   //  instance variables\n"
                                  + "   private int numerator;\n"
                                  + "   private int denominator;\n\n"
                                  + "   // constructor: set instance variables to default values\n"
                                  + "   public Fraction()\n"
                                  + "   {\n"
                                  + "      int d = 1;\n"
                                  + "      numerator = d;\n"
                                  + "      denominator = d;\n"
                                  + "   }\n\n"
                                  + "   // constructor: set instance variables to init parameters\n"
                                  + "   public Fraction(int initNumerator, int initDenominator)\n"
                                  + "   {\n"
                                  + "      numerator = initNumerator;\n"
                                  + "      denominator = initDenominator;\n"
                                  + "   }\n\n"
                                  + "   public String toString()\n"
                                  + "   {\n"
                                  + "     // if the denominator is 1, then just return the numerator\n"
                                  + "     if (denominator == d) {\n"
                                  + "        int newNumerator = 1;\n"
                                  + "     }\n"
                                  + "     return newNumerator + \"/\" + denominator;\n"
                                  + "   }\n"
                                  + "}\n";

                  boolean passed = codeChanged(orig);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String expect = "1\n1/2";
                  String actual = getMethodOutput("main");

                  boolean passed = getResults(expect, actual, "Testing main()");
                  assertTrue(passed);
              }

              @Test
              public void test3() {
                  String code = getCodeWithoutComments();
                  int count = countOccurences(code, "private");
                  boolean passed = (count >= 2);
                  getResults(
                          "2 private vars",
                          count + " private vars",
                          "Keep the instance variables private! Use other Fraction methods.",
                          passed);
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </project>
  </subsection>

    <subsection xml:id="coding-challenge-static-song-and-counter">
    <title>Coding Challenge: Static Song and counter</title>

    <p>
      In <xref ref="topic-1-9-method-signatures"/>, we wrote a class with
      methods to print out the song <url
      href="https://www.youtube.com/watch?v=QPwEZ8Vv2YQ">The Ants Go
      Marching</url>. Here’s the song with three verses, where the chorus is the
      last two lines of each verse:
    </p>

    <program>
      Verse 1:
      The ants go marching one by one, hurrah, hurrah
      The ants go marching one by one, hurrah, hurrah
      The ants go marching one by one
      The little one stops to suck a thumb
      And they all go marching down to the ground
      To get out of the rain, BOOM! BOOM! BOOM! BOOM!

      Verse 2:
      The ants go marching two by two, hurrah, hurrah
      The ants go marching two by two, hurrah, hurrah
      The ants go marching two by two
      The little one stops to tie a shoe
      And they all go marching down to the ground
      To get out of the rain, BOOM! BOOM! BOOM! BOOM!

      Verse 3:
      The ants go marching three by three, hurrah, hurrah
      The ants go marching three by three, hurrah, hurrah
      The ants go marching three by three
      The little one stops to climb a tree
      And they all go marching down to the ground
      To get out of the rain, BOOM! BOOM! BOOM! BOOM!
    </program>

    <p>
      Let’s create a class to print out the song with two methods
      <c>chorus()</c> and <c>verse</c>, where the verse takes two parameters for
      the numbers and the action. Notice that this is a class where there are no
      instance variables and we don’t really need to generate multiple objects.
      With students or pets, it makes sense to have multiple objects. With a
      class printing out a song, we can just make the methods static and have
      just one copy of them.
    </p>

    <p>
      <ol>
        <li>
          <p>
            Create a class called <c>Song</c> with two static methods:
            <c>chorus()</c> and <c>verse()</c>. The chorus method prints out the
            last two lines of each verse. The verse method takes two parameters,
            a number and an action, and prints out the verse with the number and
            action.
          </p>
        </li>

        <li>
          <p>
            Add a public static variable called <term>numVerses</term> to the
            class that keeps track of the number of verses. Increment this
            variable in the method verse and print it out at the beginning of
            the verse.
          </p>
        </li>
      </ol>
    </p>

    <project label="antsong-static-challenge">
      <statement>
        <p>
          This class should print out the <url
          href="https://www.youtube.com/watch?v=QPwEZ8Vv2YQ">The Ants Go
          Marching</url> Song using two static methods: <c>chorus()</c> and
          <c>verse()</c>. The chorus method should print out the last two lines
          of each verse. The verse method should take two parameters, a number
          and an action, and print out the verse with the number and action. Add
          a public static variable called <term>numVerses</term> that keeps
          track of the number of verses. Increment this variable in the method
          verse and print it out at the beginning of the verse.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Song {
              // Add a public static variable called numVerses

              // Add a static chorus method

              // Add a static verse method with two parameters

              public static void main(String args[]) {
                  // Print out the static variable numVerses
                  // and call the static methods to print out the Song for 3 verses

              }
          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @After
              public void tearDown() {
                  super.tearDown();
                  // Song.numVerses = 0;

              }

              @Test
              public void checkCodeContains1() {
                  // check verse 1
                  boolean passed =
                          checkCodeContains(
                                  "verse(...) method header with two String parameters",
                                  "public static void verse(String *, String *)");

                  assertTrue(passed);
              }

              @Test
              public void checkCodeContains2() {
                  // check static
                  String code = getCode();
                  int actual = countOccurences(code, "Song.verse(");
                  String expected = "3";

                  boolean passed = actual >= 3;
                  getResults(
                          expected,
                          "" + actual,
                          "Checking that code contains three calls to verse(...) method using"
                                  + " ClassName.staticMethod(...) syntax",
                          passed);
                  assertTrue(passed);
              }

              @Test
              public void checkCodeContains3() {
                  // check static
                  String code = getCode();
                  int actual = countOccurences(code, "public static int numVerses = 0");
                  String expected = "1";

                  boolean passed = actual >= 1;
                  getResults(
                          expected,
                          "" + actual,
                          "Checking that code declares variable numVerses according to instructions and sets"
                                  + " it to zero",
                          passed);

                  assertTrue(passed);
              }

              @Test
              public void checkCodeContains4() {
                  // check static
                  String code = getCode();
                  boolean increment = code.contains("numVerses++");
                  String expected = "increments: true\n";
                  String actual = "increments: " + increment + "\n";

                  String anytext = "[\\s\\S]*";
                  String regex = "System.out.print[ln]*\\([\"a-zA-Z0-9 +]*numVerses[\"a-zA-Z0-9 +]*\\);";
                  boolean printed = code.matches(anytext + regex + anytext);
                  expected += "prints: true";
                  actual += "prints: " + printed;

                  boolean passed = increment && printed;
                  getResults(expected, actual, "Checking that code increments and prints numVerses", passed);

                  assertTrue(passed);
              }

              @Test
              public void testVerses() throws IOException {
                  String output = getMethodOutput("main").replaceAll(" his ", " a ").replaceAll("\n\n", "\n");
                  String[] actualArray = output.split("\n");

                  boolean passed = true;
                  String error = "";
                  String expect = "No errors";
                  String actual = "No errors";

                  int j = 0;

                  for (int i = 0; i < actualArray.length; i++) {
                      while (j < expectedArray.length && expectedArray[j].length() < 2) j++;
                      while (i < expectedArray.length && actualArray[i].length() < 2) i++;

                      if (j < expectedArray.length && actualArray[i].length() > 1) {
                          /*
                           * System.out.println(expectedArray[j]);
                           * System.out.println(actualArray[i]);
                           * System.out.println();
                           */
                          if (actualArray[i].matches("[\\s\\S]*[0-9]+[\\s\\S]*")) {
                              continue;
                          }

                          String compAct = removeSpaces(actualArray[i].toLowerCase());
                          String compExp = removeSpaces(expectedArray[j].toLowerCase());

                          if (!compAct.equals(compExp)) {
                              expect = expectedArray[j].trim();
                              actual = actualArray[i].trim() + "\n(Error on line " + (i + 1) + " of output)";
                              passed = false;
                              error =
                                      "\n"
                                              + "There may be more than one error! Did you forget a line?\n"
                                              + "(check spelling, new lines, and punctuation carefully)";
                              break;
                          }
                      }

                      j++;
                  }

                  getResults(expect, actual, "Checking output from main" + error, passed);
                  assertTrue(passed);
              }

              private static String expectedOutput =
                      "The ants go marching one by one, hurrah, hurrah\n"
                              + "The ants go marching one by one, hurrah, hurrah\n"
                              + "The ants go marching one by one\n"
                              + "The little one stops to suck a thumb\n"
                              + "And they all go marching down to the ground\n"
                              + "To get out of the rain, BOOM! BOOM! BOOM! BOOM!\n"
                              + "\n"
                              + "The ants go marching two by two, hurrah, hurrah\n"
                              + "The ants go marching two by two, hurrah, hurrah\n"
                              + "The ants go marching two by two\n"
                              + "The little one stops to tie a shoe\n"
                              + "And they all go marching down to the ground\n"
                              + "To get out of the rain, BOOM! BOOM! BOOM! BOOM!\n"
                              + "\n"
                              + "The ants go marching three by three, hurrah, hurrah\n"
                              + "The ants go marching three by three, hurrah, hurrah\n"
                              + "The ants go marching three by three\n"
                              + "The little one stops to climb a tree\n"
                              + "And they all go marching down to the ground\n"
                              + "To get out of the rain, BOOM! BOOM! BOOM! BOOM!";
              private static String[] expectedArray = expectedOutput.replaceAll("\n\n", "\n").split("\n");
          }
          ]]>
        </tests>

      </program>
    </project>
  </subsection>

  <subsection xml:id="summary-34">
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 3.7.A.1) Class methods cannot access or change the values of
            instance variables or call instance methods without being passed an
            instance of the class via a parameter.
          </p>
        </li>

        <li>
          <p>
            (AP 3.7.A.2) Class methods can access or change the values of class
            variables and can call other class methods.
          </p>
        </li>

        <li>
          <p>
            (AP 3.7.B.1) Class variables belong to the class, with all objects
            of a class sharing a single copy of the class variable. Class
            variables are designated with the <term>static</term> keyword before
            the variable type.
          </p>
        </li>

        <li>
          <p>
            (AP 3.7.B.2) Class variables that are designated <c>public</c> are
            accessed outside of the class by using the class name and the dot
            operator, since they are associated with a class, not objects of a
            class.
          </p>
        </li>

        <li>
          <p>
            (AP 3.7.B.3) When a variable is declared <c>final</c>, its value
            cannot be modified.
          </p>
        </li>

        <li>
          <p>
            <term>Scope</term> is defined as where a variable is accessible or
            can be used.
          </p>
        </li>

        <li>
          <p>
            (AP 3.8.A.1) <term>Local variables</term> are variables declared in
            the headers or bodies of blocks of code. Local variables can only be
            accessed in the block in which they are declared.
          </p>
        </li>

        <li>
          <p>
            (AP 3.8.A.1) Parameters to constructors or methods are also
            considered local variables. These variables may only be used within
            the constructor or method and cannot be declared to be <c>public</c>
            or <c>private</c>.
          </p>
        </li>

        <li>
          <p>
            (AP 3.8.A.2) When there is a local variable or parameter with the
            same name as an instance variable, the variable name will refer to
            the local variable instead of the instance variable within the body
            of the constructor or method.
          </p>
        </li>
      </ul>
    </p>
  </subsection>

  <subsection xml:id="ap-practice-22">
    <title>AP Practice</title>

    <activity label="AP5-8-1">
      <statement>
        <p>
          Consider the following class definitions. Which of the following best
          explains why the class will not compile?
        </p>

        <program>
          public class Party {
              private int boxesOfFood;
              private int numOfPeople;

              public Party(int people, int foodBoxes) {
                  numOfPeople = people;
                  boxesOfFood = foodBoxes;
              }

              public void orderMoreFood(int additionalFoodBoxes) {
                  int updatedAmountOfFood = boxesOfFood + additionalFoodBoxes;
                  boxesOfFood = updatedAmountOfFood;
              }

              public void eatFoodBoxes(int eatenBoxes) {
                  boxesOfFood = updatedAmountOfFood - eatenBoxes;
              }
          }
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>The class is missing an accessor method.</p>
          </statement>

          <feedback>
            <p>There is a scope violation.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              The instance variables boxesOfFood and numOfPeople should be
              designated public instead of private.
            </p>
          </statement>

          <feedback>
            <p>
              There is a scope violation. Instance variables are usually
              private.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The return type for the Party constructor is missing.</p>
          </statement>

          <feedback>
            <p>
              There is a scope violation. Constructors do not have return types.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>
              The variable updatedAmountOfFood is not defined in eatFoodBoxes
              method.
            </p>
          </statement>

          <feedback>
            <p>
              There is a scope violation. The updatedAmountOfFood variable is a
              local variable in another method.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The Party class is missing a constructor</p>
          </statement>

          <feedback>
            <p>There is a scope violation.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="AP5-8-2">
      <statement>
        <p>Consider the following class definition.</p>

        <program>
          public class Movie {
              private int currentPrice;
              private int movieRating;

              public Movie(int p, int r) {
                  currentPrice = p;
                  movieRating = r;
              }

              public int getCurrentPrice() {
                  int currentPrice = 16;
                  return currentPrice;
              }

              public void printPrice() {
                  System.out.println(getCurrentPrice());
              }
          }
        </program>

        <p>
          Which of the following reasons explains why the printPrice method is
          “broken” and only ever prints out a value of 16?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP5-8-2_opt_a">
            <p>
              The private variables currentPrice and movieRating are not
              properly initialized.
            </p>
          </statement>

          <feedback id="AP5-8-2_opt_a">
            <p>The constructor will initialize them.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP5-8-2_opt_b">
            <p>
              The private variables currentPrice and movieRating should have
              been declared public.
            </p>
          </statement>

          <feedback id="AP5-8-2_opt_b">
            <p>Instance variables should be private.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP5-8-2_opt_c">
            <p>The printPrice method should have been declared as private.</p>
          </statement>

          <feedback id="AP5-8-2_opt_c">
            <p>Methods are usually public.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP5-8-2_opt_d">
            <p>
              currentPrice is declared as a local variable in the
              getCurrentPrice method and set to 16, and will be used instead of
              the instance variable currentPrice.
            </p>
          </statement>

          <feedback id="AP5-8-2_opt_d">
            <p>Correct!</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP5-8-2_opt_e">
            <p>The currentPrice instance variable does not have a value.</p>
          </statement>

          <feedback id="AP5-8-2_opt_e">
            <p>Accessor methods are usually public.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>
</section>
