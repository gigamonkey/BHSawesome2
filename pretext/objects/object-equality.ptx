<?xml version="1.0" encoding="utf-8"?>

<section xml:id="object-equality">
  <title>Object equality</title>

  <introduction>
    <p>
      In <xref ref="topic-1-15-strings" /> we learned that we needed to use the
      <c>equals</c> method to test whether two <c>String</c> values were the
      same if what we cared about was whether they contained the same text. Now
      that we understand object references we can dig a bit deeper into exactly
      why that is.
    </p>
  </introduction>

  <subsection>
    <title>Reference equality</title>

    <p>
      Watch the following <url
      href="https://www.youtube.com/watch?v=bO9bejT0jwE&amp;list=PLHqz-wcqDQIEP6p1_0wOb9l9aQ0qFijrP&amp;ab_channel=colleenlewis">video</url>
      which shows what happens in memory as both primitive types like <c>int</c>
      and reference types like <c>Dog</c> are compared with <c>==</c> in a
      physical model of Java memory.
    </p>

    <video youtube="bO9bejT0jwE" label="video-ref-model" />
    <p>
      As the video shows we can also use the <c>==</c> or <c>!=</c> to test if
      two reference values, refer to the same object. In the video, she used
      <c>Dog</c> objects. In the figure below, we use <c>Turtle</c> objects,
      creating two <c>Turtle</c> objects assigned to variables <c>juan</c> and
      <c>mia</c>. Because each variable is assigned to the result of calling the
      <c>Turtle</c> constructor they do not refer to same object.
    </p>

    <p>
      Then, we create a new variable called <c>friend</c>, assigning it the
      value from <c>mia</c>. The turtle object <c>mia</c> referenced is now also
      referenced by the variable <c>friend</c> because each variable holds a
      copy of the same reference. This is sometimes called an
      <term>aliases</term> because there are two names, <c>mia</c> and
      <c>friend</c> that refer to the same object in memory. If two reference
      variables refer to the same object like the turtle on the right in the
      image below, the test with <c>==</c> will return true which you can see in
      the code below.
    </p>

    <figure align="center">
      <caption>Turtle Reference Equality</caption>

      <image source="Unit2-Selection-and-Iteration/Figures/turtleEquality.png" width="89%" />
    </figure>

    <activity label="boolRef">
      <statement>
        <p>
          What will the code below print out? Try to guess before you run it!
          Then, add another Turtle friend2 and set it to juan. Does friend2 ==
          juan? Does friend2 == friend? Print out the Boolean expressions for
          these.
        </p>
      </statement>

      <program interactive="activecode" datafile="turtleClasses.jar,turtleClasses2.jar">

        <code>
          import java.awt.*;
          import java.util.*;

          public class BoolTestRef {
              public static void main(String[] args) {
                  World world = new World(300, 300);
                  Turtle juan = new Turtle(world);
                  Turtle mia = new Turtle(world);

                  // Will these print true or false?
                  System.out.println(juan == mia);
                  Turtle friend = mia; // set friend to be an alias for mia
                  System.out.println(friend == mia);
                  // Create another Turtle friend2 and set it to juan
                  // Does friend2 == juan?
                  // Does friend2 == friend?

              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "false\ntrue\ntrue\nfalse\n";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="string-equality">
    <title>String equality</title>

    <idx><h>String</h><h>equality</h></idx>
    <idx><h>String</h><h>equals</h></idx>

    <p>
      While <c>==</c> and <c>!=</c> have a clear meaning when comparing
      references, often with object types we often care about a different notion
      of equality that looks at the values stored an objects’ instance variables
      to decide if they are the same. This is particularly true of classes like
      <c>String</c> that represent immutable values that just happen to be
      stored in a more complex way than primitive types like <c>int</c>and
      <c>double</c>.
    </p>

    <p>
      The <term>equals</term> method for Strings compares two strings letter by
      letter. <c>s1.equals(s2)</c> is true if <c>s1</c> and <c>s2</c> have all
      the same characters in the same order. It is beyond the scope of the AP
      curriculum but any class can define its own <c>equals</c> method to
      compare instances of the class in some meaningful way. By default all
      classes have an <c>equals</c> method that just uses <c>==</c> but many
      classes will provide a more meaningful <c>equals</c> so in general
      whenever you are testing whether two non-primitive values are the same you
      should use <c>equals</c> unless you specifically care about whether they
      are literally the same (or different) objects in memory.
    </p>

    <p>
      The figure below shows how a set of variables can include <c>String</c>
      values that are both <c>==</c> and <c>equals</c> and not. The value of
      <c>a</c> is neither <c>==</c> nor <c>equals</c> to any of the other
      variables’ values since it is the only <c>String</c> with the contents
      <c>"hi"</c>. The other three variables’ values are all <c>equals</c> to
      each other since they all contain the text <c>"bye"</c> but only <c>c</c>
      and <c>d</c> are <c>==</c> since they reference the same actual object.
      The values of <c>b</c> and <c>c</c> are not <c>==</c> because whenever a
      <c>String</c> (or any other object) is created with <c>new</c>, it is
      always a new object that is not <c>==</c> to any other.
    </p>

    <figure align="center">
      <caption>String aliases</caption>

      <image source="Unit2-Selection-and-Iteration/Figures/stringEquality.svg" width="54%" />
    </figure>


    <p>
      The following <url
      href="https://www.youtube.com/watch?v=hhYBVgmC-vw">video</url> traces
      through the code above and shows how <c>==</c> and <c>equals</c> work with
      String objects in memory.
    </p>

    <video youtube="hhYBVgmC-vw" label="video-strings" />
    <p>
      Here’s the representation of memory where s2 and s3 refer to the same
      String object.
    </p>

    <figure align="center">
      <caption>
        s2 and s3 are aliases referring to the same String object
      </caption>

      <image source="Unit2-Selection-and-Iteration/Figures/s2ands3.jpg" width="63%" />
    </figure>

    <activity label="lcse1">
      <statement>
        <p>If you run the following, what will be printed?</p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Test1 {
              public static void main(String[] args) {
                  String s1 = new String("Hello");
                  String s2 = new String("Bye");
                  String s3 = s2; // s3 is now an alias for s2
                  System.out.println(s3);
                  System.out.println(s2 == s3);
                  System.out.println(s2.equals(s3));
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "Bye\ntrue\ntrue\n";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <activity label="strEquals">
      <statement>
        <p>
          What will the following print? Run the code to see the difference
          between == and equals with new Strings that are both “Hello”. Then,
          write the if statements described below to test the equality of s1 and
          s3 to see if capitalization matters.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Test2 {
              public static void main(String[] args) {
                  String s1 = new String("Hello");
                  String s2 = new String("Hello");
                  System.out.println(s1 == s2);
                  System.out.println(s1.equals(s2));

                  String s3 = new String("hello");
                  // Write an if statement to test if
                  //  s1 and s2 are equal with equals
                  // If they are, print "Equals"

                  // Write an if/else statement to test if
                  //   s1 and s3 are equal with equals
                  // If they are, print "Equals"
                  // else print "Not Equals".
                  // Note that case matters with equals unless you use equalsIgnoreCase

              }
          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "false\ntrue\nEquals\nNot Equals\n";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }

              @Test
              public void testCodeContains1() {
                  boolean ifStatement = checkCodeContains("if", "if");
                  assertTrue(ifStatement);
              }

              @Test
              public void testCount() {
                  String code = getCode();
                  int num = countOccurences(code, ".equals");
                  boolean passed = num >= 3;

                  getResults("3", "" + num, "Number of equals used", passed);
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </activity>

    <p>
      Watch the <url href="https://www.youtube.com/watch?v=xZroaSGhgxA">video
      below</url> to see how this code works in memory. Since we used the
      <c>new</c> keyword, two different <c>String</c> objects will be created
      that each have the characters <c>Hello</c> in them. So <c>s1 == s2</c>
      will be false since they don’t refer to the same object, but
      <c>s1.equals(s2)</c> is true since the two different objects contain the
      same characters in the same order.
    </p>

    <video youtube="xZroaSGhgxA" label="video-equals" />
    <p>Here is the representation of these String objects in memory.</p>

    <figure align="center">
      <caption>
        Two strings that are equal with <c>equals</c> but not with <c>==</c>.
      </caption>

      <image source="Unit2-Selection-and-Iteration/Figures/s1ands2.jpg" width="63%" />
    </figure>

    <note>
      <p>
        <c>Strings</c> values that come from string literals like <c>String s =
        "Hello"</c> behave a little differently because Java makes sure, as a
        way of saving memory, that each unique string literal is represented by
        the same object in memory. Thus two string literals with the same
        content would in fact be <c>==</c>. But that is pretty esoteric Java
        knowledge and nothing on the AP exam would expect you to know that and
        almost no Java code is written to take advantage of that fact.
      </p>
    </note>

    <activity label="qsbeq_1">
      <statement>
        <p>Which of the following is true after the code executes?</p>

        <program>
          String s1 = new String("hi");
          String s2 = new String("bye");
          String s3 = new String("hi");
          s2 = s1;
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>s1 == s2 &amp;&amp; s1 == s3</p>
          </statement>

          <feedback>
            <p>Do s1 and s3 refer to the same object?</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>s1 == s2 &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>
              Yes s2 was set to refer to the same object as s1 and s1 and s3
              have the same characters.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>s1 != s2 &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>
              Did you miss that s2 was set to refer to the same object as s1?
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qsbeq_2">
      <statement>
        <p>Which of the following is true after the code executes?</p>

        <program>
          String s1 = new String("hi");
          String s2 = new String("bye");
          String s3 = new String("hi");
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>s1 == s2 &amp;&amp; s1 == s3</p>
          </statement>

          <feedback>
            <p>Do s1 and s2 refer to the same object?</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>s2.equals(s3) &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>Does s2 have the same characters as s1 or s3?</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>s1 != s3 &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>
              s1 and s3 refer to different string objects but they contain the
              same characters "hi" in the same order.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qsbeq_3">
      <statement>
        <p>Which of the following is true after the code executes?</p>

        <program>
          String s1 = new String("hi");
          String s2 = new String("bye");
          String s3 = new String("hi");
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>s1 == s3 &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>
              Since s3 uses the new operator it will not refer to the same
              object as s1.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>s2.equals(s3) &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>Do s2 and s3 have the same characters in the same order?</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>!(s1 == s2) &amp;&amp; !(s1 == s3)</p>
          </statement>

          <feedback>
            <p>
              All of the variables refer to different objects. But,
              s1.equals(s3) would be true since they have the same characters in
              the same order.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="comparing-with-null">
    <title>Comparing with null</title>

    <p>
      The one time we do use <c>==</c> or <c>!=</c> with reference values is to
      compare a reference value to <term>null</term> to see if it safe to use
      since accessing an instance variable or invoking a method on <c>null</c>
      produces a <c>NullPointerException</c>. Often <term>short-circuit
      evaluation</term> is used to avoid an error if the object doesn’t exist.
      Remember that short-circuit evaluation is a feature of <c>&amp;&amp;</c>
      that means that if the first part of the if condition is <c>false</c>, it
      doesn’t even have to check the second condition and it knows the whole
      <c>&amp;&amp;</c> test is false. So we can write something like:
    </p>

    <program>
      if (s != null &amp;&amp; s.indexOf("x") != -1) { ...
    </program>

    <p>
      to safely test whether <c>s</c> contains the substring <c>"x"</c> even if
      <c>s</c> may be <c>null</c>.
    </p>

    <activity label="nullTest">
      <statement>
        <p>
          Try the following code to see a <c>NullPointerException</c> (if you
          don’t see the exception because of the autograding, you can copy it
          into the pencil icon scratch area to run it without the grader). Since
          <c>s</c> is <c>null</c>, trying to access <c>indexOf</c> on <c>s</c>
          throws an <c>NullPointerException</c>. Comment out the first <c>if</c>
          statement and run the program again. The second <c>if</c> statement
          avoids the error with shortcircuit evaluation. Because <c>s !=
          null</c> is <c>false</c>, the rest of the Boolean expression is not
          evaluated. Now, change <c>s</c> to set it to <c>"apple"</c> instead of
          <c>null</c> in the first line and run the code again to see that the
          <c>if</c> statements can print out that “apple contains an a”.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          public class NullTest {
              public static void main(String[] args) {
                  String s = null;
                  if (s.indexOf("a") >= 0) {
                      System.out.println(s + " contains an a");
                  }
                  if (s != null && s.indexOf("a") >= 0) {
                      System.out.println(s + " contains an a");
                  }
              }
          }
          ]]>
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              public RunestoneTests() {
                  super("NullTest");
              }

              @Test
              public void testMain() {
                  String output = getMethodOutput("main");
                  String expect = "apple contains an a\napple contains an a";

                  boolean passed = getResults(expect, output, "Checking main() gives correct results");
              }

              @Test
              public void testChangedCode() {
                  String origCode =
                          "public class NullTest { public static void main(String[] args) { String s = null;"
                              + " if (s.indexOf(\"a\") >= 0) {  System.out.println(s + \" contains an a\"); }"
                              + " if (s != null && s.indexOf(\"a\") >= 0) { System.out.println(s + \""
                              + " contains an a\"); } } }";

                  boolean changed = codeChanged(origCode);

                  assertTrue(changed);
              }

              @Test
              public void testCodeContains() {
                  String code = getCode();
                  String target1 = "String s = ";
                  String target2 = "System.out.println(s + \" contains an a\");";

                  boolean passed = code.contains(target1) && code.contains(target2);
                  getResults("true", "" + passed, "Checking that code has not been removed", passed);
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </activity>

    <p>
      The <url href="https://www.youtube.com/watch?v=GPdoHm1K8HA">following
      video</url> shows how the null string reference works in memory.
    </p>

    <video youtube="GPdoHm1K8HA" label="video-null-string" />
  </subsection>

</section>
