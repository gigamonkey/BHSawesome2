<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-3-6-methods-references">
  <title>Using objects</title>

  <introduction>
  </introduction>

  <subsection xml:id="objects-as-instance-variables">
    <title>Objects as Instance Variables</title>

    <p>
      Classes can have complex instance variables that use other classes. For
      example, a <c>Person</c> class could have an instance variable for the
      address which can be an object with its own instance variables of street,
      city, state, and zipcode. This is a <term>has-a</term> relationship where
      a Person <em>has</em> an Address inside it.
    </p>

    <program>
      class Address {
          // instance variables
          private String street;
          private String city;
          private String state;
          private String zipcode;
      }

      class Person {
          // instance variables
          private String name;
          private Address addr; // instance variable of type Address
      }
    </program>

    <p>
      In Java, usually each class is saved in its own file with the same name as
      the class, so the Person class would be in Person.java and the Address
      class would be in Address.java. If the files are in the same folder, they
      can be compiled together so that they can interact. In Runestone, we
      cannot have separate files, so we put them in 1 coding area. In Runestone,
      only the class that has the main method can be public; the other classes
      can leave out the public keyword.
    </p>
  </subsection>

  <subsection xml:id="objects-as-arguments">
    <title>Objects as Arguments</title>

    <p>
      Java uses <term>Call by Value</term> when it passes arguments to methods
      and constructors. This means that a copy of the value in the argument is
      saved in the parameter variable. If the parameter variable changes its
      value inside the method, the original value outside the method is not
      changed. With primitive types like int and double, the argument value is
      copied into the parameter variable as expected. However, if you pass in an
      argument that holds a reference to an object, like a String or Person or
      Address or Turtle objects, the reference is copied, not the whole object.
      Java was designed this way to avoid copying large objects from method to
      method.
    </p>

    <p>
      When a copy of a reference is passed in and saved in the parameter
      variable, the parameter and the argument are then <term>aliases</term>,
      both refering to the same object. Remember when we discussed reference
      aliases with turtle objects who are set equal to one another.
    </p>

    <figure align="center">
      <caption>Turtle Reference Equality</caption>

      <image source="Unit3-Class-Creation/Figures/turtleEquality.png" width="89%" />
    </figure>

    <p>
      There can be unexpected results if the parameter refers to a mutable
      object; the method or constructor can use this reference to alter the
      state of the original object. Some classes like <c>String</c> are
      immutable, so they cannot be changed by any method; for example, when
      <c>s.toUpperCase()</c> is called, it returns a new String object with the
      uppercase letters, but the original String object is not changed. Any new
      classes that you write that have setters or methods that change the state
      of the object will be mutable. So, if you pass in an object of a class
      that you write into a method as an argument, you need to be careful that
      the method does not change the object unless that is the intended
      behavior. It is good programming practice to not modify mutable objects
      that are passed as parameters unless required in the specification.
    </p>

    <p>
      Try the code below. Add code in the main method that changes the original
      address to your city. Does it also change in the person object? This can
      be a problem with references to mutable objects. In the next subsection,
      we’ll copy the Address object to avoid this problem.
    </p>

    <activity label="AddressPerson">
      <statement>
        <p>
          Try the following code. Scroll down to see both the Person and the
          Address class definitions. The Person class has an Address object as
          an instance variable. Add code in the main method that changes the
          original address to your city. Does it also change in the person
          object? This can be a problem with references to mutable objects.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private Address addr; // instance variable of type Address defined below

              // Constructor
              public Person(String initName, Address initAddress) {
                  name = initName;
                  // This direct assignment of references may not be the best practice!
                  addr = initAddress;
              }

              public String toString() {
                  return "Name:" + name + "\n" + "Address:" + addr;
              }

              public static void main(String[] args) {
                  Address a1 = new Address("123 Main St", "Anytown", "Anystate", "12345");
                  Person p1 = new Person("Skyler", a1);
                  System.out.println(p1);
                  // Add code to change a1 to your city with its setCity method

                  // Print out a1 and p1. Did changing a1 change p1?

              }
          }

          class Address {
              // instance variables
              private String street;
              private String city;
              private String state;
              private String zipcode;

              // constructor
              public Address(String initStreet, String initCity, String initState, String initZipcode) {
                  street = initStreet;
                  city = initCity;
                  state = initState;
                  zipcode = initZipcode;
              }

              public String toString() {
                  return street + "\n" + city + ", " + state + " " + zipcode;
              }

              public String getStreet() {
                  return street;
              }

              public String getCity() {
                  return city;
              }

              public String getState() {
                  return state;
              }

              public String getZipcode() {
                  return zipcode;
              }

              // Setters (makes the class mutable)
              public void setCity(String initCity) {
                  city = initCity;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() throws IOException {
                  String target = "a1.setCity";
                  boolean passed = checkCodeContains("call to a1.setCity", target);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="this-as-an-argument">
    <title><c>this</c> as an Argument</title>

    <p>
      The <c>this</c> variable can be used anywhere you would use an object
      variable. You can even pass it to another method as an argument. Consider
      the classes below, <c>Pay</c> and <c>Overtime</c>. The <c>Pay</c> class
      declares an <c>Overtime</c> object and passes in <c>this</c> (the current
      <c>Pay</c> object) to its constructor which computes the overtime with
      respect to that <c>Pay</c> object. Try this code in the active code
      exercise below with the Show CodeLens button to trace through it step by
      step. Here is an image that shows how <c>this</c>, <c>myPay</c> and
      <c>p</c> all refer to the same object in memory.
    </p>

    <figure align="center">
      <image source="Unit3-Class-Creation/Figures/thisTrace.png" width="71%" />
    </figure>

    <activity label="PayClassThis">
      <statement>
        <p>
          What does this code print out? Trace through the code with the Show
          CodeLens button. Notice how the this Pay object is passed to the
          Overtime constructor.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Pay {
              private double pay;

              public Pay(double p) {
                  pay = p;
              }

              public double getPay() {
                  return pay;
              }

              public void calculatePayWithOvertime() {
                  // this Pay object is passed to the Overtime constructor
                  Overtime ot = new Overtime(this);
                  pay = ot.getOvertimePay();
              }

              public static void main(String[] args) {
                  Pay myPay = new Pay(100.0);
                  myPay.calculatePayWithOvertime();
                  System.out.println(myPay.getPay());
              }
          }

          class Overtime {
              private double payWithOvertime;

              public Overtime(Pay p) {
                  payWithOvertime = p.getPay() * 1.5;
              }

              public double getOvertimePay() {
                  return payWithOvertime;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "150.0";

                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <activity label="AP-this-arg">
      <statement>
        <p>Consider the following class definitions.</p>

        <program>
          public class Pay {
              private double pay;

              public Pay(double p) {
                  pay = p;
              }

              public double getPay() {
                  return pay;
              }

              public void calculatePayWithOvertime() {
                  // this Pay object is passed to the Overtime constructor
                  Overtime ot = new Overtime(this);
                  pay = ot.getOvertimePay();
              }
          }

          public class Overtime {
              private double payWithOvertime;

              public Overtime(Pay p) {
                  payWithOvertime = p.getPay() * 1.5;
              }

              public double getOvertimePay() {
                  return payWithOvertime;
              }
          }
        </program>

        <p>
          The following code segment appears in a class other than Pay or
          Overtime.
        </p>

        <program>
          Pay one = new Pay(20.0);
          one.calculatePayWithOvertime();
          System.out.println(one.getPay());
        </program>

        <p>
          What, if anything, is printed as a result of executing the code
          segment?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP-this-arg_opt_a">
            <p>10.0</p>
          </statement>

          <feedback id="AP-this-arg_opt_a">
            <p>The pay starts at 20 and then increases with overtime.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this-arg_opt_b">
            <p>15.0</p>
          </statement>

          <feedback id="AP-this-arg_opt_b">
            <p>If the pay started at 10, this would be the result.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this-arg_opt_c">
            <p>20.0</p>
          </statement>

          <feedback id="AP-this-arg_opt_c">
            <p>The pay starts at 20 and then increases with overtime.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP-this-arg_opt_d">
            <p>30.0</p>
          </statement>

          <feedback id="AP-this-arg_opt_d">
            <p>
              Correct! The pay starts at 20 and then increases with overtime by
              multiplying by 1.5.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this-arg_opt_e">
            <p>Nothing is printed because the code will not compile.</p>
          </statement>

          <feedback id="AP-this-arg_opt_e">
            <p>Incorrect. The code will compile.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="object-variables-and-references">
    <title>Object Variables and References</title>

    <idx>reference</idx>
    <idx>null</idx>
    <p>
      New objects are saved in variables of a <term>reference type</term> which
      holds a reference to an object. A <term>reference</term> is a way to find
      the object in memory. It is like a tracking number that you can use to
      track the location of a package in the mail.
    </p>

    <p>
      A special reference value <term>null</term> (which means none) can be used
      when a variable doesn’t refer to any object. For instance, you can declare
      a variable and initialize it to <term>null</term> (<c>Turtle t1 =
      null;</c>) meaning the variable doesn’t refer to any object yet.
    </p>

    <p>
      Watch the <url
      href="https://www.youtube.com/watch?v=5fpjgXAV2BU&amp;list=PLHqz-wcqDQIEP6p1_0wOb9l9aQ0qFijrP&amp;ab_channel=colleenlewis">video</url>
      below about null.
    </p>

    <video youtube="5fpjgXAV2BU" label="video-null" />
    <p>
      The code <c>Turtle t1 = null;</c> creates a variable <c>t1</c> that refers
      to a <c>Turtle</c> object, but the <c>null</c> means that it doesn’t refer
      to an object yet. You could later create the object and set the object
      variable to refer to that new object (<c>t1 = new Turtle(world1)</c>). Or
      more commonly, you can declare an object variable and initialize it in the
      same line of code (<c>Turtle t2 = new Turtle(world1);</c>).
    </p>

    <program>
      World world1 = new World();
      Turtle t1 = null;
      t1 = new Turtle(world1);
      // declare and initialize t2
      Turtle t2 = new Turtle(world1);
    </program>
  </subsection>

  <subsection xml:id="arguments-parameters-and-call-by-value">
    <title>Arguments, Parameters, and Call by Value</title>

    <p>
      When a constructor like <c>Date(2005,9,1)</c> is called, the
      <term>parameters</term>, (<c>year</c>, <c>month</c>, and <c>day</c>), are
      set to copies of the <term>arguments</term>, (<c>2005</c>, <c>9</c>, and
      <c>1</c>). This is <term>call by value</term> which means that copies of
      the argument values are passed to the constructor. These values are used
      to initialize the object’s attributes. A constructor call interrupts the
      sequential execution of statements in that the program executes the
      statements in the constructor before continuing. Once the last statement
      in the constructor has been executed, the flow of control is returned to
      the point immediately following where the constructor was called.
    </p>

    <figure align="center">
      <caption>Parameter Mapping</caption>

      <image source="Unit1-Using-Objects-and-Methods/Figures/parameterMappingDate.png" width="80%">
        <shortdescription>Parameter Mapping</shortdescription>
      </image>
    </figure>

    <p>
      The type of the values being passed in as arguments have to match the type
      of the parameter variables. We cannot give a constructor a <c>String</c>
      object when it is expecting an <c>int</c>. The order of the arguments also
      matters. If you mix up the month and the day in the <c>Date</c>
      constructor, you will get a completely different date, for example January
      9th (1/9) instead of Sept. 1st (9/1).
    </p>

    <activity label="mcq_params">
      <statement>
        <p>
          In <c>public World(int width, int height)</c> what are <c>width</c>
          and <c>height</c>?
        </p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>objects</p>
          </statement>

          <feedback>
            <p>Objects have attributes and behavior.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>classes</p>
          </statement>

          <feedback>
            <p>
              A class defines the data and behavior for all objects of that
              type.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>parameters</p>
          </statement>

          <feedback>
            <p>The parameters are in the constructor's signature.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>arguments</p>
          </statement>

          <feedback>
            <p>An argument is the value that is passed into the constructor.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="mcq_arguments">
      <statement>
        <p>In <c>new World(150, 200)</c> what are <c>150</c> and <c>200</c>?</p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>objects</p>
          </statement>

          <feedback>
            <p>Objects have attributes and behavior.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>classes</p>
          </statement>

          <feedback>
            <p>
              A class defines the data and behavior for all objects of that
              type.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>parameters</p>
          </statement>

          <feedback>
            <p>A parameter is in the constructor's signature.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>arguments</p>
          </statement>

          <feedback>
            <p>An argument is the value that is passed into the constructor.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="TurtleConstructorDebug">
      <statement>
        <p>Debug the following code.</p>
      </statement>

      <program interactive="activecode" datafile="turtleClasses.jar,turtleClasses2.jar">

        <code>
          import java.awt.*;
          import java.util.*;

          public class TurtleConstructorDebug
          {
              public static void main(String[] args)
              {
                  World w = new World(300,0);
                  turtle t0;
                  Turtle t1 = new Turtle();
                  Turtle t2 = new Turtle(world, 100, 50)
                  t0.forward();
                  t1.turnRight();
                  t2.turnLeft();
                  world.show(true);
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              public RunestoneTests() {
                  super("TurtleConstructorDebug");
              }

              @Test
              public void test1() {
                  String orig =
                          "import java.awt.*;\n"
                                  + "import java.util.*;\n\n"
                                  + "public class TurtleConstructorDebug\n"
                                  + "{\n"
                                  + "  public static void main(String[] args)\n"
                                  + "  {\n"
                                  + "      World w = new World(300,0);\n"
                                  + "      turtle t0;\n"
                                  + "      Turtle t1 = new Turtle();\n"
                                  + "      Turtle t2 = new Turtle(world, 100, 50)\n"
                                  + "      t0.forward();\n"
                                  + "      t1.turnRight();\n"
                                  + "      t2.turnLeft();\n"
                                  + "      world.show(true);\n"
                                  + "  }\n"
                                  + "}\n";
                  boolean passed = codeChanged(orig);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <p>
      This lesson introduces a lot of vocabulary, but don’t worry if you don’t
      understand everything about classes and constructors yet. You will learn
      more about how this all works in later units when you write your own
      classes and constructors. And you will see parameters again with methods
      in the next lessons.
    </p>

    <image source="Unit1-Using-Objects-and-Methods/Figures/customTurtles.png" width="36%" />
  </subsection>

  <subsection xml:id="copying-parameter-objects">
    <title>Copying Parameter Objects</title>

    <p>
      The <c>Person</c> class above has an <c>Address</c> object as an instance
      variable. We found that changing the Address object outside the class also
      changed the address in the Person object. This is because the Address
      object is mutable, and the reference to the object is passed in as an
      argument to the constructor.
    </p>

    <p>
      When you pass object references as parameters to constructors, those
      references refer to the same objects as the references in the caller. If
      the objects are immutable, like <c>String</c> objects it doesn’t matter at
      all. On the other hand, if the objects are <term>mutable</term>, meaning
      their instance variables can change after they are constructed, then
      storing the passed-in reference in an instance variable in your object can
      lead to surprising results: if some other code changes the object it will
      change for you too. If that’s not what you want, sometimes it makes sense
      to copy the object passed to the constructor and store the copy in the
      instance variable instead. How to make the copy will depend on the class
      of the object, but often you can just construct a new object of the
      appropriate class using values from the original object as shown below.
      This way the instance variable <c>addr</c> does not hold a reference to
      the original object <c>initAddr</c>, and the methods in the <c>Person</c>
      class cannot modify the state of the original object.
    </p>

    <program>
      public class Person {
          private String name;
          private Address addr; // Assumes an Address class is already defined

          // constructor: initialize instance variable and call Address constructor to
          // make a copy
          public Person(String initName, Address initAddr) {
              name = initName;
              addr =
                      new Address(
                              initAddr.getStreet(),
                              initAddr.getCity(),
                              initAddr.getState(),
                              initAddr.getZipcode());
          }
      }
    </program>

    <p>
      Another way to handle this is to provide a copy constructor in the
      <c>Address</c> class that takes an <c>Address</c> object as a parameter
      and makes a copy of it. Then, the <c>Person</c> constructor can call the
      <c>Address</c> copy constructor.
    </p>

    <program>
      class Address {
          // instance variables
          private String street;
          private String city;
          private String state;
          private String zipcode;

          // constructor
          public Address(String initStreet, String initCity, String initState, String initZipcode) {
              street = initStreet;
              city = initCity;
              state = initState;
              zipcode = initZipcode;
          }

          // copy constructor
          public Address(Address otherAddr) {
              street = otherAddr.getStreet();
              city = otherAddr.getCity();
              state = otherAddr.getState();
              zipcode = otherAddr.getZipcode();
          }
      }

      class Person {
          // instance variables
          private String name;
          private Address addr; // instance variable of type Address defined below

          // constructor: initialize instance variable and call Address constructor to
          // make a copy
          public Person(String initName, Address initAddr) {
              name = initName;
              // call the copy constructor of Address to make a defensive copy
              addr = new Address(initAddr);
          }
      }
    </program>

    <p>
      Try the variation of the code below where the constructor copies the
      Address object so that it is separate from the original object. Add code
      in the main method that changes the original address to your city. It will
      not change the address in the Person object because it was copied.
    </p>

    <activity label="PersonAddressCopy">
      <statement>
        <p>
          In the following Person class, the constructor method copies the
          Address object so that it is separate from the original object.
          Complete the setAddress method in Person so that it also makes a copy
          of otherAddr object like the constructor. Then, add code in the main
          method that changes the original address to your city. It should not
          change the copy! Add code that uses the setAddress method. It should
          not change the original!
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private Address addr; // instance variable of type Address defined below

              // constructor: initialize instance variable and call Address constructor to
              // make a copy
              public Person(String initName, Address initAddr) {
                  name = initName;
                  // Defensive copy of the Address argument
                  addr =
                          new Address(
                                  initAddr.getStreet(),
                                  initAddr.getCity(),
                                  initAddr.getState(),
                                  initAddr.getZipcode());
              }

              public void setAddress(Address otherAddr) {
                  // TODO: Complete the setAddress method below that
                  // makes a defensive copy of newAddr using its get methods like the constructor

              }

              public String toString() {
                  return "Name:" + name + "\n" + "Address:" + addr;
              }

              public static void main(String[] args) {
                  Address a1 = new Address("123 Main St", "Anytown", "Anystate", "12345");
                  Address a2 = new Address("456 Elm St", "Othertown", "Otherstate", "67890");
                  Person p1 = new Person("Skyler", a1);
                  System.out.println(p1);
                  // TODO: Add code to change a1 to your city with its setCity method

                  // Print out a1 and p1. Did changing a1 change p1?

                  // Add code to change p1's address to a2 with its setAddress method

                  // Print out a1 and p1. Did changing p1 change a1?

              }
          }

          class Address {
              // instance variables
              private String street;
              private String city;
              private String state;
              private String zipcode;

              // constructor
              public Address(String initStreet, String initCity, String initState, String initZipcode) {
                  street = initStreet;
                  city = initCity;
                  state = initState;
                  zipcode = initZipcode;
              }

              public String toString() {
                  return street + "\n" + city + ", " + state + " " + zipcode;
              }

              public String getStreet() {
                  return street;
              }

              public String getCity() {
                  return city;
              }

              public String getState() {
                  return state;
              }

              public String getZipcode() {
                  return zipcode;
              }

              // Setters (makes the class mutable)
              public void setCity(String initCity) {
                  city = initCity;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() throws IOException {
                  String target = "a1.setCity";
                  boolean passed = checkCodeContains("call to a1.setCity", target);
                  assertTrue(passed);
              }

              @Test
              public void test2() throws IOException {
                  String target = "p1.setAddress";
                  boolean passed = checkCodeContains("call to p1.setAddress", target);
                  assertTrue(passed);
              }

              @Test
              public void test3() throws IOException {
                  String target = "otherAddr.getCity()";
                  boolean passed = checkCodeContains("call to otherAddr.getCity() in setAddress", target);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="parameter-of-the-same-class-type">
    <title>Parameter of the Same Class Type</title>

    <p>
      Methods cannot access the private data and methods of a parameter that
      holds a reference to an object unless the parameter is the same type as
      the method’s enclosing class. In the following code, the <c>Person</c>
      class can access the <c>Adress</c> instance variable of another Person
      object because they are of the same class type, but it cannot access the
      <c>city</c> instance variable of an <c>Address</c> object directly because
      it is private and not of the same class.
    </p>

    <program>
      public class Person {
          private String name;
          private Address addr; // instance variable of type Address defined below

          public void copyAddress(Person otherPerson) {
              // otherPerson.addr will work because the parameter is of the same class Person
              addr = new Address(otherPerson.addr);
          }

          public void copyCity(Address otherAddr) {
              // This will not work because the city instance variable is private
              //   and the parameter is not of the same class type
              // addr.city = otherAddr.city;
              // But you can use the get method to access the city
              addr.setCity(otherAddr.getCity());
          }
      }
    </program>

    <p>Try it in the code below.</p>

    <activity label="PersonAddressGet">
      <statement>
        <p>
          Run the code to see that the Person class can directly access the
          instance variables of objects of the same class, but cannot directly
          access the instance variable of an Address object because it is not of
          the same class. Change the code in the copyAddressFromAddress() method
          to use get/set methods instead.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private Address addr; // instance variable of type Address defined below

              // constructor: initialize instance variable and call Address constructor to
              // make a copy
              public Person(String initName, Address initAddr) {
                  name = initName;
                  // Defensive copy of the Address argument
                  addr =
                          new Address(
                                  initAddr.getStreet(),
                                  initAddr.getCity(),
                                  initAddr.getState(),
                                  initAddr.getZipcode());
              }

              public void copyAddressFromPerson(Person otherPerson) {
                  // otherPerson.addr will work because the parameter is of the same class Person
                  addr = new Address(otherPerson.addr);
              }

              // TODO: Change the code in this method
              public void copyAddressFromAddress(Address otherAddr) {
                  // This will not work because the instance variables are private
                  //   and the parameter is not of the same class type
                  // Change this code to use set/get methods!
                  addr.street = otherAddr.street;
                  addr.city = otherAddr.city;
                  addr.state = otherAddr.state;
                  addr.zipcode = otherAddr.zipcode;
              }

              public String toString() {
                  return "Name:" + name + "\n" + "Address:" + addr;
              }

              public static void main(String[] args) {
                  Address a1 = new Address("123 Main St", "Anytown", "Anystate", "12345");
                  Address a2 = new Address("456 Elm St", "Othertown", "Otherstate", "67890");
                  Person p1 = new Person("Skyler", a1);
                  Person p2 = new Person("Jordan", a2);
                  System.out.println(p1);
                  p1.copyAddressFromPerson(p2);
                  System.out.println(p1);
                  p1.copyAddressFromAddress(a1);
                  System.out.println(p1);
              }
          }

          class Address {
              // instance variables
              private String street;
              private String city;
              private String state;
              private String zipcode;

              // constructor
              public Address(String initStreet, String initCity, String initState, String initZipcode) {
                  street = initStreet;
                  city = initCity;
                  state = initState;
                  zipcode = initZipcode;
              }

              // copy constructor
              public Address(Address otherAddr) {
                  street = otherAddr.getStreet();
                  city = otherAddr.getCity();
                  zipcode = otherAddr.getZipcode();
              }

              public String toString() {
                  return street + "\n" + city + ", " + state + " " + zipcode;
              }

              public String getStreet() {
                  return street;
              }

              public String getCity() {
                  return city;
              }

              public String getState() {
                  return state;
              }

              public String getZipcode() {
                  return zipcode;
              }

              // Setters (makes the class mutable)
              public void setStreet(String initStreet) {
                  street = initStreet;
              }

              public void setCity(String initCity) {
                  city = initCity;
              }

              public void setState(String initState) {
                  state = initState;
              }

              public void setZipcode(String initZipcode) {
                  zipcode = initZipcode;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() {
                  String target = "addr.setCity";
                  boolean passed = checkCodeContains("call to addr.setCity", target);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String target = "otherAddr.getCity";
                  boolean passed = checkCodeContains("call to otherAddr.getCity", target);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="returning-objects">
    <title>Returning Objects</title>

    <p>
      Methods can also return objects. Remember that methods can only return the
      value of a variable. If the return value is of a primitive type like int
      or double, only a copy of the value is returned; the original variable
      cannot be changed. But when the return expression evaluates to an object
      reference, the reference is returned, not a reference to a new copy of the
      object. This means that there can be multiple references to the same
      object. If the object is mutable, then any changes made to the object
      through one reference will be seen through any other references to the
      object.
    </p>

    <p>
      For example, the <c>Person</c> class can have a <c>getAddress</c> method
      that returns the <c>Address</c> instance variable which is an object.
      Since <c>Address</c> has set methods which make it mutable, the caller can
      change the Address object through the reference returned by the method.
    </p>

    <program>
      public class Person {
          // instance variables
          private String name;
          private Address addr; // instance variable of type Address

          public Address getAddress() {
              return addr;
          }

          public static void main(String[] args) {
              Person p1 =
                      new Person("Skyler", new Address("123 Main St", "Anytown", "Anystate", "12345"));
              System.out.println(p1);
              Address a = p1.getAddress();
              a.setCity("Othertown");
              System.out.println(p1);
          }
      }
    </program>

    <p>
      Notice that we created the new Address object above inside the call to the
      <c>Person</c> constructor, instead of saving it into a variable first:
      <c>Person p1 = new Person("Skyler", new Address("123 Main St",
      "Anytown","Anystate","12345"))</c>. This is called an <term>anonymous
      object</term> where we create a new object without associating it with a
      variable. This is useful when you only need the object for a short time.
      This new Address object will be copied into the instance variable
      <c>addr</c> in the <c>Person</c> constructor.
    </p>

    <p>Try it in the code below.</p>

    <activity label="PersonReturnAddress">
      <statement>
        <p>
          Run the code to see that the Person class can return the Address
          object which is mutable. Add code in the main method that changes the
          zipcode of the Address object returned by the getAddress method. It
          will change the zipcode in the Person object too.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private Address addr; // instance variable of type Address defined below

              // constructor: initialize instance variable and call Address constructor to
              // make a copy
              public Person(String initName, Address initAddr) {
                  name = initName;
                  // Defensive copy of the Address argument
                  addr =
                          new Address(
                                  initAddr.getStreet(),
                                  initAddr.getCity(),
                                  initAddr.getState(),
                                  initAddr.getZipcode());
              }

              public Address getAddress() {
                  return addr;
              }

              public String toString() {
                  return "Name:" + name + "\n" + "Address:" + addr;
              }

              public static void main(String[] args) {
                  Person p1 =
                          new Person("Skyler", new Address("123 Main St", "Anytown", "Anystate", "12345"));
                  System.out.println(p1);
                  Address a = p1.getAddress();
                  // TODO: add code to change a's zipcode to "11111"
                  //    using setZipcode

                  // Does it change in p1 too?
                  System.out.println(p1);
              }
          }

          class Address {
              // instance variables
              private String street;
              private String city;
              private String state;
              private String zipcode;

              // constructor
              public Address(String initStreet, String initCity, String initState, String initZipcode) {
                  street = initStreet;
                  city = initCity;
                  state = initState;
                  zipcode = initZipcode;
              }

              public String toString() {
                  return street + "\n" + city + ", " + state + " " + zipcode;
              }

              public String getStreet() {
                  return street;
              }

              public String getCity() {
                  return city;
              }

              public String getState() {
                  return state;
              }

              public String getZipcode() {
                  return zipcode;
              }

              // Setters (makes the class mutable)
              public void setCity(String initCity) {
                  city = initCity;
              }

              public void setZipcode(String initZipcode) {
                  zipcode = initZipcode;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() {
                  String target = "a.setZipcode";
                  boolean passed = checkCodeContains("call to a.setZipcode", target);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String output = getMethodOutput("main");
                  String expect = "11111";

                  boolean passed = getResults(expect, output, "11111 in output");
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="method-chaining">
    <title>Chaining Method Calls</title>

    <p>
      Programmers will sometimes call methods in a chain, one after another on
      the same line, for example <c>p.getAddress().getCity()</c>. The method
      calls are separated by a dot and the return value of each method is used
      as the object for the next method call. It is important to know the types
      that each method returns so that you can call the methods of that object.
      For example, if the first method returns a String, the next method must be
      one that is defined for a String object. In the code below, the
      <c>getAddress</c> method returns an Address object, and then the
      <c>getCity</c> method is called on that Address object.
    </p>

    <program>
      Person p1 = new Person("Skyler",
                      new Address("123 Main St",
                      "Anytown", "Anystate","12345"));
      System.out.println( p1.getAddress().getCity() );
    </program>

    <activity label="fillAddress1">
      <statement>
        <p>What is printed out by <c>p1.getAddress().getCity()</c> above?</p>

        <p>
          <fillin answer="Anytown" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct.</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              Look at the arguments to the Address constructor in: <c>Person p1
              = new Person("Skyler", new Address("123 Main St", "Anytown",
              "Anystate","12345"));</c>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="fillAddress2">
      <statement>
        <p>
          What is the type of the object returned by the <c>getAddress</c>
          method?
        </p>

        <p>
          <fillin answer="Address" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct.</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              <p>Is it type Person, Address, or String?</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="fillAddress3">
      <statement>
        <p>
          What is the type of the object returned by the <c>getCity</c> method?
        </p>

        <p>
          <fillin answer="String" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct.</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              <p>Is it type Person, Address, or String?</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="method-chain">
      <statement>
        <p>
          Print out the first two letters of the state in the address of the
          person below by chaining together the method calls in one line.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private Address addr; // instance variable of type Address defined below

              // constructor: initialize instance variable and call Address constructor to
              // make a copy
              public Person(String initName, Address initAddr) {
                  name = initName;
                  // Defensive copy of the Address argument
                  addr =
                          new Address(
                                  initAddr.getStreet(),
                                  initAddr.getCity(),
                                  initAddr.getState(),
                                  initAddr.getZipcode());
              }

              public Address getAddress() {
                  return addr;
              }

              public String toString() {
                  return "Name:" + name + "\n" + "Address:" + addr;
              }

              public static void main(String[] args) {
                  Person kay =
                          new Person("Kay", new Address("123 Main St", "Boston", "Massachusetts", "01234"));
                  // TODO: print out the first two letters of the state
                  // in the address of kay in 1 line

              }
          }

          class Address {
              // instance variables
              private String street;
              private String city;
              private String state;
              private String zipcode;

              // constructor
              public Address(String initStreet, String initCity, String initState, String initZipcode) {
                  street = initStreet;
                  city = initCity;
                  state = initState;
                  zipcode = initZipcode;
              }

              public String toString() {
                  return street + "\n" + city + ", " + state + " " + zipcode;
              }

              public String getStreet() {
                  return street;
              }

              public String getCity() {
                  return city;
              }

              public String getState() {
                  return state;
              }

              public String getZipcode() {
                  return zipcode;
              }

              // Setters (makes the class mutable)
              public void setCity(String initCity) {
                  city = initCity;
              }

              public void setZipcode(String initZipcode) {
                  zipcode = initZipcode;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() {
                  String target = "kay.getAddress().getState().substring";
                  boolean passed =
                          checkCodeContains("kay's getAddress and then getState and then substring", target);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String output = getMethodOutput("main");
                  String expect = "Ma";

                  boolean passed = getResults(expect, output, "Ma in output");
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>


  <subsection>
    <title>Reference equality</title>

    <p>
      Watch the following <url
      href="https://www.youtube.com/watch?v=bO9bejT0jwE&amp;list=PLHqz-wcqDQIEP6p1_0wOb9l9aQ0qFijrP&amp;ab_channel=colleenlewis">video</url>
      which shows what happens in memory as primitive types like <c>int</c> and
      reference types like <c>Dog</c> are compared with <c>==</c> in a physical
      model of Java memory.
    </p>

    <video youtube="bO9bejT0jwE" label="video-ref-model" />
    <p>
      We can also use <c>==</c> or <c>!=</c> to test if two reference values,
      like <c>Turtle</c> and <c>String</c> objects, refer to the same object. In
      the figure below, we are creating two separate <c>Turtle</c> objects
      called <c>juan</c> and <c>mia</c>. They do not refer to same object or
      turtle. Then, we create a reference variable called <c>friend</c> that is
      set to <c>mia</c>. The turtle <c>mia</c> will have two ways
      (<term>references</term> or <term>aliases</term>) to name her – she’s both
      <c>mia</c> and <c>friend</c>, and these variables refer to the same object
      (same <c>Turtle</c>) in memory. If two reference variables refer to the
      same object like the turtle on the right in the image below, the test with
      <c>==</c> will return true which you can see in the code below.
    </p>

    <figure align="center">
      <caption>Turtle Reference Equality</caption>

      <image source="Unit2-Selection-and-Iteration/Figures/turtleEquality.png" width="89%" />
    </figure>

    <activity label="boolRef">
      <statement>
        <p>
          What will the code below print out? Try to guess before you run it!
          Then, add another Turtle friend2 and set it to juan. Does friend2 ==
          juan? Does friend2 == friend? Print out the Boolean expressions for
          these.
        </p>
      </statement>

      <program interactive="activecode" datafile="turtleClasses.jar,turtleClasses2.jar">

        <code>
          import java.awt.*;
          import java.util.*;

          public class BoolTestRef {
              public static void main(String[] args) {
                  World world = new World(300, 300);
                  Turtle juan = new Turtle(world);
                  Turtle mia = new Turtle(world);

                  // Will these print true or false?
                  System.out.println(juan == mia);
                  Turtle friend = mia; // set friend to be an alias for mia
                  System.out.println(friend == mia);
                  // Create another Turtle friend2 and set it to juan
                  // Does friend2 == juan?
                  // Does friend2 == friend?

              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "false\ntrue\ntrue\nfalse\n";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="comparing-objects">
    <title>Comparing Objects</title>

    <p>
      Comparing objects is a little different than comparing primitive typed
      values like numbers. Objects can be very complex and have many attribute
      values or instance variables inside them. For example, the <c>Turtle</c>
      objects have many instance variables like <c>name</c>, <c>width</c>,
      <c>height</c>, <c>xPos</c>, <c>yPos</c>, etc. When comparing two
      <c>Turtle</c> objects, we need a specially written <term>equals</term>
      method to compare all of these values. In the next sections, we will take
      a look at <c>String</c> objects and the difference between comparing them
      with <c>==</c> vs. the <c>equals</c> method.
    </p>
  </subsection>

  <subsection xml:id="string-equality">
    <title>String Equality</title>

    <idx><h>String</h><h>equality</h></idx>
    <idx><h>String</h><h>equals</h></idx>
    <p>
      The <term>equals</term> method for Strings compares two strings letter by
      letter. <c>s1.equals(s2)</c> is true if <c>s1</c> and <c>s2</c> have all
      the same characters in the same order. With <c>Strings</c> and other
      objects, you almost always use <c>equals</c> instead of <c>==</c> to check
      their equality.
    </p>

    <p>
      When the operator <c>==</c> or <c>!=</c> is used to compare object
      variables, it returns true when the two variables <em>refer to the same
      object</em>. These variables are called <term>object references</term> and
      <term>aliases</term> for the same object. With strings this happens when
      one string variable is set to another.
    </p>

    <figure align="center">
      <caption>String aliases</caption>

      <image source="Unit2-Selection-and-Iteration/Figures/stringEquality.png" width="54%" />
    </figure>

    <activity label="lcse1">
      <statement>
        <p>If you run the following, what will be printed?</p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Test1 {
              public static void main(String[] args) {
                  String s1 = new String("Hello");
                  String s2 = new String("Bye");
                  String s3 = s2; // s3 is now an alias for s2
                  System.out.println(s3);
                  System.out.println(s2 == s3);
                  System.out.println(s2.equals(s3));
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "Bye\ntrue\ntrue\n";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <p>
      The following <url
      href="https://www.youtube.com/watch?v=hhYBVgmC-vw">video</url> traces
      through the code above and shows how <c>==</c> and <c>equals</c> work with
      String objects in memory.
    </p>

    <video youtube="hhYBVgmC-vw" label="video-strings" />
    <p>
      Here’s the representation of memory where s2 and s3 refer to the same
      String object.
    </p>

    <figure align="center">
      <caption>
        s2 and s3 are aliases referring to the same String object
      </caption>

      <image source="Unit2-Selection-and-Iteration/Figures/s2ands3.jpg" width="63%" />
    </figure>
  </subsection>

  <subsection xml:id="equality-with-new-strings">
    <title>Equality with New Strings</title>

    <p>
      If you use the <c>new</c> keyword to create a string, it will always
      create a new string object. So, even if we create two string objects with
      new that contain all the same characters in the same order, they will not
      refer to the same object.
    </p>

    <activity label="strEquals">
      <statement>
        <p>
          What will the following print? Run the code to see the difference
          between == and equals with new Strings that are both “Hello”. Then,
          write the if statements described below to test the equality of s1 and
          s3 to see if capitalization matters.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Test2 {
              public static void main(String[] args) {
                  String s1 = new String("Hello");
                  String s2 = new String("Hello");
                  System.out.println(s1 == s2);
                  System.out.println(s1.equals(s2));

                  String s3 = new String("hello");
                  // Write an if statement to test if
                  //  s1 and s2 are equal with equals
                  // If they are, print "Equals"

                  // Write an if/else statement to test if
                  //   s1 and s3 are equal with equals
                  // If they are, print "Equals"
                  // else print "Not Equals".
                  // Note that case matters with equals unless you use equalsIgnoreCase

              }
          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "false\ntrue\nEquals\nNot Equals\n";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }

              @Test
              public void testCodeContains1() {
                  boolean ifStatement = checkCodeContains("if", "if");
                  assertTrue(ifStatement);
              }

              @Test
              public void testCount() {
                  String code = getCode();
                  int num = countOccurences(code, ".equals");
                  boolean passed = num >= 3;

                  getResults("3", "" + num, "Number of equals used", passed);
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </activity>

    <p>
      Watch the <url href="https://www.youtube.com/watch?v=xZroaSGhgxA">video
      below</url> to see how this code works in memory. Since we used the
      <c>new</c> keyword, two different <c>String</c> objects will be created
      that each have the characters <c>Hello</c> in them. So <c>s1 == s2</c>
      will be false since they don’t refer to the same object, but
      <c>s1.equals(s2)</c> is true since the two different objects contain the
      same characters in the same order.
    </p>

    <video youtube="xZroaSGhgxA" label="video-equals" />
    <p>Here is the representation of these String objects in memory.</p>

    <figure align="center">
      <caption>
        Two strings that are equal with <c>equals</c> but not with <c>==</c>.
      </caption>

      <image source="Unit2-Selection-and-Iteration/Figures/s1ands2.jpg" width="63%" />
    </figure>

    <p>
      Note that you can also create <c>Strings</c> using string literals instead
      of new, like <c>String s = "Hello"</c>. <c>String</c> literals behave a
      little differently because they are re-used if they already exist instead
      of creating a new object. But you should not see questions with string
      literals and <c>==</c> on the AP exam.
    </p>

    <note>
      <p>
        Only use <c>==</c> and <c>!=</c> with primitive types like <c>int</c> or
        to test if two strings (or objects) refer to the same object. Use
        <c>equals</c>, not <c>==</c> or <c>!=</c>, with strings to test if they
        are equal letter by letter, and with other objects to see if all of
        their relevant attributes are equal.
      </p>
    </note>

    <activity label="qsbeq_1">
      <statement>
        <p>Which of the following is true after the code executes?</p>

        <program>
          String s1 = new String("hi");
          String s2 = new String("bye");
          String s3 = new String("hi");
          s2 = s1;
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>s1 == s2 &amp;&amp; s1 == s3</p>
          </statement>

          <feedback>
            <p>Do s1 and s3 refer to the same object?</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>s1 == s2 &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>
              Yes s2 was set to refer to the same object as s1 and s1 and s3
              have the same characters.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>s1 != s2 &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>
              Did you miss that s2 was set to refer to the same object as s1?
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qsbeq_2">
      <statement>
        <p>Which of the following is true after the code executes?</p>

        <program>
          String s1 = new String("hi");
          String s2 = new String("bye");
          String s3 = new String("hi");
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>s1 == s2 &amp;&amp; s1 == s3</p>
          </statement>

          <feedback>
            <p>Do s1 and s2 refer to the same object?</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>s2.equals(s3) &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>Does s2 have the same characters as s1 or s3?</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>s1 != s3 &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>
              s1 and s3 refer to different string objects but they contain the
              same characters "hi" in the same order.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qsbeq_3">
      <statement>
        <p>Which of the following is true after the code executes?</p>

        <program>
          String s1 = new String("hi");
          String s2 = new String("bye");
          String s3 = new String("hi");
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>s1 == s3 &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>
              Since s3 uses the new operator it will not refer to the same
              object as s1.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>s2.equals(s3) &amp;&amp; s1.equals(s3)</p>
          </statement>

          <feedback>
            <p>Do s2 and s3 have the same characters in the same order?</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>!(s1 == s2) &amp;&amp; !(s1 == s3)</p>
          </statement>

          <feedback>
            <p>
              All of the variables refer to different objects. But,
              s1.equals(s3) would be true since they have the same characters in
              the same order.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="comparing-with-null">
    <title>Comparing with null</title>

    <p>
      One common place to use <c>==</c> or <c>!=</c> with objects is to compare
      them to <term>null</term> to see if they really exist. Sometimes
      short-circuit evaluation is used to avoid an error if the object doesn’t
      exist. Remember that <term>short-circuit evaluation</term> is used with
      <c>&amp;&amp;</c> in Java meaning that if the first part of the if
      condition is false, it doesn’t even have to check the second condition and
      it knows the whole <c>&amp;&amp;</c> test is false.
    </p>

    <activity label="nullTest">
      <statement>
        <p>
          Try the following code to see a <c>NullPointerException</c> (if you
          don’t see the exception because of the autograding, you can copy it
          into the pencil icon scratch area to run it without the grader). Since
          <c>s</c> is <c>null</c>, trying to access <c>indexOf</c> on <c>s</c>
          throws an <c>NullPointerException</c>. Comment out the first <c>if</c>
          statement and run the program again. The second <c>if</c> statement
          avoids the error with shortcircuit evaluation. Because <c>s !=
          null</c> is <c>false</c>, the rest of the Boolean expression is not
          evaluated. Now, change <c>s</c> to set it to <c>"apple"</c> instead of
          <c>null</c> in the first line and run the code again to see that the
          <c>if</c> statements can print out that “apple contains an a”.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          public class NullTest {
              public static void main(String[] args) {
                  String s = null;
                  if (s.indexOf("a") >= 0) {
                      System.out.println(s + " contains an a");
                  }
                  if (s != null && s.indexOf("a") >= 0) {
                      System.out.println(s + " contains an a");
                  }
              }
          }
          ]]>
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              public RunestoneTests() {
                  super("NullTest");
              }

              @Test
              public void testMain() {
                  String output = getMethodOutput("main");
                  String expect = "apple contains an a\napple contains an a";

                  boolean passed = getResults(expect, output, "Checking main() gives correct results");
              }

              @Test
              public void testChangedCode() {
                  String origCode =
                          "public class NullTest { public static void main(String[] args) { String s = null;"
                              + " if (s.indexOf(\"a\") >= 0) {  System.out.println(s + \" contains an a\"); }"
                              + " if (s != null && s.indexOf(\"a\") >= 0) { System.out.println(s + \""
                              + " contains an a\"); } } }";

                  boolean changed = codeChanged(origCode);

                  assertTrue(changed);
              }

              @Test
              public void testCodeContains() {
                  String code = getCode();
                  String target1 = "String s = ";
                  String target2 = "System.out.println(s + \" contains an a\");";

                  boolean passed = code.contains(target1) && code.contains(target2);
                  getResults("true", "" + passed, "Checking that code has not been removed", passed);
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </activity>

    <p>
      The <url href="https://www.youtube.com/watch?v=GPdoHm1K8HA">following
      video</url> shows how the null string reference works in memory.
    </p>

    <video youtube="GPdoHm1K8HA" label="video-null-string" />
  </subsection>

  <subsection xml:id="coding-challenge-friends-and-birthdays">
    <title>Coding Challenge: Friends and Birthdays</title>
    <sidebyside widths="15% 100%" margins="-20% 0%">
      <image source="Unit3-Class-Creation/Figures/cake.png" width="23%">
        <shortdescription>Birthday cake</shortdescription>
      </image>

      <stack>
      <p>
      In this challenge, you will create a class <c>Friend</c> which keeps track
      of your friends’ names and birthdays using another class called
      <c>Date</c>.
    </p>

    <p>
      <ol>
        <li>
          <p>
            Create a class called <c>Date</c> with the following instance
            variables as ints: month, day, and year. Add a constructor, getters,
            and setters for the instance variables.
          </p>
        </li>

        <li>
          <p>
            Create a class called <c>Friend</c> with the following instance
            variables: name and birthdate which is of type <c>Date</c>.
          </p>
        </li>

        <li>
          <p>
            Add a constructor that takes 2 parameters and initializes the
            instance variables, making sure to copy the birthdate parameter
            object.
          </p>
        </li>

        <li>
          <p>
            Add a method called <c>isBirthday</c> that returns true if the
            birthdate matches the given date parameter.
          </p>
        </li>

        <li>
          <p>
            Test your methods in the main method by creating a Friend object
            with a friend’s name and birthday. Then, create a Date object with
            today’s date and call the <c>isBirthday</c> method to see if it is
            the friend’s birthday.
          </p>
        </li>
      </ol>
    </p>
      </stack>
    </sidebyside>

    <project label="challenge-friend-birthday">
      <statement>
        <p>
          Complete the Date and Friend classes below. The Friend class should
          have a method isBirthday that returns true if the birthdate matches
          the given date parameter. Test your methods in the main method.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          class Date {
              // Add instance variables for the month, day, and year as ints

              // Add a constructor that initializes the instance variables with int parameters

              // Add getters for the instance variables

              // Add at least 1 setter to make the class mutable

          }

          public class Friend {
              // Add instance variables for the name and birthdate using the Date class

              // Add a constructor that initializes the instance variables
              //   Make sure you copy the birthdate parameter object

              // Add a toString method

              // Add a method isBirthday that returns true if the birthdate matches the given Date parameter.
              // You will need to check day, month, and year using getters.

              public static void main(String[] args) {
                  // Create a Date object with your friend's birthday date

                  // Create a Friend object with a friend's name and birthday

                  // Create a Date object with today's date

                  // Call your friend's isBirthday method with today's date object

              }
          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              public RunestoneTests() {
                  super("Friend");
              }

              @Test
              public void test1() {
                  String code = getCodeWithoutComments();
                  String search = ".get";
                  int num = countOccurences(code, search);

                  boolean passed = num >= 3;

                  getResults("3+", "" + num, "Date get methods called in isBirthday", passed);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  Friend tw = new Friend("Taylor Swift", new Date(12, 13, 1989));
                  String output = tw.isBirthday(new Date(12, 13, 1989)) + "";
                  String expect = "true";
                  boolean passed =
                          getResults(
                                  expect,
                                  output,
                                  "Checking if friend Taylor Swift's bday is Date(12,13,1989)");
                  assertTrue(passed);
              }

              @Test
              public void test3() {
                  Friend tw = new Friend("Taylor Swift", new Date(12, 13, 1989));
                  String output = tw.isBirthday(new Date(1, 1, 2025)) + "";
                  String expect = "false";
                  boolean passed =
                          getResults(
                                  expect, output, "Checking if friend Taylor Swift's bday is Date(1,1,2025)");
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </project>
  </subsection>

    <subsection xml:id="coding-challenge-bank-account">
    <title>Coding Challenge: Bank Account</title>
    <sidebyside widths="15% 100%" margins="-20% 0%">
    <figure align="left">
      <image source="Unit3-Class-Creation/Figures/dollarSign.png" width="18%" />
    </figure>

    <p>
      Many people keep their money in a bank account. The bank may keep track of
      the account holder’s name, the acount balance which is the amount of money
      in the account, and assign an account number to each account. At the bank
      or an ATM (automatic teller machine) or on a phone app, the account holder
      can deposit (add) or withdraw (subtract) an amount from their account.
      Here’s a <url
      href="https://www.youtube.com/watch?v=YpD1tJK9vIA&amp;ab_channel=Doyouknow%3F">video</url>
      that shows the steps to use an ATM to withdraw money from a bank acount.
      Phone apps like Venmo and Paypal connect to your bank account or credit
      card to send and get money from businesses or friends.
    </p>
    </sidebyside>

    <p>For this challenge, you can work in pairs to:</p>

    <p>
      <ul>
        <li>
          <p>
            Create a class called BankAccount below that keeps track of the
            account holder’s name, the account number, and the balance in the
            account. Make sure you use the appropriate data types for these.
          </p>
        </li>

        <li>
          <p>
            Write 2 constructors for the class: one that initializes all the
            instance variables and one that only has 2 parameters for the name
            and account number and initializes the balance to 0. For the
            parameters, use the same variable names as your instance variables.
            Use the <c>this</c> keyword to distinguish between the instance
            variables and the parameter variables.
          </p>
        </li>

        <li>
          <p>
            Write a <c>toString</c> method for the class. Use the <c>this</c>
            keyword to return the instance variables.
          </p>
        </li>

        <li>
          <p>
            Write <c>withdraw(amount)</c> and <c>deposit(amount)</c> methods for
            the class. The <c>withdraw</c> method should subtract the amount
            from the balance as long as there is enough money in the account
            (the balance is larger than the amount). And <c>deposit</c> should
            add the amount to the balance. Use the <c>this</c> keyword to refer
            to the balance.
          </p>
        </li>

        <li>
          <p>
            Test your class below with a <c>main</c> method that creates a
            <c>BankAccount</c> object and calls its <c>deposit</c> and
            <c>withdraw</c> methods and prints out the object to test its
            <c>toString</c> method.
          </p>
        </li>
      </ul>
    </p>


    <project label="challenge-BankAccount">
      <statement>
        <p>
          Create a class called BankAccount that keeps track of the account
          holder’s name, the account number, and the balance in the account.
          Create 2 constructors using <c>this</c> (one constructor to initialize
          all 3 instance variables and one that only has 2 parameters for the
          name and account number and initializes the balance to 0), a
          toString() method, and withdraw(amount) and deposit(amount) methods.
          Test your class in a main method.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class BankAccount {
              // 3 instance variables

              // 2 constructors using this

              // toString method
              // deposit(amount) method
              // withdraw(amount) method
              // main method for testing

          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              public RunestoneTests() {
                  super("BankAccount");
              }

              @Test
              public void test0() {
                  String output = getMethodOutput("main");
                  String expect = "Something like:\nName 101 100.0\nName 101 200.0\nName 101 100.0";

                  boolean passed = !output.contains("Method main does not exist");

                  getResults(expect, output, "Expected output from main", passed);
                  assertTrue(passed);
              }

              @Test
              public void test1() {
                  String output = checkConstructor(2);
                  String expect = "pass";

                  boolean passed = getResults(expect, output, "Checking 2-parameter constructor");
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String output = checkConstructor(3);
                  String expect = "pass";

                  boolean passed = getResults(expect, output, "Checking 3-parameter constructor");
                  assertTrue(passed);
              }

              @Test
              public void test01() {
                  String expect = "3 Private";
                  String output = testPrivateInstanceVariables();

                  boolean passed = getResults(expect, output, "Checking Private Instance Variable(s)");
                  assertTrue(passed);
              }

              @Test
              public void test3() {
                  String target = "public String toString()";

                  boolean passed = checkCodeContainsRegex("toString method", target);
                  assertTrue(passed);
              }

              @Test
              public void test41() {
                  String target = "public void withdraw(*)";

                  boolean passed = checkCodeContainsRegex("withdraw method", target);
                  assertTrue(passed);
              }

              @Test
              public void test42() {
                  String target = "public void deposit(*)";

                  boolean passed = checkCodeContainsRegex("deposit method", target);
                  assertTrue(passed);
              }

              @Test
              public void test5() {
                  String target = "this.";
                  String code = getCode();

                  int num = countOccurences(code, target);

                  boolean passed = num >= 6;

                  getResults("6+", "" + num, "use of this.*", passed);
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </project>
  </subsection>


  <subsection>
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 3.4.A.3) When a mutable object is a constructor parameter, the
            instance variable should be initialized with a copy of the
            referenced object. In this way, the instance variable does not hold
            a reference to the original object, and methods are prevented from
            modifying the state of the original object.
          </p>
        </li>

        <li>
          <p>
            (AP 3.6.A.1) When an argument is an object reference, the parameter
            is initialized with a copy of that reference; it does not create a
            new independent copy of the object. If the parameter refers to a
            mutable object, the method or constructor can use this reference to
            alter the state of the object. It is good programming practice to
            not modify mutable objects that are passed as parameters unless
            required in the specification.
          </p>
        </li>

        <li>
          <p>
            (AP 3.6.A.2) When the return expression evaluates to an object
            reference, the reference is returned, not a reference to a new copy
            of the object.
          </p>
        </li>

        <li>
          <p>
            (AP 3.6.A.3) Methods cannot access the private data and methods of a
            parameter that holds a reference to an object unless the parameter
            is the same type as the method’s enclosing class.
          </p>
        </li>

        <li>
          <p>
            (AP 3.9.A.1) Within an instance method or a constructor, the keyword
            <c>this</c> acts as a special variable that holds a reference to the
            current object—the object whose method or constructor is being
            called.
          </p>
        </li>

        <li>
          <p>
            <c>this.instanceVariable</c> can be used to distinguish between this
            object’s instance variables and local parameter variables that may
            have the same variable names.
          </p>
        </li>

        <li>
          <p>
            (AP 3.9.A.2) The keyword <c>this</c> can be used to pass the current
            object as an argument in a method call.
          </p>
        </li>

        <li>
          <p>(AP 3.9.A.3) Class methods do not have a <c>this</c> reference.</p>
        </li>
      </ul>
    </p>
  </subsection>

  <subsection>
    <title>AP Practice</title>

    <activity label="AP-string-equality">
      <statement>
        <p>Consider the following code segment.</p>

        <program>
          <![CDATA[
          String message = new String("AP Practice");
          String note = new String("AP Practice");
          String memo = new String("memo");
          int i = 5;

          if (message.equals(note) && !message.equals("memo"))
          {
              message = note;

              if (message == note && message.length() > i)
              {
                 i = 3;
                 memo = message.substring(i);
              }
          }
          ]]>
        </program>

        <p>
          Which of the following expressions evaluate to <c>true</c> after the
          code segment above executes?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP-string-equality_opt_a">
            <p>message == note &amp;&amp; message == memo</p>
          </statement>

          <feedback id="AP-string-equality_opt_a">
            <p>Message does not refer to the same object as memo.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-string-equality_opt_b">
            <p>message.equals(note) &amp;&amp; message.equals(memo)</p>
          </statement>

          <feedback id="AP-string-equality_opt_b">
            <p>Message is not the same string as in memo.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP-string-equality_opt_c">
            <p>message == note &amp;&amp; memo.equals(“Practice”)</p>
          </statement>

          <feedback id="AP-string-equality_opt_c">
            <p>
              Yes, both if statements in the code above execute changing message
              to equal note and memo to equal “Practice”.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-string-equality_opt_d">
            <p>message != note || message == memo</p>
          </statement>

          <feedback id="AP-string-equality_opt_d">
            <p>Both of these are false.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-string-equality_opt_e">
            <p>message.equals(memo) || memo.equals(note)</p>
          </statement>

          <feedback id="AP-string-equality_opt_e">
            <p>Both of these are false.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="AP-this">
      <statement>
        <p>Consider the following class definitions.</p>

        <program>
          public class Liquid {
              private int currentTemp;

              public Liquid(int ct) {
                  currentTemp = ct;
              }

              public int getCurrentTemp() {
                  return currentTemp;
              }

              public void addToJar(LiquidJar j) {
                  j.addLiquid(this);
              }
          }

          public class LiquidJar {
              private int totalTemp;

              public LiquidJar() {
                  totalTemp = 0;
              }

              public void addLiquid(Liquid l) {
                  totalTemp += l.getCurrentTemp();
              }

              public int getTotalTemp() {
                  return totalTemp;
              }
              // Constructor not shown.
          }
        </program>

        <p>
          Consider the following code segment, which appears in a class other
          than Liquid or LiquidJar.
        </p>

        <program>
          Liquid water = new Liquid(50);
          Liquid milk = new Liquid(15);

          LiquidJar j = new LiquidJar();
          water.addToJar(j);
          milk.addToJar(j);
          System.out.println(j.getTotalTemp());
        </program>

        <p>
          What, if anything, is printed out after the execution of the code
          segment?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP-this_opt_a">
            <p>50</p>
          </statement>

          <feedback id="AP-this_opt_a">
            <p>
              The liquid water has a temperature of 50 but more is added to the
              jar.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this_opt_b">
            <p>15</p>
          </statement>

          <feedback id="AP-this_opt_b">
            <p>
              The liquid milk has a temperature of 15 but more is added to the
              jar.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP-this_opt_c">
            <p>65</p>
          </statement>

          <feedback id="AP-this_opt_c">
            <p>
              Correct! The liquid water with a temperature of 50 and then the
              liquid milk with a temperature of 15 are added to the jar.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this_opt_d">
            <p>
              Nothing, the code segment attempts to access the private variable
              currentTemp outside of its scope.
            </p>
          </statement>

          <feedback id="AP-this_opt_d">
            <p>Incorrect. The currentTemp is never used outside its scope.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this_opt_e">
            <p>
              Nothing, the code segment attempts to access the private variable
              totalTemp outside of its scope.
            </p>
          </statement>

          <feedback id="AP-this_opt_e">
            <p>Incorrect. The totalTemp is never used outside its scope.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

</section>
