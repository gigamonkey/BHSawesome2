<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-3-6-methods-references">
  <title>Connecting objects</title>

  <introduction>
    <p>
      When we’re dealing with objects, the actual value that is stored in a
      variable, passed as an argumment, or returned from a method is a reference
      to the object’s data. This means it’s possible to connect objects to each
      other in all kinds of ways. We’ll look at some of the most important in
      this section.
    </p>
  </introduction>

  <subsection xml:id="objects-as-instance-variables">
    <title>Objects as instance variables</title>

    <p>
      A class can declare instance variables whose type is another class. For
      example, a <c>Person</c> class could have an instance variable of type
      <c>Address</c> which has its own instance variables that hold a street,
      city, state, and zipcode. This is sometimes called <term>has-a</term>
      relationship because a person <em>has</em> an address.
    </p>

    <p>
      The person class, with just its instance variables and a constructor might
      look like this:
    </p>

    <program>
      class Person {
          private String name;
          private Address address;

          public Person(String name, Address address) {
              this.name = name;
              this.address = address;
          }

      }
    </program>

    <p>
      And the <c>Address</c> class that it uses might look like this:
    </p>

    <program>
      class Address {
          private String street;
          private String city;
          private String state;
          private String zipcode;

          public Address(String street, String city, String state, String zipcode) {
              this.street = street;
              this.city = city;
              this.state = state;
              this.zipcode = zipcode;
          }
      }
    </program>

    <p>
      This is preferable to having the <c>Person</c> class define its own
      <c>street</c>, <c>city</c>, <c>state</c>, and <c>zipcode</c> instance
      variables for a couple reasons. The main one is it makes <c>Person</c>
      simpler—a <c>Person</c> is just made up of two things, a name and an
      address. When trying to understand the <c>Person</c> class we don’t have
      to deal with the complexity of how an address is represented. And then
      when we do look at the <c>Address</c> class, we don’t have to think about
      the <c>Person</c> class at all; we can understand the <c>Address</c> class
      entirely on its own terms.
    </p>

    <p>
      Also, people are not the only things that have addresses. If we want to
      represent other things that have addresses in our program, such as houses
      or schools, it’s better to have all of our code related to addresses live
      in one place rather than duplicating it in every class that represents
      something with an address.
    </p>

    <note>
      <p>
        In Java, the source code for each class is saved in its own file named
        after the class, so the <c>Person</c> class would be in
        <c>Person.java</c> and the <c>Address</c> class would be in
        <c>Address.java</c>. If the files are in the same folder, they can be
        compiled together so that they can interact. In Runestone, we cannot
        have separate files, so we put them in one coding area. In Runestone,
        only the class that has the main method can be public; the other classes
        can leave out the <c>public</c> keyword.
      </p>

    </note>
  </subsection>

  <subsection xml:id="objects-as-arguments">
    <title>Passing objects as arguments</title>

    <p>
      The <c>Person</c> constructor above demonstrates one of the ways that
      objects can be connected, by passing one object to the constructor of
      another. Remember that every object is made up of two parts: its object
      data that lives somewhere in memory and a reference to that data which is
      the value that can be passed around and stored. So when we write code
      like this to construct an <c>Address</c>:
    </p>

    <program>
      Address addr = new Address("345 Cave Stone Road", "Bedrock", "CA", "12345");
    </program>

    <p>
      the value stored in the variable <c>addr</c> is a reference to the the
      object data that was allocated to hold the data that makes up the
      <c>Address</c> object. And when we write a line like this to create a
      <c>Person</c>:
    </p>

    <program>
      Person fred = new Person("Fred Flintstone", addr);
    </program>

    <p>
      The value of <c>addr</c>, i.e. the reference, is what is passed to the
      <c>Person</c> contructor which then stores it in the <c>address</c>
      instance variable in the <c>Person</c> object data.
    </p>

    <p>
      This way of passing arguments is known as <term>call by value</term> and
      is used for both constructor and method calls in Java. Because the value
      of <c>addr</c> is passed to the constructor, the code in the constructor
      cannot affect the variable <c>addr</c>.
    </p>

    <p>
      However because the value of <c>addr</c> is a reference to the
      <c>Address</c> object, if the <c>Address</c> class defined methods that
      let us modify an <c>Address</c> object, then code in the constructor or
      elsewhere in <c>Person</c> could use those methods to change the
      <c>Address</c> object and those changes would be visible to any code that
      had a reference to that <c>Address</c> object.
    </p>

    <p>
      Consider, for example, if given the previous two lines of code, we added
      this line:
    </p>

    <program>
      Person wilma = new Person("Wilma Flintstone", addr);
    </program>

    <p>
      Fred and Wilma live at the same address so it makes sense that they share
      an <c>Address</c> object. Now suppose that <c>Address</c> provided a
      <c>setCity</c> method that changed the <c>city</c> instance variable in an
      <c>Address</c>. What happens to Fred and Wilma if we execute this line?
    </p>

    <program>
      addr.setCity("Orbit City");
    </program>

    <p>
      In this case, there’s just one <c>Address</c> object so the change would
      affect both <c>Person</c> objects in that if you got their address and
      then got the city from that address it would now return <c>"Orbit
      City"</c>. Sometimes that’s what we want and the whole point of passing
      around mutable objects. Other times it can be the source of subtle bugs if
      we forget or don’t realize that an object referenced by one object may be
      referenced elsewhere.
    </p>

    <p>
      This is the same thing that happens with arrays as we discussed in <xref
      ref="array-refs-as-args" />. It doesn’t happen with primitive types
      because the value of primitive types <em>is</em> the value that is copied
      and passed as an argument. And it doesn’t happen with reference types like
      <c>String</c> whose values are immutable.
    </p>

    <activity label="AddressPerson">
      <statement>
        <p>
          Try the following code. Scroll down to see both the Person and the
          Address class definitions. The Person class has an Address object as
          an instance variable. Add code in the main method that changes the
          original address to your city. Does it also change in the person
          object? This can be a problem with references to mutable objects.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {

              // Instance variables
              private String name;
              private Address address;

              // Constructor
              public Person(String name, Address address) {
                  this.name = name;
                  this.address = address;
              }

              public String toString() {
                  return "Name:" + name + "\n" + "Address:" + addr;
              }

              public static void main(String[] args) {
                  Address a1 = new Address("123 Main St", "Anytown", "Anystate", "12345");
                  Person p1 = new Person("Skyler", a1);
                  System.out.println(p1);
                  // Add code to change a1 to your city with its setCity method

                  // Print out a1 and p1. Did changing a1 change p1?

              }
          }

          class Address {
              // Instance variables
              private String street;
              private String city;
              private String state;
              private String zipcode;

              // constructor
              public Address(String street, String city, String state, String zipcode) {
                  this.street = street;
                  this.city = city;
                  this.state = state;
                  this.zipcode = zipcode;
              }

              public String toString() {
                  return street + "\n" + city + ", " + state + " " + zipcode;
              }

              public String getStreet() {
                  return street;
              }

              public String getCity() {
                  return city;
              }

              public String getState() {
                  return state;
              }

              public String getZipcode() {
                  return zipcode;
              }

              // Setters (makes the class mutable)
              public void setCity(String city) {
                  this.city = city;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() throws IOException {
                  String target = "a1.setCity";
                  boolean passed = checkCodeContains("call to a1.setCity", target);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="this-as-an-argument">
    <title><c>this</c> as an Argument</title>

    <p>
      The <c>this</c> variable can be used anywhere you need a reference to the
      current class. For instance you can pass it to a method or constructor as
      an argument. Consider the classes below, <c>Pay</c> and <c>Overtime</c>.
      The <c>calculatePayWithOvertime</c> method in the <c>Pay</c> class
      contstructs an <c>Overtime</c> object, passing in <c>this</c> (the current
      <c>Pay</c> object) to its constructor so the <c>Overtime</c> object can
      compute the overtime with respect to that particular <c>Pay</c> object.
    </p>

    <p>
      Try this code in the active code exercise below with the Show CodeLens
      button to trace through it step by step. Here is an image that shows how
      <c>this</c>, <c>myPay</c> and <c>p</c> all refer to the same object in
      memory.
    </p>

    <figure align="center">
      <image source="Unit3-Class-Creation/Figures/thisTrace.png" width="71%" />
    </figure>

    <activity label="PayClassThis">
      <statement>
        <p>
          What does this code print out? Trace through the code with the Show
          CodeLens button. Notice how the this Pay object is passed to the
          Overtime constructor.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Pay {
              private double pay;

              public Pay(double p) {
                  pay = p;
              }

              public double getPay() {
                  return pay;
              }

              public void calculatePayWithOvertime() {
                  // this Pay object is passed to the Overtime constructor
                  Overtime ot = new Overtime(this);
                  pay = ot.getOvertimePay();
              }

              public static void main(String[] args) {
                  Pay myPay = new Pay(100.0);
                  myPay.calculatePayWithOvertime();
                  System.out.println(myPay.getPay());
              }
          }

          class Overtime {
              private double payWithOvertime;

              public Overtime(Pay p) {
                  payWithOvertime = p.getPay() * 1.5;
              }

              public double getOvertimePay() {
                  return payWithOvertime;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect = "150.0";

                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <activity label="AP-this-arg">
      <statement>
        <p>Consider the following class definitions.</p>

        <program>
          public class Pay {
              private double pay;

              public Pay(double p) {
                  pay = p;
              }

              public double getPay() {
                  return pay;
              }

              public void calculatePayWithOvertime() {
                  // this Pay object is passed to the Overtime constructor
                  Overtime ot = new Overtime(this);
                  pay = ot.getOvertimePay();
              }
          }

          public class Overtime {
              private double payWithOvertime;

              public Overtime(Pay p) {
                  payWithOvertime = p.getPay() * 1.5;
              }

              public double getOvertimePay() {
                  return payWithOvertime;
              }
          }
        </program>

        <p>
          The following code segment appears in a class other than Pay or
          Overtime.
        </p>

        <program>
          Pay one = new Pay(20.0);
          one.calculatePayWithOvertime();
          System.out.println(one.getPay());
        </program>

        <p>
          What, if anything, is printed as a result of executing the code
          segment?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP-this-arg_opt_a">
            <p>10.0</p>
          </statement>

          <feedback id="AP-this-arg_opt_a">
            <p>The pay starts at 20 and then increases with overtime.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this-arg_opt_b">
            <p>15.0</p>
          </statement>

          <feedback id="AP-this-arg_opt_b">
            <p>If the pay started at 10, this would be the result.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this-arg_opt_c">
            <p>20.0</p>
          </statement>

          <feedback id="AP-this-arg_opt_c">
            <p>The pay starts at 20 and then increases with overtime.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP-this-arg_opt_d">
            <p>30.0</p>
          </statement>

          <feedback id="AP-this-arg_opt_d">
            <p>
              Correct! The pay starts at 20 and then increases with overtime by
              multiplying by 1.5.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this-arg_opt_e">
            <p>Nothing is printed because the code will not compile.</p>
          </statement>

          <feedback id="AP-this-arg_opt_e">
            <p>Incorrect. The code will compile.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>


  <subsection xml:id="copying-parameter-objects">
    <title>Copying object arguments</title>

    <p>
      The <c>Person</c> class above has an <c>Address</c> instance variable. As
      we saw with the example above of Fred and Wilma sharing an <c>Address</c>,
      if the <c>Address</c> object is mutable and we change it, it changes for
      both <c>Person</c> objects since they both reference the same
      <c>Address</c> object.
    </p>

    <p>
      Sometimes that exactly what we want. If Fred and Wilma live together it
      makes sense that changing their <c>Address</c> object changes it for both
      of them. But sometimes that can lead to surprising results where you think
      code is just changing the <c>Address</c> for one <c>Person</c> but is
      actually changing it for every <c>Person</c> that shares the same
      <c>Address</c> object.
    </p>

    <p>
      If that’s not what you want, sometimes it makes sense to copy the object
      passed in to the constructor and store the copy in the instance variable
      instead. How to make the copy will depend on the class of the object, but
      often you can just construct a new object of the appropriate class using
      values from the original object as shown below. This way the instance
      variable <c>addr</c> does not hold a reference to the original object
      <c>initAddr</c>, and the methods in the <c>Person</c> class cannot modify
      the state of the original object.
    </p>

    <program>
      public class Person {
          private String name;
          private Address addr; // Assumes an Address class is already defined

          // constructor: initialize instance variable and call Address constructor to
          // make a copy
          public Person(String initName, Address initAddr) {
              name = initName;
              addr =
                      new Address(
                              initAddr.getStreet(),
                              initAddr.getCity(),
                              initAddr.getState(),
                              initAddr.getZipcode());
          }
      }
    </program>

    <p>
      Another way to handle this is to provide a <term>copy constructor</term>
      in the <c>Address</c> class that takes an <c>Address</c> object as a
      parameter and makes a copy of it. Then, the <c>Person</c> constructor can
      call the <c>Address</c> copy constructor.
    </p>

    <program>
      class Address {
          // Instance variables
          private String street;
          private String city;
          private String state;
          private String zipcode;

          // Main constructor
          public Address(String street, String city, String state, String zipcode) {
              this.street = street;
              this.city = city;
              this.state = state;
              this.zipcode = zipcode;
          }

          // Copy constructor
          public Address(Address other) {
              this(other.street, other.city, other.state, other.zipcode);
          }
      }

      class Person {
          // Instance variables
          private String name;
          private Address addr; // instance variable of type Address defined below

          // Use Address's copy constructor to make a copy of the passed-in Address
          public Person(String name, Address addr) {
              this.name = name;
              this.addr = new Address(addr);
          }
      }
    </program>

    <p>
      Try the variation of the code below where the constructor copies the
      Address object so that it is separate from the original object. Add code
      in the main method that changes the original address to your city. It will
      not change the address in the Person object because it was copied.
    </p>

    <activity label="PersonAddressCopy">
      <statement>
        <p>
          In the following <c>Person</c> class, the constructor method copies
          the <c>Address</c> object so that it is separate from the original
          object. Complete the <c>setAddress</c> method in <c>Person</c> so that
          it also makes a copy of <c>otherAddr</c> object like the constructor.
          Then, add code in the <c>main</c> method that changes the original
          address to your city. It should not change the copy! Add code that
          uses the <c>setAddress</c> method. It should not change the original!
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private Address addr; // instance variable of type Address defined below

              // constructor: initialize instance variable and call Address constructor to
              // make a copy
              public Person(String name, Address addr) {
                  this.name = name;
                  // Defensive copy of the Address argument
                  this.addr = new Address(
                             addr.getStreet(),
                             addr.getCity(),
                             addr.getState(),
                             addr.getZipcode());
              }

              public void setAddress(Address otherAddr) {
                  // TODO: Complete the setAddress method below that
                  // makes a defensive copy of newAddr using its get methods like the constructor

              }

              public String toString() {
                  return "Name:" + name + "\n" + "Address:" + addr;
              }

              public static void main(String[] args) {
                  Address a1 = new Address("123 Main St", "Anytown", "Anystate", "12345");
                  Address a2 = new Address("456 Elm St", "Othertown", "Otherstate", "67890");
                  Person p1 = new Person("Skyler", a1);
                  System.out.println(p1);
                  // TODO: Add code to change a1 to your city with its setCity method

                  // Print out a1 and p1. Did changing a1 change p1?

                  // Add code to change p1's address to a2 with its setAddress method

                  // Print out a1 and p1. Did changing p1 change a1?

              }
          }

          class Address {
              // instance variables
              private String street;
              private String city;
              private String state;
              private String zipcode;

              // constructor
              public Address(String street, String city, String state, String zipcode) {
                  this.street = street;
                  this.city = city;
                  this.state = state;
                  this.zipcode = zipcode;
              }

              public String toString() {
                  return street + "\n" + city + ", " + state + " " + zipcode;
              }

              public String getStreet() {
                  return street;
              }

              public String getCity() {
                  return city;
              }

              public String getState() {
                  return state;
              }

              public String getZipcode() {
                  return zipcode;
              }

              // Setters (makes the class mutable)
              public void setCity(String initCity) {
                  city = initCity;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() throws IOException {
                  String target = "a1.setCity";
                  boolean passed = checkCodeContains("call to a1.setCity", target);
                  assertTrue(passed);
              }

              @Test
              public void test2() throws IOException {
                  String target = "p1.setAddress";
                  boolean passed = checkCodeContains("call to p1.setAddress", target);
                  assertTrue(passed);
              }

              @Test
              public void test3() throws IOException {
                  String target = "otherAddr.getCity()";
                  boolean passed = checkCodeContains("call to otherAddr.getCity() in setAddress", target);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="parameter-of-the-same-class-type">
    <title>Parameters of the same class</title>

    <p>
      In general code in methods and constructors cannot access the
      <c>private</c> data and methods of their parameters—that’s what it means
      for something to be <c>private</c>. However if a parameter is of the same
      type as the method or constructor’s enclosing class it can. We saw an
      example of that in the <c>Address</c> copy constructor in the code above.
      For another example, in the following code, the <c>Person</c> class
      accesses the <c>Adress</c> instance variable of another <c>Person</c>
      object because they are of the same class type, but it cannot access the
      <c>city</c> instance variable of an <c>Address</c> object directly because
      it is private and not of the same class.
    </p>

    <program>
      public class Person {
          private String name;
          private Address addr; // instance variable of type Address defined below

          public void copyAddress(Person otherPerson) {
              // This code can directly access otherPerson.addr because otherPerson
              // is an instance of Person, the class we are in.
              addr = new Address(otherPerson.addr);
          }

          public void copyCity(Address otherAddr) {
              // This code can't directly access the city instance variable
              // on either Address object because and has to use the getter
              // and setter provided by Address. (Assuming they exist.)
              addr.setCity(otherAddr.getCity());
          }
      }
    </program>

    <p>Try it in the code below.</p>

    <activity label="PersonAddressGet">
      <statement>
        <p>
          Run the code to see that the Person class can directly access the
          instance variables of objects of the same class, but cannot directly
          access the instance variable of an Address object because it is not of
          the same class. Change the code in the copyAddressFromAddress() method
          to use get/set methods instead.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private Address addr; // instance variable of type Address defined below

              // constructor: initialize instance variable and call Address constructor to
              // make a copy
              public Person(String name, Address addr) {
                  this.name = name;
                  // Defensive copy of the Address argument
                  this.addr = new Address(
                                  addr.getStreet(),
                                  addr.getCity(),
                                  addr.getState(),
                                  addr.getZipcode());
              }

              public void copyAddressFromPerson(Person otherPerson) {
                  // otherPerson.addr will work because the parameter is of the same class Person
                  addr = new Address(otherPerson.addr);
              }

              // TODO: Change the code in this method
              public void copyAddressFromAddress(Address otherAddr) {
                  // This will not work because the instance variables are private
                  //   and the parameter is not of the same class type
                  // Change this code to use set/get methods!
                  addr.street = otherAddr.street;
                  addr.city = otherAddr.city;
                  addr.state = otherAddr.state;
                  addr.zipcode = otherAddr.zipcode;
              }

              public String toString() {
                  return "Name:" + name + "\n" + "Address:" + addr;
              }

              public static void main(String[] args) {
                  Address a1 = new Address("123 Main St", "Anytown", "Anystate", "12345");
                  Address a2 = new Address("456 Elm St", "Othertown", "Otherstate", "67890");
                  Person p1 = new Person("Skyler", a1);
                  Person p2 = new Person("Jordan", a2);
                  System.out.println(p1);
                  p1.copyAddressFromPerson(p2);
                  System.out.println(p1);
                  p1.copyAddressFromAddress(a1);
                  System.out.println(p1);
              }
          }

          class Address {
              // instance variables
              private String street;
              private String city;
              private String state;
              private String zipcode;

              // Main constructor
              public Address(String street, String city, String state, String zipcode) {
                  this.street = street;
                  this.city = city;
                  this.state = state;
                  this.zipcode = zipcode;
              }

              // Copy constructor
              public Address(Address other) {
                  this(other.street, other.city, other.state, other.zipcode);
              }

              public String toString() {
                  return street + "\n" + city + ", " + state + " " + zipcode;
              }

              public String getStreet() {
                  return street;
              }

              public String getCity() {
                  return city;
              }

              public String getState() {
                  return state;
              }

              public String getZipcode() {
                  return zipcode;
              }

              // Setters (makes the class mutable)
              public void setStreet(String initStreet) {
                  street = initStreet;
              }

              public void setCity(String initCity) {
                  city = initCity;
              }

              public void setState(String initState) {
                  state = initState;
              }

              public void setZipcode(String initZipcode) {
                  zipcode = initZipcode;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() {
                  String target = "addr.setCity";
                  boolean passed = checkCodeContains("call to addr.setCity", target);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String target = "otherAddr.getCity";
                  boolean passed = checkCodeContains("call to otherAddr.getCity", target);
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="returning-objects">
    <title>Returning objects</title>

    <p>
      Methods can also return references to objects. Just like when we pass
      arguments <em>to</em> a method, when we return values <em>from</em> a
      method we return a copy of the value. For primitive types like <c>int</c>
      or <c>double</c> the value itself is copied, just like when we pass a
      primitive value as an argument. And just like when we pass an object as an
      argument to a method or constructor and a copy of the reference is passed,
      when we return an object from a method the value that is returned is also
      a copy of the reference.
    </p>

    <p>
      For example, the <c>Person</c> class’s <c>getAddress</c> getter returns
      the <c>Address</c> stored in the <c>addr</c> instance variable which means
      it returns a reference to the same object referenced by <c>addr</c>. And
      that means that if some code calls <c>getAddress</c> and then mutates the
      returned <c>Address</c>, it mutates it for the <c>Person</c> that is still
      holding a reference to that same object.
    </p>

    <p>
      This is another way that mutable objects can lead to surprising results.
      Even if <c>Person</c> made a defensive copy of the <c>Address</c> it was
      passed in its constructor, if it returns a reference to that object from
      any of its methods then code outside the <c>Person</c> class can still
      mutate it. Sometimes that’s exactly the point of having mutable objects
      but other times it can lead to subtle bugs with code in different classes
      interfering with each other.
    </p>

    <activity label="PersonReturnAddress">
      <statement>
        <p>
          Run the code to see that the <c>Person</c> class can return the
          <c>Address</c> object which is mutable. Add code in the <c>main</c>
          method that changes the zipcode of the <c>Address</c> object returned
          by the <c>getAddress</c> method. It will change the zipcode in the
          <c>Person</c> object too.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private Address addr; // instance variable of type Address defined below

              // constructor: initialize instance variable and call Address constructor to
              // make a copy
              public Person(String name, Address addr) {
                  this.name = initName;
                  // Defensive copy of the Address argument
                  this.addr = new Address(addr);
              }

              public Address getAddress() {
                  return addr;
              }

              public String toString() {
                  return "Name:" + name + "\n" + "Address:" + addr;
              }

              public static void main(String[] args) {
                  Person p1 =
                          new Person("Skyler", new Address("123 Main St", "Anytown", "Anystate", "12345"));
                  System.out.println(p1);
                  Address a = p1.getAddress();
                  // TODO: add code to change a's zipcode to "11111"
                  //    using setZipcode

                  // Does it change in p1 too?
                  System.out.println(p1);
              }
          }

          class Address {
              // instance variables
              private String street;
              private String city;
              private String state;
              private String zipcode;

              // Main constructor
              public Address(String street, String city, String state, String zipcode) {
                  this.street = street;
                  this.city = city;
                  this.state = state;
                  this.zipcode = zipcode;
              }

              // Copy constructor
              public Address(Address other) {
                  this(other.street, other.city, other.state, other.zipcode);
              }

              public String toString() {
                  return street + "\n" + city + ", " + state + " " + zipcode;
              }

              public String getStreet() {
                  return street;
              }

              public String getCity() {
                  return city;
              }

              public String getState() {
                  return state;
              }

              public String getZipcode() {
                  return zipcode;
              }

              // Setters (makes the class mutable)
              public void setCity(String city) {
                  this.city = city;
              }

              public void setZipcode(String zipcode) {
                  this.zipcode = zipcode;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() {
                  String target = "a.setZipcode";
                  boolean passed = checkCodeContains("call to a.setZipcode", target);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String output = getMethodOutput("main");
                  String expect = "11111";

                  boolean passed = getResults(expect, output, "11111 in output");
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="method-chaining">
    <title>Chaining method calls</title>

    <p>
      Programmers will sometimes call methods in a chain, one after another on
      the same line, for example <c>p.getAddress().getCity()</c>. The method
      calls are separated by a dot and the return value of each method is used
      as the object for the next method call. It is important to know the types
      that each method returns so that you can call the methods of that object.
      For example, if the first method returns a String, the next method must be
      one that is defined for a String object. In the code below, the
      <c>getAddress</c> method returns an Address object, and then the
      <c>getCity</c> method is called on that Address object.
    </p>

    <program>
      Person p1 = new Person("Skyler", new Address("123 Main St", "Anytown", "Anystate","12345"));
      System.out.println( p1.getAddress().getCity() );
    </program>

    <activity label="fillAddress1">
      <statement>
        <p>What is printed out by <c>p1.getAddress().getCity()</c> above?</p>

        <p>
          <fillin answer="Anytown" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct.</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              Look at the arguments to the Address constructor in: <c>Person p1
              = new Person("Skyler", new Address("123 Main St", "Anytown",
              "Anystate","12345"));</c>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="fillAddress2">
      <statement>
        <p>
          What is the type of the object returned by the <c>getAddress</c>
          method?
        </p>

        <p>
          <fillin answer="Address" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct.</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              <p>Is it type Person, Address, or String?</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="fillAddress3">
      <statement>
        <p>
          What is the type of the object returned by the <c>getCity</c> method?
        </p>

        <p>
          <fillin answer="String" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct.</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              <p>Is it type Person, Address, or String?</p>
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="method-chain">
      <statement>
        <p>
          Print out the first two letters of the state in the address of the
          person below by chaining together the method calls in one line.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Person {
              // instance variables
              private String name;
              private Address addr; // instance variable of type Address defined below

              // constructor: initialize instance variable and call Address constructor to
              // make a copy
              public Person(String initName, Address initAddr) {
                  name = initName;
                  // Defensive copy of the Address argument
                  addr =
                          new Address(
                                  initAddr.getStreet(),
                                  initAddr.getCity(),
                                  initAddr.getState(),
                                  initAddr.getZipcode());
              }

              public Address getAddress() {
                  return addr;
              }

              public String toString() {
                  return "Name:" + name + "\n" + "Address:" + addr;
              }

              public static void main(String[] args) {
                  Person kay =
                          new Person("Kay", new Address("123 Main St", "Boston", "Massachusetts", "01234"));
                  // TODO: print out the first two letters of the state
                  // in the address of kay in 1 line

              }
          }

          class Address {
              // instance variables
              private String street;
              private String city;
              private String state;
              private String zipcode;

              // constructor
              public Address(String initStreet, String initCity, String initState, String initZipcode) {
                  street = initStreet;
                  city = initCity;
                  state = initState;
                  zipcode = initZipcode;
              }

              public String toString() {
                  return street + "\n" + city + ", " + state + " " + zipcode;
              }

              public String getStreet() {
                  return street;
              }

              public String getCity() {
                  return city;
              }

              public String getState() {
                  return state;
              }

              public String getZipcode() {
                  return zipcode;
              }

              // Setters (makes the class mutable)
              public void setCity(String initCity) {
                  city = initCity;
              }

              public void setZipcode(String initZipcode) {
                  zipcode = initZipcode;
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() {
                  String target = "kay.getAddress().getState().substring";
                  boolean passed =
                          checkCodeContains("kay's getAddress and then getState and then substring", target);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String output = getMethodOutput("main");
                  String expect = "Ma";

                  boolean passed = getResults(expect, output, "Ma in output");
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="coding-challenge-friends-and-birthdays">
    <title>Coding Challenge: Friends and Birthdays</title>
    <sidebyside widths="15% 100%" margins="-20% 0%">
      <image source="Unit3-Class-Creation/Figures/cake.png" width="23%">
        <shortdescription>Birthday cake</shortdescription>
      </image>

      <stack>
      <p>
      In this challenge, you will create a class <c>Friend</c> which keeps track
      of your friends’ names and birthdays using another class called
      <c>Date</c>.
    </p>

    <p>
      <ol>
        <li>
          <p>
            Create a class called <c>Date</c> with the following instance
            variables as ints: month, day, and year. Add a constructor, getters,
            and setters for the instance variables.
          </p>
        </li>

        <li>
          <p>
            Create a class called <c>Friend</c> with the following instance
            variables: name and birthdate which is of type <c>Date</c>.
          </p>
        </li>

        <li>
          <p>
            Add a constructor that takes 2 parameters and initializes the
            instance variables, making sure to copy the birthdate parameter
            object.
          </p>
        </li>

        <li>
          <p>
            Add a method called <c>isBirthday</c> that returns true if the
            birthdate matches the given date parameter.
          </p>
        </li>

        <li>
          <p>
            Test your methods in the main method by creating a Friend object
            with a friend’s name and birthday. Then, create a Date object with
            today’s date and call the <c>isBirthday</c> method to see if it is
            the friend’s birthday.
          </p>
        </li>
      </ol>
    </p>
      </stack>
    </sidebyside>

    <project label="challenge-friend-birthday">
      <statement>
        <p>
          Complete the Date and Friend classes below. The Friend class should
          have a method isBirthday that returns true if the birthdate matches
          the given date parameter. Test your methods in the main method.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          class Date {
              // Add instance variables for the month, day, and year as ints

              // Add a constructor that initializes the instance variables with int parameters

              // Add getters for the instance variables

              // Add at least 1 setter to make the class mutable

          }

          public class Friend {
              // Add instance variables for the name and birthdate using the Date class

              // Add a constructor that initializes the instance variables
              //   Make sure you copy the birthdate parameter object

              // Add a toString method

              // Add a method isBirthday that returns true if the birthdate matches the given Date parameter.
              // You will need to check day, month, and year using getters.

              public static void main(String[] args) {
                  // Create a Date object with your friend's birthday date

                  // Create a Friend object with a friend's name and birthday

                  // Create a Date object with today's date

                  // Call your friend's isBirthday method with today's date object

              }
          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              public RunestoneTests() {
                  super("Friend");
              }

              @Test
              public void test1() {
                  String code = getCodeWithoutComments();
                  String search = ".get";
                  int num = countOccurences(code, search);

                  boolean passed = num >= 3;

                  getResults("3+", "" + num, "Date get methods called in isBirthday", passed);
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  Friend tw = new Friend("Taylor Swift", new Date(12, 13, 1989));
                  String output = tw.isBirthday(new Date(12, 13, 1989)) + "";
                  String expect = "true";
                  boolean passed =
                          getResults(
                                  expect,
                                  output,
                                  "Checking if friend Taylor Swift's bday is Date(12,13,1989)");
                  assertTrue(passed);
              }

              @Test
              public void test3() {
                  Friend tw = new Friend("Taylor Swift", new Date(12, 13, 1989));
                  String output = tw.isBirthday(new Date(1, 1, 2025)) + "";
                  String expect = "false";
                  boolean passed =
                          getResults(
                                  expect, output, "Checking if friend Taylor Swift's bday is Date(1,1,2025)");
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </project>
  </subsection>

    <subsection xml:id="coding-challenge-bank-account">
    <title>Coding Challenge: Bank Account</title>
    <sidebyside widths="15% 100%" margins="-20% 0%">
    <figure align="left">
      <image source="Unit3-Class-Creation/Figures/dollarSign.png" width="18%" />
    </figure>

    <p>
      Many people keep their money in a bank account. The bank may keep track of
      the account holder’s name, the acount balance which is the amount of money
      in the account, and assign an account number to each account. At the bank
      or an ATM (automatic teller machine) or on a phone app, the account holder
      can deposit (add) or withdraw (subtract) an amount from their account.
      Here’s a <url
      href="https://www.youtube.com/watch?v=YpD1tJK9vIA&amp;ab_channel=Doyouknow%3F">video</url>
      that shows the steps to use an ATM to withdraw money from a bank acount.
      Phone apps like Venmo and Paypal connect to your bank account or credit
      card to send and get money from businesses or friends.
    </p>
    </sidebyside>

    <p>For this challenge, you can work in pairs to:</p>

    <p>
      <ul>
        <li>
          <p>
            Create a class called BankAccount below that keeps track of the
            account holder’s name, the account number, and the balance in the
            account. Make sure you use the appropriate data types for these.
          </p>
        </li>

        <li>
          <p>
            Write 2 constructors for the class: one that initializes all the
            instance variables and one that only has 2 parameters for the name
            and account number and initializes the balance to 0. For the
            parameters, use the same variable names as your instance variables.
            Use the <c>this</c> keyword to distinguish between the instance
            variables and the parameter variables.
          </p>
        </li>

        <li>
          <p>
            Write a <c>toString</c> method for the class. Use the <c>this</c>
            keyword to return the instance variables.
          </p>
        </li>

        <li>
          <p>
            Write <c>withdraw(amount)</c> and <c>deposit(amount)</c> methods for
            the class. The <c>withdraw</c> method should subtract the amount
            from the balance as long as there is enough money in the account
            (the balance is larger than the amount). And <c>deposit</c> should
            add the amount to the balance. Use the <c>this</c> keyword to refer
            to the balance.
          </p>
        </li>

        <li>
          <p>
            Test your class below with a <c>main</c> method that creates a
            <c>BankAccount</c> object and calls its <c>deposit</c> and
            <c>withdraw</c> methods and prints out the object to test its
            <c>toString</c> method.
          </p>
        </li>
      </ul>
    </p>


    <project label="challenge-BankAccount">
      <statement>
        <p>
          Create a class called BankAccount that keeps track of the account
          holder’s name, the account number, and the balance in the account.
          Create 2 constructors using <c>this</c> (one constructor to initialize
          all 3 instance variables and one that only has 2 parameters for the
          name and account number and initializes the balance to 0), a
          toString() method, and withdraw(amount) and deposit(amount) methods.
          Test your class in a main method.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class BankAccount {
              // 3 instance variables

              // 2 constructors using this

              // toString method
              // deposit(amount) method
              // withdraw(amount) method
              // main method for testing

          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              public RunestoneTests() {
                  super("BankAccount");
              }

              @Test
              public void test0() {
                  String output = getMethodOutput("main");
                  String expect = "Something like:\nName 101 100.0\nName 101 200.0\nName 101 100.0";

                  boolean passed = !output.contains("Method main does not exist");

                  getResults(expect, output, "Expected output from main", passed);
                  assertTrue(passed);
              }

              @Test
              public void test1() {
                  String output = checkConstructor(2);
                  String expect = "pass";

                  boolean passed = getResults(expect, output, "Checking 2-parameter constructor");
                  assertTrue(passed);
              }

              @Test
              public void test2() {
                  String output = checkConstructor(3);
                  String expect = "pass";

                  boolean passed = getResults(expect, output, "Checking 3-parameter constructor");
                  assertTrue(passed);
              }

              @Test
              public void test01() {
                  String expect = "3 Private";
                  String output = testPrivateInstanceVariables();

                  boolean passed = getResults(expect, output, "Checking Private Instance Variable(s)");
                  assertTrue(passed);
              }

              @Test
              public void test3() {
                  String target = "public String toString()";

                  boolean passed = checkCodeContainsRegex("toString method", target);
                  assertTrue(passed);
              }

              @Test
              public void test41() {
                  String target = "public void withdraw(*)";

                  boolean passed = checkCodeContainsRegex("withdraw method", target);
                  assertTrue(passed);
              }

              @Test
              public void test42() {
                  String target = "public void deposit(*)";

                  boolean passed = checkCodeContainsRegex("deposit method", target);
                  assertTrue(passed);
              }

              @Test
              public void test5() {
                  String target = "this.";
                  String code = getCode();

                  int num = countOccurences(code, target);

                  boolean passed = num >= 6;

                  getResults("6+", "" + num, "use of this.*", passed);
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </project>
  </subsection>


  <subsection>
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 3.4.A.3) When a mutable object is a constructor parameter, the
            instance variable should be initialized with a copy of the
            referenced object. In this way, the instance variable does not hold
            a reference to the original object, and methods are prevented from
            modifying the state of the original object.
          </p>
        </li>

        <li>
          <p>
            (AP 3.6.A.1) When an argument is an object reference, the parameter
            is initialized with a copy of that reference; it does not create a
            new independent copy of the object. If the parameter refers to a
            mutable object, the method or constructor can use this reference to
            alter the state of the object. It is good programming practice to
            not modify mutable objects that are passed as parameters unless
            required in the specification.
          </p>
        </li>

        <li>
          <p>
            (AP 3.6.A.2) When the return expression evaluates to an object
            reference, the reference is returned, not a reference to a new copy
            of the object.
          </p>
        </li>

        <li>
          <p>
            (AP 3.6.A.3) Methods cannot access the private data and methods of a
            parameter that holds a reference to an object unless the parameter
            is the same type as the method’s enclosing class.
          </p>
        </li>

        <li>
          <p>
            (AP 3.9.A.1) Within an instance method or a constructor, the keyword
            <c>this</c> acts as a special variable that holds a reference to the
            current object—the object whose method or constructor is being
            called.
          </p>
        </li>

        <li>
          <p>
            <c>this.instanceVariable</c> can be used to distinguish between this
            object’s instance variables and local parameter variables that may
            have the same variable names.
          </p>
        </li>

        <li>
          <p>
            (AP 3.9.A.2) The keyword <c>this</c> can be used to pass the current
            object as an argument in a method call.
          </p>
        </li>

        <li>
          <p>(AP 3.9.A.3) Class methods do not have a <c>this</c> reference.</p>
        </li>
      </ul>
    </p>
  </subsection>

  <subsection>
    <title>AP Practice</title>

    <activity label="AP-string-equality">
      <statement>
        <p>Consider the following code segment.</p>

        <program>
          <![CDATA[
          String message = new String("AP Practice");
          String note = new String("AP Practice");
          String memo = new String("memo");
          int i = 5;

          if (message.equals(note) && !message.equals("memo"))
          {
              message = note;

              if (message == note && message.length() > i)
              {
                 i = 3;
                 memo = message.substring(i);
              }
          }
          ]]>
        </program>

        <p>
          Which of the following expressions evaluate to <c>true</c> after the
          code segment above executes?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP-string-equality_opt_a">
            <p>message == note &amp;&amp; message == memo</p>
          </statement>

          <feedback id="AP-string-equality_opt_a">
            <p>Message does not refer to the same object as memo.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-string-equality_opt_b">
            <p>message.equals(note) &amp;&amp; message.equals(memo)</p>
          </statement>

          <feedback id="AP-string-equality_opt_b">
            <p>Message is not the same string as in memo.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP-string-equality_opt_c">
            <p>message == note &amp;&amp; memo.equals(“Practice”)</p>
          </statement>

          <feedback id="AP-string-equality_opt_c">
            <p>
              Yes, both if statements in the code above execute changing message
              to equal note and memo to equal “Practice”.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-string-equality_opt_d">
            <p>message != note || message == memo</p>
          </statement>

          <feedback id="AP-string-equality_opt_d">
            <p>Both of these are false.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-string-equality_opt_e">
            <p>message.equals(memo) || memo.equals(note)</p>
          </statement>

          <feedback id="AP-string-equality_opt_e">
            <p>Both of these are false.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="AP-this">
      <statement>
        <p>Consider the following class definitions.</p>

        <program>
          public class Liquid {
              private int currentTemp;

              public Liquid(int ct) {
                  currentTemp = ct;
              }

              public int getCurrentTemp() {
                  return currentTemp;
              }

              public void addToJar(LiquidJar j) {
                  j.addLiquid(this);
              }
          }

          public class LiquidJar {
              private int totalTemp;

              public LiquidJar() {
                  totalTemp = 0;
              }

              public void addLiquid(Liquid l) {
                  totalTemp += l.getCurrentTemp();
              }

              public int getTotalTemp() {
                  return totalTemp;
              }
              // Constructor not shown.
          }
        </program>

        <p>
          Consider the following code segment, which appears in a class other
          than Liquid or LiquidJar.
        </p>

        <program>
          Liquid water = new Liquid(50);
          Liquid milk = new Liquid(15);

          LiquidJar j = new LiquidJar();
          water.addToJar(j);
          milk.addToJar(j);
          System.out.println(j.getTotalTemp());
        </program>

        <p>
          What, if anything, is printed out after the execution of the code
          segment?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP-this_opt_a">
            <p>50</p>
          </statement>

          <feedback id="AP-this_opt_a">
            <p>
              The liquid water has a temperature of 50 but more is added to the
              jar.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this_opt_b">
            <p>15</p>
          </statement>

          <feedback id="AP-this_opt_b">
            <p>
              The liquid milk has a temperature of 15 but more is added to the
              jar.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP-this_opt_c">
            <p>65</p>
          </statement>

          <feedback id="AP-this_opt_c">
            <p>
              Correct! The liquid water with a temperature of 50 and then the
              liquid milk with a temperature of 15 are added to the jar.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this_opt_d">
            <p>
              Nothing, the code segment attempts to access the private variable
              currentTemp outside of its scope.
            </p>
          </statement>

          <feedback id="AP-this_opt_d">
            <p>Incorrect. The currentTemp is never used outside its scope.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-this_opt_e">
            <p>
              Nothing, the code segment attempts to access the private variable
              totalTemp outside of its scope.
            </p>
          </statement>

          <feedback id="AP-this_opt_e">
            <p>Incorrect. The totalTemp is never used outside its scope.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

</section>
