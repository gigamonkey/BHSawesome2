<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-2-12-loop-analysis">
  <title>Analyzing loops</title>
<!--

      Start with simple loop counting starting from the canonical for loop.

      Then talk about translating slightly more complicated loops into the
      canonical form.

      Nested loops: product of outer and inner.

      Talk about analyzing beginning and ends of loops. Are the first and last
      values of the loop variable what you want?

      Finally talk about tracing tables as a last resort for complicated loops.

  -->
  <introduction>
    <p>
      While conceptually simple, loops actually turn out to be a bit tricky to
      get right. Unfortunately stepping through the execution of a loop line by
      line can be tedious due to the repetition—imagine if you had a loop that
      ran a million times; you wouldn’t want to step through that! So it’s
      useful to have a few techniques for analyzing loops a bit more abstractly.
    </p>

    <p>
      Often the main question we have about a loop is simply how many times will
      the body run? Sometimes this is in order to do <term>run-time
      analysis</term> in order to get an estimate of how long a program will
      take. (A loop that runs a billion times is going to take a lot longer than
      one that runs ten times even though, textually, the code of the two loops
      might be identical.) More often we know how many times the loop is
      supposed to run and we want to make sure we’ve written the loop correctly.
    </p>

    <p>
      In particular, a common bug that occurs in loops is called a
      <term>fencepost error</term> or an <term>off-by-one error</term> which is
      when a loop iterates one fewer times (or occasionally one more) than it
      should. The name comes from the mistake that many people make when asked
      how many fenceposts—the uprights in a fence—you need to build a hundred
      foot fence with fenceposts every ten feet. If you think the answer is ten
      you have a fencepost error because the correct answer is eleven.
    </p>

    <p>
      If all else fails, sometimes it is necessary to trace through some or all
      the iterations of loop. If so we’ll want to use a techniue called a
      <term>trace table</term> to keep track of things.
    </p>

    <p>
      In this lesson, we’ll look at all three of these ways of analyzing loops.
    </p>
  </introduction>

  <subsection>
    <title>Counting loop iterations</title>

    <p>
      The simplest way to know how many times the body of a loop is going to run
      is to write the loop simply. Here’s is the <term>canonical</term>
      <c>for</c> loop:
    </p>

    <program>
      <![CDATA[

      for (int i = 0; i < n; i++) {
        // whatever
      }

      ]]>
    </program>

    <p>
      Whenever you can, we should write our loops in this form. There are a few
      features that make it the canonical loop:
    </p>

    <p>
      <ol>
        <li>The loop variable, <c>i</c> starts at <c>0</c>.</li>

        <li>The loop variable is incremented by one in the updater.</li>

        <li>
          The comparison uses <c>&lt;</c> so the maximum value of <c>i</c> is
          one less than <c>n</c>.
        </li>
      </ol>
    </p>

    <p>
      After ensuring those features are present, any Java programmer should be
      able to look at this loop and almost instantly respond to the question,
      “How many times will the body run?” with the answer, “<c>n</c> times.” In
      this case <c>n</c> is a variable but it could be any expression.
    </p>

    <p>
      If it was a literal number like <c>10</c> the answer would be “ten times”.
      And if it was some other expression like <c>s.length()</c> where <c>s</c>
      was a <c>String</c>, the answer would be “once for every character in
      <c>s</c>”.
    </p>

    <p>
      Note that it <em>is</em> possible for code in the loop body to cause the
      loop to complete early. For instance, a <c>return</c> statement causes an
      immediate return from the method, breaking out of the loop early. But for
      purposes of analyzing loops, we typically assume nothing like that happens
      in the body.
    </p>

    <activity label="canonical-loop-1">
      <title>A canonical loop</title>

      <statement>
        <p>
          How many times does this loop run? (Assume the body doesn’t contain
          any code to cause the loop to complete early.)
        </p>

        <program>
          <![CDATA[

          for (int i = 0; i < 100; i++) {
            // whatever
          }

          ]]>
        </program>
      </statement>

      <choices randomize="yes">
        <choice correct="yes">
          <statement>
            <p>100</p>
          </statement>

          <feedback>
            <p>Yes.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>101</p>
          </statement>

          <feedback>
            <p>
              That would be correct if the condition used &lt;= rather than
              &lt;.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>99</p>
          </statement>

          <feedback>
            <p>
              You may have a fencepost error. While the largest value <c>i</c>
              will take on in the body of the loop is 99, there are one hundred
              numbers between 0-99, inclusive.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>It’s an infinite loop</p>
          </statement>

          <feedback>
            <p>Not sure why you’d think that. Check again.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      Often the easiest way to analyze a non-canonical loop is to turn into into
      a canonical loop by accounting for whatever things make it non-canonical.
    </p>

    <p>
      For instance if a loop uses <c>&lt;=</c> rather than <c>&lt;</c> we can
      change the <c>&lt;=</c> to a <c>&lt;</c> if we add one to the limit. And
      assuming we’re only trying to figure out how many times the loop body will
      run we’re can add or subtract the same amount from both the initial value
      and the limit to get a canonical loop that will run the same number of
      times (though obviously with different values for the loop variable).
    </p>

    <table>
      <title>
        Non-canonical and canonical loops with same number of iterations
      </title>

      <tabular>
        <col right="minor" />
        <col />
        <row header="yes" bottom="minor">
          <cell>Non-canonical loop</cell>
          <cell>Canonical loop</cell>
        </row>

        <row>
          <cell><c>for (int i = 0; i &lt;= 9; i++)</c></cell>
          <cell><c>for (int i = 0; i &lt; 10; i++)</c></cell>
        </row>

        <row>
          <cell><c>for (int i = 1; i &lt; 11; i++)</c></cell>
          <cell><c>for (int i = 0; i &lt; 10; i++)</c></cell>
        </row>

        <row>
          <cell><c>for (int i = 10; i &lt; 20; i++)</c></cell>
          <cell><c>for (int i = 0; i &lt; 10; i++)</c></cell>
        </row>
      </tabular>
    </table>

    <p>
      We can also use this trick to analyze loops that run backwards. To convert
      a backwards loop to a canonical forwards loop we first convert it to an
      equivalent (except for the order, obviously) forward loop and put that
      forward loop into canonical form.
    </p>

    <p>
      To turn around a backwards loop, write a forwards loop where the initial
      value of the loop variable is value of the limit in the originial loop if
      it is written with &gt;= and one greater than the limit if it is written
      with &gt;. And the limit in the forwards loop is one greater than the
      initial value in the backwards loop.
    </p>

    <table>
      <title>
        Backwards loops to canonical loops with same number of iterations
      </title>

      <tabular>
        <col right="minor" />
        <col right="minor" />
        <col />
        <row header="yes" bottom="minor">
          <cell>Backwards loop</cell>
          <cell>Forwards loop</cell>
          <cell>Canonical loop</cell>
        </row>

        <row>
          <cell><c>for (int i = 9; i &gt;= 0; i--)</c></cell>
          <cell><c>for (int i = 0; i &lt; 10; i++)</c></cell>
          <cell><c>for (int i = 0; i &lt; 10; i++)</c></cell>
        </row>

        <row>
          <cell><c>for (int i = 10; i &gt; 0; i--)</c></cell>
          <cell><c>for (int i = 1; i &lt; 11; i++)</c></cell>
          <cell><c>for (int i = 0; i &lt; 10; i++)</c></cell>
        </row>

        <row>
          <cell><c>for (int i = 19; i &gt;= 10 i--)</c></cell>
          <cell><c>for (int i = 10; i &lt; 20; i++)</c></cell>
          <cell><c>for (int i = 0; i &lt; 10; i++)</c></cell>
        </row>
      </tabular>
    </table>

    <activity label="backwards-loop-1">
      <title>A backwards loop</title>

      <statement>
        <p>
          How many times does this loop run? (Assume the body doesn’t contain
          any code to cause the loop to complete early.)
        </p>

        <program>
          <![CDATA[

          for (int i = 20; i > 10; i--) {
            // whatever
          }

          ]]>
        </program>
      </statement>

      <choices randomize="yes">
        <choice correct="yes">
          <statement>
            <p>10</p>
          </statement>

          <feedback>
            <p>Yes.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>11</p>
          </statement>

          <feedback>
            <p>
              That would be correct if the condition used &gt;= rather than
              &lt;.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>9</p>
          </statement>

          <feedback>
            <p>
              You may have a fencepost error. While the largest value <c>i</c>
              will take on in the body of the loop is 20 and the smallest is 11,
              there are ten numbers between 11-20, counting 11 and 20
              themselves.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>It’s an infinite loop</p>
          </statement>

          <feedback>
            <p>Not sure why you’d think that. Check again.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="countstars1">
      <title>Line of stars</title>

      <statement>
        <p>
          How many stars are printed out in this loop? Depends how many
          iterations the loop runs. See if you can convert the loop to a
          canonical loop in your head or on a piece of paper to predecict how
          many iterations it will run before you run the code.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class CountLoop {

              public static void main(String[] args) {
                  for (int i = 3; i < 7; i++) {
                      System.out.print("*");
                  }
              }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "****\n";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>

    <p>
      Translating between non-canonical and canonical loops is a good skill to
      have. In general we should write loops in canonical form whenever we can
      so that people reading our code (including ourselves!) can see at a glance
      what is going on. That will also make the times when we have to write a
      non-canonical loop because something tricky is going on stand out so we
      know to pay extra careful attention to that code.
    </p>

    <p>
      But we can further distill the process of converting to a canonical loop
      if all we care about is how many times the loop body will run. For any
      loop all we really need to know is the smallest value the loop variable
      will take on and the limit, which is one greater than the largest value.
      I.e. these are the initial value and the value to the right of the &lt; in
      the condition of a canonical loop. Then the number of times the loop will
      run is just <m>limit - smallestValue</m>.
    </p>

    <table>
      <title>Using <m>limit - smallestValue</m> formula</title>

      <tabular halign="center">
        <col halign="left" right="minor" />
        <col right="minor" />
        <col right="minor" />
        <col />
        <row header="yes" bottom="minor">
          <cell>Loop</cell>
          <cell>Smallest</cell>
          <cell>Limit</cell>
          <cell>Iterations</cell>
        </row>

        <row>
          <cell><c>for (int i = 0; i &lt; 10; i++)</c></cell>
          <cell>0</cell>
          <cell>10</cell>
          <cell>10</cell>
        </row>

        <row>
          <cell><c>for (int i = 0; i &lt;= 9; i++)</c></cell>
          <cell>0</cell>
          <cell>10</cell>
          <cell>10</cell>
        </row>

        <row>
          <cell><c>for (int i = 1; i &lt; 11; i++)</c></cell>
          <cell>1</cell>
          <cell>11</cell>
          <cell>10</cell>
        </row>

        <row>
          <cell><c>for (int i = 10; i &lt; 20; i++)</c></cell>
          <cell>10</cell>
          <cell>20</cell>
          <cell>10</cell>
        </row>

        <row>
          <cell><c>for (int i = 9; i &gt;= 0; i--)</c></cell>
          <cell>0</cell>
          <cell>10</cell>
          <cell>10</cell>
        </row>

        <row>
          <cell><c>for (int i = 10; i &gt; 0; i--)</c></cell>
          <cell>1</cell>
          <cell>11</cell>
          <cell>10</cell>
        </row>

        <row>
          <cell><c>for (int i = 19; i &gt;= 10 i--)</c></cell>
          <cell>10</cell>
          <cell>20</cell>
          <cell>10</cell>
        </row>
      </tabular>
    </table>
  </subsection>

  <subsection>
    <title>Analyzing nested loops</title>

    <p>
      Recall that nested loops are just loops within the body of another loop.
      Since the whole inner loop runs all of its iterations every time the outer
      loop’s body runs once, the total number of times the body of a nested loop
      runs is the number of times the outer loop runs multiplied by the number
      of times the inner loop runs. Here is an example of a nested loop that
      prints a rectangle of stars:
    </p>

    <activity label="countstars">
      <title>Grid of stars</title>

      <statement>
        <p>
          How many stars are printed out by the following loops? How many times
          do the loops run? Figure it out in our head or on paper before you run
          the code.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class NestedLoops {

              public static void main(String[] args) {
                  for (int row = 0; row < 5; row++) {
                      for (int col = 0; col < 10; col++) {
                          System.out.print("*");
                      }
                      System.out.println();
                  }
              }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "**********\n**********\n**********\n**********\n**********\n";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>

    <p>
      Analyzing the nested loops using the formula from above, we see that the
      outer loop has a smallest value of <c>0</c> and a limit of <c>5</c> so it
      runs <m>5 - 0 = 5</m> times. And the inner loop has a smallest value of
      <c>0</c> and a limit of <c>10</c> so it runs <m>10 - 0 = 10</m> times. And
      five times ten gives us fifty total stars.
    </p>

    <activity label="swap-rows-cols">
      <title>Swap rows and columns</title>

      <statement>
        <p>
          The code in the previous problem printed a grid of five rows and ten
          columns. Which of the following print a grid of ten rows and five
          columns?
        </p>
      </statement>

      <choices randomize="yes">
        <choice correct="yes">
          <statement>
            <program>
              <![CDATA[

              for (int row = 0; row < 10; row++) {
                  for (int col = 0; col < 5; col++) {
                      System.out.print("*");
                  }
                  System.out.println();
              }

              ]]>
            </program>
          </statement>

          <feedback>
            <p>Yes.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <program>
              <![CDATA[

              for (int row = 0; row <= 5; row++) {
                  for (int col = 0; col <= 10; col++) {
                      System.out.print("*");
                  }
                  System.out.println();
              }

              ]]>
            </program>
          </statement>

          <feedback>
            <p>Yes.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <program>
              <![CDATA[

              for (int row = 0; row < 5; row++) {
                  for (int col = 0; col < 10; col++) {
                      System.out.print("*");
                      System.out.println();
                  }
              }

              ]]>
            </program>
          </statement>

          <feedback>
            <p>Yes.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection>
    <title>Trace tables</title>

    <p>
      Because they are hard enough to get right even when they’re simple, it’s a
      good idea to keep loops as simple as possible. But sometimes we come
      across loop that contain multiple variables that all change in the body of
      the loop and which may all be involved in the loop’s condition which makes
      all our simpler loop analysis techniques less useful. In those situations
      it may be time to pull out a piece of scratch paper and create a
      <term>trace table</term>.
    </p>

    <p>
      A trace table is a table that we use to track the values of the variables
      in a loop at each iteration of the loop. Each row of the table represents
      one iteration of the loop and each column holds the value for one
      variable. To see how to build a trace table we’ll use this example loop.
    </p>

    <program>
      <![CDATA[

      int var1 = 3;
      int var2 = 2;

      while ((var2 != 0) && ((var1 / var2) >= 0)) {
          var1 = var1 + 1;
          var2 = var2 - 1;
      }

      ]]>
    </program>

    <p>
      This is not absurdly complicated but it’s definitely not a simple counting
      loop.
    </p>

    <p>
      To make a trace table, the first step is to count the variables that are
      assigned values in the body of the loop Make a table with as many columns
      as variables plus one. Label the first column “iteration”. Then label the
      remaining columns with variable names in the order that they are assigned
      new values in the loop body. The header row for a trace table for this
      loop would look like this:
    </p>

    <tabular halign="center">
      <col right="minor" />
      <col right="minor" />
      <col />
      <row header="yes" bottom="minor">
        <cell>Iteration</cell>
        <cell><c>var1</c></cell>
        <cell><c>var2</c></cell>
      </row>
    </tabular>

    <p>
      Now to fill out the table add row for iteration <c>0</c>, i.e. before the
      loop body has run and fill in the initial value of each variable in the
      appropriate column.
    </p>

    <tabular halign="center">
      <col right="minor" />
      <col right="minor" />
      <col />
      <row header="yes" bottom="minor">
        <cell>Iteration</cell>
        <cell><c>var1</c></cell>
        <cell><c>var2</c></cell>
      </row>

      <row>
        <cell>0</cell>
        <cell>3</cell>
        <cell>2</cell>
      </row>
    </tabular>

    <p>
      Then add rows to the table, Before you add a new row, check whether the
      loop condition given the values of the variables recorded in the current
      row. If it is <c>false</c> the loop ends and the table is complete. But if
      it’s <c>true</c>, add a row, increasing the number in the iteration
      column, and then mentally executing the code in the loop to determine the
      new value of each variable.
    </p>

    <p>
      If one variable depends on a variable to its left in the table, use the
      value in the current row; otherwise—including if the variable depends on
      itself—use the value from the previous row. (This is why it’s important to
      put the variables into columns in the right order.)
    </p>

    <p>The completed table for the loop above should look like this</p>

    <tabular halign="center">
      <col right="minor" />
      <col right="minor" />
      <col />
      <row header="yes" bottom="minor">
        <cell>Iteration</cell>
        <cell><c>var1</c></cell>
        <cell><c>var2</c></cell>
      </row>

      <row>
        <cell>0</cell>
        <cell>3</cell>
        <cell>2</cell>
      </row>

      <row>
        <cell>1</cell>
        <cell>4</cell>
        <cell>1</cell>
      </row>

      <row>
        <cell>2</cell>
        <cell>5</cell>
        <cell>0</cell>
      </row>
    </tabular>

    <p>
      From the last row of a completed trace table we can read off how many
      times the body was executed from the iteration column and the final values
      of all the variables. Note it even works if if the loop’s condition is
      never true and the body never executes. In that case the last row will be
      for iteration <c>0</c> and the final values of all the variables will be
      whatever they were initialized to.
    </p>

    <activity label="example_trace_loop">
      <title>Check the trace table</title>

      <statement>
        <p>
          Make sure you understand how the table was filled out. You may want to
          get a piece of paper and try to make your own table and see if you get
          the same answer as above. Or you can click the Code Lens button to
          trace the code below or add print statements like
          <c>System.out.println("var1: " + var1 + " var2: " + var2);</c> before,
          inside, and after the loop and Run the code to see how the variables
          change.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class Trace {

              public static void main(String[] args) {
                  int var1 = 3;
                  int var2 = 2;

                  while ((var2 != 0) && ((var1 / var2) >= 0)) {
                      var1 = var1 + 1;
                      var2 = var2 - 1;
                  }
              }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "var1: 3 var2: 2\nvar1: 4 var2: 1\nvar1: 5 var2: 0\n";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>

    <activity label="loop-trace-count">
      <statement>
        <p>
          What are the values of var1 and var2 when the code finishes executing?
        </p>

        <program>
          <![CDATA[

          int var1 = 0;
          int var2 = 2;

          while ((var2 != 0) && ((var1 / var2) >= 0))
          {
             var1 = var1 + 1;
             var2 = var2 -1;
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>var1 = 1, var2 = 1</p>
          </statement>

          <feedback>
            <p>
              The loop stops one of two ways, when var2 = 0 or when var1 / var2
              = 0 - neither is true in this case
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>var1 = 2, var2 = 0</p>
          </statement>

          <feedback>
            <p>
              The loop stopped because var2 = 0. After the first execution of
              the loop var1 = 1 and var2 = 1. After the second execution of the
              loop var1 = 2 and var2 = 0. This stops the loop and doesn't
              execute the second part of the complex conditional.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>var1 = 3, var2 = -1</p>
          </statement>

          <feedback>
            <p>
              The loop stops one of two ways, when var2 = 0 or when var1 / var2
              = 0 - neither is true in this case
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>var1 = 0, var2 = 2</p>
          </statement>

          <feedback>
            <p>
              The loop stops one of two ways, when var2 = 0 or when var1 / var2
              = 0 - neither is true in this case
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The loop will cause a run-time error with a division by zero</p>
          </statement>

          <feedback>
            <p>
              Even though var1 = 2 and var2 = 0 when the conditional is executed
              the first condition is true so the rest of the complex conditional
              won't execute.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="loop-trace-count2">
      <statement>
        <p>What are the values of x and y when the code finishes executing?</p>

        <program>
          <![CDATA[

          int x = 2;
          int y = 5;

          while (y > 2 && x < y)
          {
             x = x + 1;
             y = y - 1;
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>x = 5, y = 2</p>
          </statement>

          <feedback>
            <p>
              This would be true if the and (&amp;&amp;) was an or (||) instead.
              But in a complex conditional joined with and (&amp;&amp;) both
              conditions must be true for the condition to be true.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>x = 2, y = 5</p>
          </statement>

          <feedback>
            <p>
              This would be true if the loop never executed, but both conditions
              are true so the loop will execute.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>x = 5, y = 2</p>
          </statement>

          <feedback>
            <p>
              This would be true if the values were swapped, but they are not.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>x = 3, y = 4</p>
          </statement>

          <feedback>
            <p>
              This would be true the loop only executed one time, but it will
              execute twice.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>x = 4, y = 3</p>
          </statement>

          <feedback>
            <p>
              The first time the loop changes to x = 3, y = 4, the second time x
              = 4, y = 3 then the loop will stop since x is not less than y
              anymore.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity xml:id="complex-loop-trace-table">
      <title>Tracing a hairy loop</title>

      <statement>
        <p>
          Here is a particularly hairy loop. Get a piece of scratch paper and
          make a trace table. When you are done, click “Answer” and compare to
          see if you got it right.
        </p>

        <program>
          <![CDATA[

          int x = 0;
            int y = 4;
            int z = 2;

            while (x < 3 && y >= 0) {
              x = y - z;
              y--;
              z *= 2;
            }
          }

          ]]>
        </program>
      </statement>

      <answer>
        <tabular halign="center">
          <col right="minor" />
          <col right="minor" />
          <col right="minor" />
          <col />
          <row header="yes" bottom="minor">
            <cell>Iteration</cell>
            <cell><c>x</c></cell>
            <cell><c>y</c></cell>
            <cell><c>z</c></cell>
          </row>

          <row>
            <cell>0</cell>
            <cell>0</cell>
            <cell>4</cell>
            <cell>2</cell>
          </row>

          <row>
            <cell>1</cell>
            <cell>2</cell>
            <cell>3</cell>
            <cell>4</cell>
          </row>

          <row>
            <cell>2</cell>
            <cell>-1</cell>
            <cell>2</cell>
            <cell>8</cell>
          </row>

          <row>
            <cell>3</cell>
            <cell>-6</cell>
            <cell>1</cell>
            <cell>16</cell>
          </row>

          <row>
            <cell>4</cell>
            <cell>-15</cell>
            <cell>0</cell>
            <cell>32</cell>
          </row>

          <row>
            <cell>5</cell>
            <cell>-32</cell>
            <cell>-1</cell>
            <cell>64</cell>
          </row>
        </tabular>
      </answer>
    </activity>
  </subsection>

  <subsection>
    <title>Limits of trace tables</title>

    <p>
      It’s useful to know how to build trace tables and actually making them is
      good practice for following a mechanical procedure precisely which is good
      practice for thinking about how code works.
    </p>

    <p>
      In actual programming practice, trace tables are of limited use. They have
      the virtue that, similar to boolean truth tables, once you master the
      mechanics you can reliably crank them out without having to think too
      hard. On the other hand, code tracing is only possible if we know the
      initial values. And if we knew the initial values we could just run the
      program to find out what it does. Or write a program to print out the
      trace table! To actually understand a loop via tracing you might need to
      trace it multiple times with different initial values. Which is even more
      tedious than making just one.
    </p>

    <p>
      However there are times (particularly on the AP exam) when a trace table
      can quickly and reliably answer certain questions about a piece of code.
      If you ever find yourself confronting as hairy a loop as the one in <xref
      ref="complex-loop-trace-table" />, you way want to make a trace table to
      help yourself understand what’s going on so you can rewrite it to be
      simpler. Unless the loop is on the AP exam in which case just shake your
      fist at the AP exam writers and then answer the question.
    </p>
  </subsection>

  <subsection>
    <title>Coding Challenge: POGIL Analyzing Loops</title>

    <p>
      We encourage you to do this activity as a <url
      href="https://pogil.org/about-pogil/what-is-pogil"
      visual="https://pogil.org/about-pogil/what-is-pogil">POGIL</url> (Process
      Oriented Guided Inquiry Learning) group activity. POGIL groups are
      self-managed teams of up to 4 students where everyone has a <url
      href="https://docs.google.com/document/d/1_NfNLWJxaG4qZ2Jd2x8UctDS05twn1h6p-o3XaAcRv0/edit?usp=sharing"
      visual="https://docs.google.com/document/d/1_NfNLWJxaG4qZ2Jd2x8UctDS05twn1h6p-o3XaAcRv0/edit?usp=sharing">POGIL
      role</url> and works together to solve the problems, making sure that
      everyone in the team participates and learns.
    </p>

    <p>
      Do the following exercises in your group. Make sure you draw the trace
      tables keeping track of all the variables in the loops. Use the formulas
      to determine how many times the loops run. If your group finishes early,
      do some of the multiple-choice problems in the Practice and Summary
      section of this unit.
    </p>

    <activity label="qln1">
      <statement>
        <p>How many times does the following code print a <c>*</c>?</p>

        <program>
          <![CDATA[

          for (int i = 3; i < 8; i++)
          {
              for (int y = 1; y < 5; y++)
              {
                  System.out.print("*");
              }
              System.out.println();
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>40</p>
          </statement>

          <feedback>
            <p>
              This would be true if the outer loop executed 8 times and the
              inner 5 times, but what is the initial value of <c>i</c>?
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>20</p>
          </statement>

          <feedback>
            <p>
              The outer loop executes 7-3+1=5 times and the inner 4-1+1=4 so
              this will print 5 * 4 = 20 stars.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>24</p>
          </statement>

          <feedback>
            <p>
              This would be true if the outer loop executed 6 times such as if
              it was <c>i &lt;= 8</c>.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>30</p>
          </statement>

          <feedback>
            <p>
              This would be true if the inner loop executed 5 times such as if
              it was <c>y &lt;= 5</c>.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qln2">
      <statement>
        <p>What does the following code print?</p>

        <program>
          <![CDATA[

          for (int i = 2; i < 8; i++)
          {
              for (int y = 1; y <= 5; y++)
              {
                  System.out.print("*");
              }
              System.out.println();
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>A rectangle of 8 rows with 5 stars per row.</p>
          </statement>

          <feedback>
            <p>This would be true if i was initialized to 0.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>A rectangle of 8 rows with 4 stars per row.</p>
          </statement>

          <feedback>
            <p>
              This would be true if i was initialized to 0 and the inner loop
              continued while <c>y &lt; 5</c>.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>A rectangle of 6 rows with 5 stars per row.</p>
          </statement>

          <feedback>
            <p>
              The outer loop executes 8-2+1=6 times so there are 6 rows and the
              inner loop executes 5-1+1=5 times so there are 5 columns.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>A rectangle of 6 rows with 4 stars per row.</p>
          </statement>

          <feedback>
            <p>
              This would be true if the inner loop continued while <c>y &lt;
              5</c>.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qln3">
      <statement>
        <p>What does the following print?</p>

        <program>
          <![CDATA[

          for (int i = 3; i <= 9; i++)
          {
             for (int j = 6; j > 0; j--)
             {
                 System.out.print("*");
             }
             System.out.println();
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>A rectangle of 9 rows and 5 stars per row.</p>
          </statement>

          <feedback>
            <p>Did you notice what i was initialized to?</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>A rectangle of 6 rows and 6 stars per row.</p>
          </statement>

          <feedback>
            <p>It would print 6 rows if it was <c>i &lt; 9</c>.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>A rectangle of 7 rows and 5 stars per row.</p>
          </statement>

          <feedback>
            <p>It would print 5 stars per row if it was <c>j &gt; 1</c>.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>A rectangle of 7 rows and 6 stars per row.</p>
          </statement>

          <feedback>
            <p>
              The outer loop executes 9 - 3 + 1 = 7 times and the inner 6 - 1 +
              1 = 6 times.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qln4">
      <statement>
        <p>
          Consider the following code segment. How many times is the string
          “Hi!” printed as a result of executing the code segment?
        </p>

        <program>
          <![CDATA[

          int i = 0;
          while (i <= 4)
          {
            for (int j = 0; j < 3; j++)
            {
              System.out.println("Hi!");
            }
            i++;
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>15</p>
          </statement>

          <feedback>
            <p>
              The outer loop executes 4-0+1=5 times and the inner loop 2-0+1=3,
              so hi is printed 5*3 = 15 times
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>12</p>
          </statement>

          <feedback>
            <p>The outer loop runs 5 times for i = 0, 1, 2, 3, 4.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>10</p>
          </statement>

          <feedback>
            <p>The inner loop runs 3 times for j = 0, 1, 2.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>8</p>
          </statement>

          <feedback>
            <p>The outer loop runs 5 times for i = 0, 1, 2, 3, 4.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection>
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 2.12.A.1) A <term>statement execution count</term> indicates the
            number of times a statement is executed by the program. Statement
            execution counts are often calculated informally through tracing and
            analysis of the iterative statements.
          </p>
        </li>

        <li>
          <p>
            A trace table can be used to keep track of the variables and their
            values throughout each iteration of the loop.
          </p>
        </li>

        <li>
          <p>
            The number of times a loop executes can be calculated by
            <c>largestValue - smallestValue + 1</c> where these are the largest
            and smallest values of the loop counter variable possible in the
            body of the loop.
          </p>
        </li>

        <li>
          <p>
            The number of times a nested for-loop runs is the number of times
            the outer loop runs <term>times</term> the number of times the inner
            loop runs.
          </p>
        </li>

        <li>
          <p>
            In non-rectangular loops, the number of times the inner loop runs
            can be calculated with the sum of natural numbers formula
            <c>n(n+1)/2</c> where n is the number of times the outer loop runs
            or the maximum number of times the inner loop runs.
          </p>
        </li>
      </ul>
    </p>
  </subsection>
</section>
