<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-2-12-loop-analysis">
  <title>Analyzing loops</title>
<!--

      Start with simple loop counting starting from the canonical for loop.

      Then talk about translating slightly more complicated loops into the
      canonical form.

      Nested loops: product of outer and inner.

      Talk about analyzing beginning and ends of loops. Are the first and last
      values of the loop variable what you want?

      Finally talk about tracing tables as a last resort for complicated loops.

  -->
  <introduction>
    <p>
      While conceptually simple, loops actually turn out to be a bit tricky to
      get right. Unfortunately stepping through the execution of a loop line by
      line can be tedious due to the repetition—imagine if you had a loop that
      ran a million times; you wouldn’t want to step through that! So it’s
      useful to have a few techniques for analyzing loops a bit more abstractly.
    </p>

    <p>
      Sometimes the main question we have about a loop is simply how many times
      will the body run? Sometimes the answer is a specific number but more
      often it’s some other relevant value in the program, such as a loop that
      is going to run it’s body as many times as there are characters in some
      <c>String</c>.
    </p>

    <p>
      Other times we care less about the particular number than whether a loop
      starts and stops at the right place. A common bug that occurs in loops is
      called a <term>fencepost error</term> or an <term>off-by-one error</term>
      which occurs when a loop repeats one fewer times (or occasionally one
      more) than it should. The name comes from the natural mistake that occurs
      when people are asked how many fenceposts—the uprights in a fence—you need
      to build a hundred foot fence with fenceposts every ten feet. If you think
      the answer is ten you have a fencepost error because the correct answer is
      eleven.
    </p>

    <p>
      If all else fails, sometimes it is necessary to trace through some or all
      the iterations of loop. If so we’ll want to use a techniue called a
      <term>tracing table</term> to keep track of things.
    </p>

    <p>
      In this lesson, we’ll look at all three of these ways of analyzing loops.
    </p>
  </introduction>

  <subsection>
    <title>Counting loop iterations</title>

    <p>
      The simplest way to know how many times the body of a loop is going to run
      is to write the loop simply. Here’s is the “canonical” <c>for</c> loop:
    </p>

    <program>
      <![CDATA[

      for (int i = 0; i < n; i++) {
        // whatever
      }

      ]]>
    </program>

    <p>
      There are a few features of this loop that make it the canonical loop:
    </p>

    <p>
      <ol>
        <li>The loop variable, <c>i</c> starts at <c>0</c>.</li>

        <li>The loop variable is incremented by one in the updater.</li>

        <li>
          The comparison uses &lt; so the maximum value of <c>i</c> is one less
          than <c>n</c>.
        </li>
      </ol>
    </p>

    <p>
      After ensuring those features are present, any Java programmer should be
      able to look at this loop and almost instantly answer the question, “How
      many times will the body run?” with the answer, “<c>n</c> times.” In this
      case <c>n</c> is a variable. If it was a literal number like <c>10</c> the
      answer would be “ten times”. And if it was some other expression like
      <c>s.length()</c> where <c>s</c> was a <c>String</c>, the loop body would
      run as many times as there are characters in <c>s</c>.
    </p>

    <p>
      There are things that could happen in the body of the loop that would
      cause the loop to complete early. For instance, if the body of the loop
      contains a <c>return</c> statement, that could break us out of the loop
      early. But for purposes of analyzing the loop, we are assuming nothing
      like that happens in the body.
    </p>

    <activity label="canonical-loop-1">
      <title>A canonical loop</title>

      <statement>
        <p>
          How many times does this loop run? (Assume the body doesn’t contain
          any code to cause the loop to complete early.)
        </p>

        <program>
          <![CDATA[

          for (int i = 0; i < 100; i++) {
            // whatever
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>100</p>
          </statement>

          <feedback>
            <p>Yes.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>101</p>
          </statement>

          <feedback>
            <p>
              That would be correct if the condition used &lt;= rather than
              &lt;.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>99</p>
          </statement>

          <feedback>
            <p>
              You may have a fencepost error. While the largest value <c>i</c>
              will take on in the body of the loop is 99, there are one hundred
              numbers between 0-99, inclusive.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>It’s an infinite loop</p>
          </statement>

          <feedback>
            <p>Not sure why you’d think that. Check again.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      Often the easiest way to analyze a non-canonical loop is to turn into into
      a canonical loop by accounting for whatever things make it non-canonical.
      For instance if a loop uses <c>&lt;=</c> rather than <c>&lt;</c> we can
      change the <c>&lt;=</c> to a <c>&lt;</c> if we add one to the limit. And
      assuming we’re only trying to figure out how many times the loop body will
      run we’re can add or subtract the same amount from both the initial value
      of the limit to get a canonical loop that will the same number of times.
    </p>

    <table>
      <tabular>
        <col right="minor" />
        <col />
        <row header="yes" bottom="minor">
          <cell>Non-canonical loop</cell>
          <cell>Canonical loop with same number of iterations</cell>
        </row>

        <row>
          <cell><c>for (int i = 0; i &lt;= 10; i++)</c></cell>
          <cell><c>for (int i = 0; i &lt; 11; i++)</c></cell>
        </row>

        <row>
          <cell><c>for (int i = 1; i &lt; 10; i++)</c></cell>
          <cell><c>for (int i = 0; i &lt; 9; i++)</c></cell>
        </row>

        <row>
          <cell><c>for (int i = 10; i &lt; 20; i++)</c></cell>
          <cell><c>for (int i = 0; i &lt; 10; i++)</c></cell>
        </row>
      </tabular>
    </table>

    <p>
      Loops can be also analyzed to determine how many times they run. This is
      called <term>run-time analysis</term> or a <term>statement execution
      count</term>. A <term>statement execution count</term> indicates the
      number of times a statement is executed by the program. Statement
      execution counts are often calculated informally through tracing and
      analysis of the iterative statements.
    </p>

    <activity label="countstars1">
      <statement>
        <p>
          How many stars are printed out in this loop? How many times does the
          loop run? Figure it out on paper before you run the code.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class CountLoop
          {

              public static void main(String[] args)
              {
                  for (int i = 3; i < 7; i++)
                  {
                      System.out.print("*");
                  }
              }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "****\n";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>

    <p>
      If you made a trace table, you would know that the loop runs when i = 3,
      4, 5, 6 but finishes as soon as i becomes 7 since that is not less than 7.
      So, the loop runs 4 times. Or you can use the shortcut formula in the note
      below.
    </p>

    <note>
      <p>
        The number of times a loop executes can be calculated by
        <em>(largestValue - smallestValue + 1)</em>.
      </p>

      <p>
        <ul>
          <li>
            <p>
              If the loop uses counter &lt;= limit, limit is the largest value.
            </p>
          </li>

          <li>
            <p>
              If the loop uses counter &lt; limit, limit-1 is the largest value
              that allows the loop to run.
            </p>
          </li>
        </ul>
      </p>
    </note>

    <p>
      In the code above the largest value that allows the loop to run is 6
      (which is the largest value &lt; 7) and the smallest value that allows the
      loop to execute is 3 so this loop executes (6 - 3 + 1 = 4 times).
    </p>

    <p>
      Nested loops are loops within loops. The number of times a nested loop
      runs is the number of times the outer loop runs <term>times</term> the
      number of times the inner loop runs. Here is an example of a nested loop
      that prints a rectangle of stars:
    </p>

    <activity label="countstars">
      <statement>
        <p>
          How many stars are printed out by the following loops? How many times
          do the loops run? Calculate on paper before you run the code.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class NestedLoops
          {

              public static void main(String[] args)
              {
                  for (int row = 0; row < 5; row++)
                  {
                      for (int col = 0; col < 10; col++)
                      {
                          System.out.print("*");
                      }
                      System.out.println();
                  }
              }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "**********\n**********\n**********\n**********\n**********\n";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>

    <note>
      <p>
        The number of times a nested for loop body is executed is the number of
        times the outer loop runs multiplied by the number of times the inner
        loop runs (outer loop runs * inner loop runs).
      </p>
    </note>

    <p>
      For the example above, the outer loop executes 4 - 0 + 1 = 5 times and the
      inner 9 - 0 + 1 = 10 times so the total is 5 * 10 = 50.
    </p>
  </subsection>

  <subsection>
    <title>Tracing Loops</title>

    <p>
      Let’s practice tracing through loops with many variables. Remember to make
      a tracing table to keep track of all the variables, the iterations, and
      the output.
    </p>

    <p>
      Here is a complex loop. See if you can trace the code on paper by making a
      tracing table to predict what the code will do when you run it. Click on
      the this <url href="https://goo.gl/qEHnpg"
      visual="https://goo.gl/qEHnpg">Java visualizer</url> link or the Code Lens
      button to help you step through the code.
    </p>

    <activity label="example_trace_loop">
      <statement>
        <p>
          Can you trace through this code? Add in output statements
          <c>System.out.println("var1: " + var1 + " var2: " + var2);</c> before
          the loop and inside the loop at the end to keep track of the variables
          and run. Click on the Code Lens button to visualize the code step by
          step.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class Trace
          {
              public static void main(String[] args)
              {
                  int var1 = 3;
                  int var2 = 2;

                  while ((var2 != 0) && ((var1 / var2) >= 0))
                  {
                      var1 = var1 + 1;
                      var2 = var2 - 1;
                  }
              }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "var1: 3 var2: 2\nvar1: 4 var2: 1\nvar1: 5 var2: 0\n";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>

    <p>Did your trace table look like the following?</p>

    <figure align="center">
      <caption>
        A table showing the values of all of the variables each time through the
        loop. The 0 means before the first loop.
      </caption>

      <image source="Unit2-Selection-and-Iteration/Figures/whileLoopTrace.png" width="27%" />
    </figure>

    <activity label="loop-trace-count">
      <statement>
        <p>
          What are the values of var1 and var2 when the code finishes executing?
        </p>

        <program>
          <![CDATA[

          int var1 = 0;
          int var2 = 2;

          while ((var2 != 0) && ((var1 / var2) >= 0))
          {
             var1 = var1 + 1;
             var2 = var2 -1;
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>var1 = 1, var2 = 1</p>
          </statement>

          <feedback>
            <p>
              The loop stops one of two ways, when var2 = 0 or when var1 / var2
              = 0 - neither is true in this case
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>var1 = 2, var2 = 0</p>
          </statement>

          <feedback>
            <p>
              The loop stopped because var2 = 0. After the first execution of
              the loop var1 = 1 and var2 = 1. After the second execution of the
              loop var1 = 2 and var2 = 0. This stops the loop and doesn't
              execute the second part of the complex conditional.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>var1 = 3, var2 = -1</p>
          </statement>

          <feedback>
            <p>
              The loop stops one of two ways, when var2 = 0 or when var1 / var2
              = 0 - neither is true in this case
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>var1 = 0, var2 = 2</p>
          </statement>

          <feedback>
            <p>
              The loop stops one of two ways, when var2 = 0 or when var1 / var2
              = 0 - neither is true in this case
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>The loop will cause a run-time error with a division by zero</p>
          </statement>

          <feedback>
            <p>
              Even though var1 = 2 and var2 = 0 when the conditional is executed
              the first condition is true so the rest of the complex conditional
              won't execute.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="loop-trace-count2">
      <statement>
        <p>What are the values of x and y when the code finishes executing?</p>

        <program>
          <![CDATA[

          int x = 2;
          int y = 5;

          while (y > 2 && x < y)
          {
             x = x + 1;
             y = y - 1;
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>x = 5, y = 2</p>
          </statement>

          <feedback>
            <p>
              This would be true if the and (&amp;&amp;) was an or (||) instead.
              But in a complex conditional joined with and (&amp;&amp;) both
              conditions must be true for the condition to be true.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>x = 2, y = 5</p>
          </statement>

          <feedback>
            <p>
              This would be true if the loop never executed, but both conditions
              are true so the loop will execute.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>x = 5, y = 2</p>
          </statement>

          <feedback>
            <p>
              This would be true if the values were swapped, but they are not.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>x = 3, y = 4</p>
          </statement>

          <feedback>
            <p>
              This would be true the loop only executed one time, but it will
              execute twice.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>x = 4, y = 3</p>
          </statement>

          <feedback>
            <p>
              The first time the loop changes to x = 3, y = 4, the second time x
              = 4, y = 3 then the loop will stop since x is not less than y
              anymore.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection>
    <title>Coding Challenge: POGIL Analyzing Loops</title>

    <p>
      We encourage you to do this activity as a <url
      href="https://pogil.org/about-pogil/what-is-pogil"
      visual="https://pogil.org/about-pogil/what-is-pogil">POGIL</url> (Process
      Oriented Guided Inquiry Learning) group activity. POGIL groups are
      self-managed teams of up to 4 students where everyone has a <url
      href="https://docs.google.com/document/d/1_NfNLWJxaG4qZ2Jd2x8UctDS05twn1h6p-o3XaAcRv0/edit?usp=sharing"
      visual="https://docs.google.com/document/d/1_NfNLWJxaG4qZ2Jd2x8UctDS05twn1h6p-o3XaAcRv0/edit?usp=sharing">POGIL
      role</url> and works together to solve the problems, making sure that
      everyone in the team participates and learns.
    </p>

    <p>
      Do the following exercises in your group. Make sure you draw the trace
      tables keeping track of all the variables in the loops. Use the formulas
      to determine how many times the loops run. If your group finishes early,
      do some of the multiple-choice problems in the Practice and Summary
      section of this unit.
    </p>

    <activity label="qln1">
      <statement>
        <p>How many times does the following code print a <c>*</c>?</p>

        <program>
          <![CDATA[

          for (int i = 3; i < 8; i++)
          {
              for (int y = 1; y < 5; y++)
              {
                  System.out.print("*");
              }
              System.out.println();
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>40</p>
          </statement>

          <feedback>
            <p>
              This would be true if the outer loop executed 8 times and the
              inner 5 times, but what is the initial value of <c>i</c>?
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>20</p>
          </statement>

          <feedback>
            <p>
              The outer loop executes 7-3+1=5 times and the inner 4-1+1=4 so
              this will print 5 * 4 = 20 stars.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>24</p>
          </statement>

          <feedback>
            <p>
              This would be true if the outer loop executed 6 times such as if
              it was <c>i &lt;= 8</c>.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>30</p>
          </statement>

          <feedback>
            <p>
              This would be true if the inner loop executed 5 times such as if
              it was <c>y &lt;= 5</c>.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qln2">
      <statement>
        <p>What does the following code print?</p>

        <program>
          <![CDATA[

          for (int i = 2; i < 8; i++)
          {
              for (int y = 1; y <= 5; y++)
              {
                  System.out.print("*");
              }
              System.out.println();
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>A rectangle of 8 rows with 5 stars per row.</p>
          </statement>

          <feedback>
            <p>This would be true if i was initialized to 0.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>A rectangle of 8 rows with 4 stars per row.</p>
          </statement>

          <feedback>
            <p>
              This would be true if i was initialized to 0 and the inner loop
              continued while <c>y &lt; 5</c>.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>A rectangle of 6 rows with 5 stars per row.</p>
          </statement>

          <feedback>
            <p>
              The outer loop executes 8-2+1=6 times so there are 6 rows and the
              inner loop executes 5-1+1=5 times so there are 5 columns.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>A rectangle of 6 rows with 4 stars per row.</p>
          </statement>

          <feedback>
            <p>
              This would be true if the inner loop continued while <c>y &lt;
              5</c>.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qln3">
      <statement>
        <p>What does the following print?</p>

        <program>
          <![CDATA[

          for (int i = 3; i <= 9; i++)
          {
             for (int j = 6; j > 0; j--)
             {
                 System.out.print("*");
             }
             System.out.println();
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>A rectangle of 9 rows and 5 stars per row.</p>
          </statement>

          <feedback>
            <p>Did you notice what i was initialized to?</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>A rectangle of 6 rows and 6 stars per row.</p>
          </statement>

          <feedback>
            <p>It would print 6 rows if it was <c>i &lt; 9</c>.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>A rectangle of 7 rows and 5 stars per row.</p>
          </statement>

          <feedback>
            <p>It would print 5 stars per row if it was <c>j &gt; 1</c>.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>A rectangle of 7 rows and 6 stars per row.</p>
          </statement>

          <feedback>
            <p>
              The outer loop executes 9 - 3 + 1 = 7 times and the inner 6 - 1 +
              1 = 6 times.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qln4">
      <statement>
        <p>
          Consider the following code segment. How many times is the string
          “Hi!” printed as a result of executing the code segment?
        </p>

        <program>
          <![CDATA[

          int i = 0;
          while (i <= 4)
          {
            for (int j = 0; j < 3; j++)
            {
              System.out.println("Hi!");
            }
            i++;
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>15</p>
          </statement>

          <feedback>
            <p>
              The outer loop executes 4-0+1=5 times and the inner loop 2-0+1=3,
              so hi is printed 5*3 = 15 times
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>12</p>
          </statement>

          <feedback>
            <p>The outer loop runs 5 times for i = 0, 1, 2, 3, 4.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>10</p>
          </statement>

          <feedback>
            <p>The inner loop runs 3 times for j = 0, 1, 2.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>8</p>
          </statement>

          <feedback>
            <p>The outer loop runs 5 times for i = 0, 1, 2, 3, 4.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection>
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 2.12.A.1) A <term>statement execution count</term> indicates the
            number of times a statement is executed by the program. Statement
            execution counts are often calculated informally through tracing and
            analysis of the iterative statements.
          </p>
        </li>

        <li>
          <p>
            A trace table can be used to keep track of the variables and their
            values throughout each iteration of the loop.
          </p>
        </li>

        <li>
          <p>
            The number of times a loop executes can be calculated by
            <c>largestValue - smallestValue + 1</c> where these are the largest
            and smallest values of the loop counter variable possible in the
            body of the loop.
          </p>
        </li>

        <li>
          <p>
            The number of times a nested for-loop runs is the number of times
            the outer loop runs <term>times</term> the number of times the inner
            loop runs.
          </p>
        </li>

        <li>
          <p>
            In non-rectangular loops, the number of times the inner loop runs
            can be calculated with the sum of natural numbers formula
            <c>n(n+1)/2</c> where n is the number of times the outer loop runs
            or the maximum number of times the inner loop runs.
          </p>
        </li>
      </ul>
    </p>
  </subsection>
</section>
