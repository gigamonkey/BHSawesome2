<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="topic-1-9-method-signatures">
  <title>Writing methods</title>
  <introduction>
    <p>
      To understand how methods work, it’s best to start by looking at how to
      write our own methods.
    </p>
  </introduction>

  <subsection>
    <title>Methods signatures</title>
    <idx>method signature</idx>
    <idx>parameter</idx>
    <idx>argument</idx>
    <idx>return type</idx>
    <idx>parameter list</idx>
    <p>
      As we learned in the previous chapter, when we declare a variable, we need
      to specify its type and its name and optionally an initial value. Defining
      methods is similar but there are more parts we need to specify.
    </p>

    <p>
      To start with, every method has a name which we will use to call the
      method. Additionally a method has a <term>return type</term> which
      specifies the kind of value (if any) the method returns when called. And a
      method can take any number of <term>arguments</term>, values it can use in
      its computation. To specify what number and types of arguments it needs, a
      method defines <term>parameters</term> which are variables that are
      declared as part of the method and which hold the argument values when the
      method is called. Together all these pieces make up the <term>method
      signature</term> or <term>method header</term>.
    </p>

    <p>
      A complete method signature for a method that adds two numbers and returns
      the result might look something like this:
    </p>

    <program language="java">
      public static int add(int a, int b)
    </program>

    <p>
      For now don't worry about the <c>public static</c>, just treat that as
      boiler plate that all your methods will start with. The next word
      <c>int</c> is the return type. It is the name of some type or the special
      keyword <c>void</c> which means the method doesn't return any value. Then
      comes the name of the method, in this case, <c>add</c>. And finally, in
      parentheses, the method’s <term>parameter list</term>, a comma-delimited
      list of variables which are the method's parameters. Parameters are
      declared like other variables with a type and a name. In this method there
      are two, named <c>a</c> and <c>b</c>, both of type <c>int</c>.
    </p>
  </subsection>

  <subsection>
    <title>Method calls</title>
    <p>
      The point of a method signature is that it gives us all the information we
      need to <term>call</term> the method. A <term>method call</term> consists
      of the method name and a pair of parentheses <c>()</c>. The parentheses
      enclose an <term>argument list</term>, a list of expressions, separated by
      commas, whose values provide the arguments the method needs to do its job.
      The number of expressions in the argument list of a method call has to
      match the number of parameters in the parameter list in the method
      signature. If the method takes no arguments, i.e. has an empty parameter
      list, there will be nothing between the parentheses but the parentheses
      are still needed so Java knows we are calling a method and not referring
      to a variable.
    </p>

    <p>
      For instance, a call to the <c>add</c> method with the signature above
      might look like this: <c>add(10, 20)</c>.
    </p>

    <p>
      When a method, such as <c>add</c>, has a return type other than
      <c>void</c> we can use the method call as an expression whose value will
      be whatever value the method returns. In this case that means we can use a
      call to <c>add</c> anywhere we need a value of type <c>int</c>. For
      example, we can use it to provide the initial value in a variable
      declaration:
    </p>

    <program language="java">
      int sum = add(10, 20);
    </program>
  </subsection>

  <subsection>
    <title>Method bodies</title>
    <p>
      Of course the signature does not tell us everything about the method. In
      particular, it does not tell us what computation the method actually
      performs or how it does it. For that we need to write a method body. The
      body is enclosed in a pair of curly braces (<c>{}</c>) and contains code
      that can use the variables from the parameter list. And at an point in the
      methed body we can use the keyword <c>return</c> followed by an expression
      to cause the method to return the value of that expression as the value of
      the method call.
    </p>

    <p>
      For intstance, adding the body to our <c>add</c> method to get a complete
      method definition would look like this:
    </p>

    <program language="java">
      public static int add(int a, int b) {
        return a + b;
      }
    </program>

    <p>
      Seeing the method body, we can actually understand exactly what happens in
      a line like:
    </p>

    <program language="java">
      int sum = add(10, 20);
    </program>

    <p>
      When Java hits the call to <c>add</c>, it first creates variables
      corresponding to the parameters <c>a</c> and <c>b</c> and initializes them
      with the argument values <c>10</c> and <c>20</c>. Then it executes the
      body of the method until it hits a <c>return</c> at which point it
      evaluates the expression after the <c>return</c> and makes that value the
      value of the method call. In other words, roughly equivalent to this.
    </p>

    <program language="java">
      int a = 10;
      int b = 20;
      int sum = a + b;
    </program>

    <activity>
      <title>Trace call to add</title>
      <statement>
        <p>
          To see how a method call works click on the next button below the code
          to step through the code and watch the red arrow jump to the method
          that is being run and watch how the arguments are passed into the
          parameter variables and how the returned value comes back to where the
          method was called.
        </p>
      </statement>

      <program interactive="codelens" language="java" label="check-add" xml:id="check-add">
        <code>
          public class CheckAdd {

            public static int add(int a, int b) {
              return a + b;
            }

            public static void main(String[] args) {
              int sum = add(10, 20);
              System.out.println(sum);
            }
          }
        </code>
      </program>
    </activity>

  </subsection>

  <subsection>
    <title>Other people’s methods</title>

    <p>
      We can also use methods that we didn’t write. In fact we already have.
      <c>System.out.println</c> is a method provided by Java for emitting output
      to the screen. To use methods we didn’t write we just need to know the
      method signature and what they do.
    </p>

    <p>
      For example, the <url
      href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/io/PrintStream.html"><c>PrintStream</c>
      class’s Javadocs</url> document the following method signatures for
      <c>println</c> that we use in <c>System.out.println()</c>:
    </p>

    <p>
      <ul>
        <li>
          <p>
            <c>void println()</c> which has an empty parameter list with no
            parameters
          </p>
        </li>

        <li>
          <p>
            <c>void println(String x)</c> which will print out a <c>String</c>
            value
          </p>
        </li>

        <li>
          <p>
            <c>void println(int x)</c> which will print out an <c>int</c> value
          </p>
        </li>
      </ul>
    </p>

    <p>
      The <c>void</c> return type in these method signatures means that these
      methods don’t return any value. That means we can’t use them in
      expressions to compute values. Instead they are called purely for their
      <term>side effects</term>, in this case emitting something to the screen.
    </p>

    <p>
      We can call these methods with the appropriate arguments to print out the
      value we want. The <term>argument</term> is the actual value that is
      passed to the method when it is called. Here are the method calls that
      correspond to the method signatures above:
    </p>

    <p>
      <ul>
        <li>
          <p>
            <c>System.out.println();</c> // prints a newline
          </p>
        </li>

        <li>
          <p>
            <c>System.out.println("Hello World");</c> // prints a String
          </p>
        </li>

        <li>
          <p>
            <c>System.out.println(42);</c> // prints an int
          </p>
        </li>
      </ul>
    </p>

    <p>
      Compare the method signature of <c>println(String x)</c> with the method
      call <c>println("Hello World");</c> below. The method signature contains
      the method name and the parameter type and variable. The method call
      contains only the method name and the argument value. The argument must be
      compatible with the data type of the parameter in the method signature and
      is saved in the parameter variable when the method is called. Many people
      use the terms parameter and argument interchangeably.
    </p>

    <figure align="center">
      <caption>Method Signature and Method Call</caption>
      <image source="Unit1-Using-Objects-and-Methods/Figures/method-parts.png" width="89%" alt="Method Signature and Method Call" />
    </figure>
  </subsection>

  <subsection>
    <title>Making smaller methods</title>
    <idx>method call</idx>
    <idx>flow of control</idx>
    <idx>tracing</idx>
    <p>
      The main purpose of methods is to break a program up into smaller chunks
      that are easier to think about. That also often results in removing
      duplicated code which also helps reduce the overall complexity. All other
      things being equal, less code is better than more code.
    </p>

    <p>
      For example, the song “Old MacDonald Had a Farm”, like many children’s
      songs, has a lot of repetition. If we wanted to write a program to print
      out the song’s lyrics, we could write out a bunch of calls to
      <c>println</c> as shown below. But then our code would have a lot of
      duplicate code—the same lines of code occurring in multiple places. See if
      you can identify the duplicate code in the following implementation of
      such a program.
    </p>

    <activity>
      <title>Finding duplicate code</title>
      <statement>
        <p>
          Click on all the lines that are exactly the same as another line.
        </p>
      </statement>

      <feedback>
        <p>Look for lines that are completely identical.</p>
      </feedback>

      <areas>
        <cline><area correct="no">public static void main(String args[]) {</area></cline>
        <cline>    <area correct="yes">System.out.println("Old MacDonald had a farm.");</area></cline>
        <cline>    <area correct="yes">System.out.println("E-I-E-I-O");</area></cline>
        <cline>    <area correct="no">System.out.println("And on this farm, they had a cow.");</area></cline>
        <cline>    <area correct="yes">System.out.println("E-I-E-I-O");</area></cline>
        <cline>    <area correct="no">System.out.println("With a moo moo here and a moo moo there");</area></cline>
        <cline>    <area correct="no">System.out.println("Here a moo, there a moo, everywhere a moo moo");</area></cline>
        <cline>    <area correct="yes">System.out.println("Old MacDonald had a farm");</area></cline>
        <cline>    <area correct="yes">System.out.println("E-I-E-I-O");</area></cline>
        <cline><area correct="no">}</area></cline>
      </areas>
    </activity>

    <p>
      Did you find some repeated lines? You may have noticed that the first two
      lines are repeated. When you see repeated code, that is a signal for you
      to make a new method!
    </p>

    <p>
      The code tracing activity below shows how a song can be divided up into methods.
      Click on the next button below the code to step through the code and watch
      the red arrow jump to the method that is being run.
    </p>
    <p>
      Execution in Java always begins in the <c>main</c> method in the current
      class. Then, the <term>flow of control</term> skips from method to method
      as they are called. Notice that when a method ends, it returns to where
      the method was called. The <c>main</c> method below calls the <c>intro</c>
      method which prints a line and then calls the <c>chorus</c> method. The
      code in <c>chorus</c> prints one line and then returns back to
      <c>intro</c> which is then done so it returns to <c>main</c> which then
      executes the next line.
    </p>

    <activity>
      <title>Old MacDonald with methods</title>
      <statement>
        <p>
          Click on the next button below the code to step through the code and
          watch the red arrow jump to the method that is being run.
        </p>
      </statement>

      <program interactive="codelens" language="java" label="codelensSong1" xml:id="codelensSong1">
        <code>
          public class OldMacDonaldSong {
            public static void intro() {
              System.out.println("Old MacDonald had a farm");
              chorus();
            }

            public static void chorus() {
              System.out.println("E-I-E-I-O");
            }

            public static void main(String[] args) {
              intro();
              System.out.println("And on that farm they had a cow.");
              chorus();
              System.out.println("With a moo moo here and a moo moo there");
              System.out.println("Here a moo, there a moo, everywhere a moo moo");
              intro();
            }
          }
        </code>
      </program>
    </activity>

    <p>
      Just like variable names, method names should be chosen to be meaningful
      and describe what the method does. Methods can be defined in any order,
      but usually programmers put the <c>main</c> method at the end the class
      after all the methods that it uses are defined.
    </p>

    <p>
      Try writing your own method calls below to add another verse to the song.
    </p>

    <activity label="song-add-calls">
      <title>Expand song</title>
      <statement>
        <p>
          Scroll down to the main method below and add lines of code to the main
          method for the second verse of the Old MacDonald Song by calling the
          intro() and chorus() methods and printing out lines about a duck or
          another animal.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
          public class OldMacDonaldSong {
              public static void intro() {
                  System.out.println("Old MacDonald had a farm");
                  chorus();
              }

              public static void chorus() {
                  System.out.println("E-I-E-I-O");
              }

              public static void main(String[] args) {
                  intro();
                  System.out.println("And on that farm they had a cow.");
                  chorus();
                  System.out.println("With a moo moo here and a moo moo there");
                  System.out.println("Here a moo, there a moo, everywhere a moo moo");

                  // TODO:
                  // 1. Call the method intro()

                  // 2. Print out the line "And on that farm..."
                  //    with a duck or another animal

                  // 3. Call the method chorus

                  // 4. Print out the lines with the appropriate animal sounds

                  // 5. Call the method intro again

              }
          }
        </code>
        <tests>
import static org.junit.Assert.*;
import org.junit.*;
import java.io.*;
public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void test1()
    {
        String code = getCode();
        int num = countOccurences(code, "intro();");

        boolean passed = num &gt;= 3;

        passed = getResults("3 or more", "" + num, "Calls to intro()", passed);
        assertTrue(passed);
    }
    @Test
    public void test2()
    {
        String code = getCode();
        int num = countOccurences(code, "chorus();");

        boolean passed = num &gt;= 3;

        passed = getResults("3 or more", "" + num, "Calls to chorus()", passed);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>

    <activity label="songMethodsTrace">
      <title>Mental execution</title>
      <statement>
        <p>What does the following code print out?</p>
        <program language="java">
          <code>
public class Song
{
    public static void print()
    {
        System.out.print("I like to ");
        eat();
        eat();
        eat();
        fruit();
    }

    public static void fruit()
    {
        System.out.println("apples and bananas!");
    }

    public static void eat()
    {
        System.out.print("eat ");
    }

    public static void main(String[] args)
    {
        print();
    }
}
          </code>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>I like to eat eat eat.</p>
          </statement>

          <feedback>
            <p>
              Try tracing through the print method and see what happens when it
              calls the other methods.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>I like to eat eat eat fruit.</p>
          </statement>

          <feedback>
            <p>
              There is a fruit() method but it does not print out the word
              fruit.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>I like to apples and bananas eat.</p>
          </statement>

          <feedback>
            <p>
              The order things are printed out depends on the order in which
              they are called from the print method.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>I like to eat eat eat apples and bananas!</p>
          </statement>

          <feedback>
            <p>
              Yes, the print method calls the eat method 3 times and then the
              fruit method to print this.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Nothing, it does not compile.</p>
          </statement>

          <feedback>
            <p>Try the code in an active code window to see that it does work.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <p>
      Try this <url
      href="https://pythontutor.com/render.html#code=public%20class%20Song%20%7B%0A%20%20%0A%20%20%20%20%20%20%20%20public%20static%20void%20print%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20System.out.print%28%22I%20like%20to%20%22%29%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20eat%28%29%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20eat%28%29%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20eat%28%29%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20fruit%28%29%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20public%20static%20void%20fruit%28%29%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20System.out.println%28%22apples%20and%20bananas!%22%29%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20public%20static%20void%20eat%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20System.out.print%28%22eat%20%22%29%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20print%28%29%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D&amp;cumulative=false&amp;curInstr=15&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">visualization</url>
      to see this code in action. Figuring out what the code does is called
      <term>code tracing</term> or <term>mental execution</term>. You can do
      this by hand or use a tool like the one above to help you see what happens
      when the code runs.
    </p>
  </subsection>





  <subsection>
    <title>Removing even more duplication</title>
    <p>
      Let’s take another look at the Old MacDonald Song and see if we can
      replace more repeated code with methods with parameters. Each verse of the
      song is similar except it is about a different animal and the sound it
      makes. Click on the words that are different in the lines that are
      repeated to discover what parameters we need to add to the methods.
    </p>

    <activity label="different-code-old-mcdonald">
      <title>Duplication with small differences</title>
      <statement>
        <p>
          Click on the specific words that are different in the lines that are
          otherwise the same as some other line.
        </p>
      </statement>

      <feedback>
        <p>
          Look for lines that are similar except for a single word and click on
          that word.
        </p>
      </feedback>

      <areas>
        <cline><area correct="no">public class OldMacDonaldSong {</area></cline>
        <cline>  <area correct="no">public static void intro() {</area></cline>
        <cline>    <area correct="no">System.out.println("Old MacDonald had a farm");</area></cline>
        <cline>    <area correct="no">chorus();</area></cline>
        <cline>  <area correct="no">}</area></cline>
        <cline></cline>
        <cline>  <area correct="no">public static void chorus() {</area></cline>
        <cline>    <area correct="no">System.out.println("E-I-E-I-O");</area></cline>
        <cline>  <area correct="no">}</area></cline>
        <cline></cline>
        <cline>  <area correct="no">public static void main(String[] args) {</area></cline>
        <cline>    <area correct="no">intro();</area></cline>
        <cline>    <area correct="no">System.out.println("And on that farm they had a</area> <area correct="yes">cow</area><area correct="no">.");</area></cline>
        <cline>    <area correct="no">chorus();</area></cline>
        <cline>    <area correct="no">System.out.println("With a</area> <area correct="yes">moo moo</area> <area correct="no">here and a</area> <area correct="yes">moo moo</area> <area correct="no"> there");</area></cline>
        <cline>    <area correct="no">System.out.println("Here a</area> <area correct="yes">moo</area><area correct="no">, there a</area> <area correct="yes">moo</area><area correct="no">, everywhere a</area> <area correct="yes">moo moo</area><area correct="no">");</area></cline>
        <cline>    <area correct="no">intro();</area></cline>
        <cline>    <area correct="no">System.out.println("And on that farm they had a</area> <area correct="yes">duck</area><area correct="no">.");</area></cline>
        <cline>    <area correct="no">chorus();</area></cline>
        <cline>    <area correct="no">System.out.println("With a</area> <area correct="yes">quack quack</area> <area correct="no">here and a</area> <area correct="yes">quack quack</area> <area correct="no"> there");</area></cline>
        <cline>    <area correct="no">System.out.println("Here a</area> <area correct="yes">quack</area><area correct="no">, there a</area> <area correct="yes">quack</area><area correct="no">, everywhere a</area> <area correct="yes">quack quack</area><area correct="no">");</area></cline>
        <cline>    <area correct="no">intro();</area></cline>
        <cline>  <area correct="no">}</area></cline>
        <cline><area correct="no">}</area></cline>
      </areas>
  </activity>

    <p>
      Did you notice that there are lines that are identical except for the
      animal name and the sound that they make?
    </p>

    <p>
      We can make methods even more powerful and more abstract by giving them
      parameters for data that they need to do their job. A
      <term>parameter</term> (sometimes called a <term>formal parameter</term>)
      is a variable declared in the header of a method or constructor and can be
      used inside the body of the method. This allows values or arguments to be
      passed and used by a method. An <term>argument</term> (sometimes called an
      <term>actual parameter</term>) is a value that is passed into a method
      when the method is called and is saved in the parameter variable.
    </p>

    <p>
      We can make a method called <c>verse</c> that takes the animal and its
      sound to print out any verse! The parameter variables <c>animal</c> and
      <c>sound</c> will hold different values when the method is called.
    </p>

    <program language="java">
      <code>
/* This method prints out a verse for any given animal and sound.
   @param animal - the name of the animal
   @param sound - the sound the animal makes
*/
public static void verse(String animal, String sound)
{
    System.out.println("And on this farm, they had a " + animal);
    chorus();
    System.out.println("With a " + sound + " " + sound
                   + " here and a " + sound + " " + sound + " there");
    System.out.println("Here a " + sound
                   + ", there a " + sound
                   + ", everywhere a " + sound + " " + sound);
}
      </code>
    </program>

    <p>
      And the main method can now just consist of calls to the intro() and
      verse() methods. Main methods often look like an outline for the program,
      calling methods to do the work.
    </p>

    <program language="java">
      <code>
public static void main(String[] args)
{
    intro();
    verse("cow", "moo");
    intro();
    verse("duck", "quack");
    intro();
}
      </code>
    </program>

    <p>
      Click on the next button below to step through this new version of the
      code in the <url
      href="https://pythontutor.com/render.html#code=%20%20%20%20public%20class%20OldMacDonaldSong%0A%20%20%20%20%7B%0A%20%20%20%20%20%20public%20static%20void%20intro%28%29%0A%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20System.out.println%28%22Old%20MacDonald%20had%20a%20farm%22%29%3B%0A%20%20%20%20%20%20%20%20chorus%28%29%3B%0A%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20public%20static%20void%20chorus%28%29%0A%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20System.out.println%28%22E-I-E-I-O%22%29%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%0A%20%20%20%20%20%20public%20static%20void%20verse%28String%20animal,%20String%20sound%29%0A%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20System.out.println%28%22And%20on%20this%20farm,%20they%20had%20a%20%22%20%2B%20animal%29%3B%0A%20%20%20%20%20%20%20%20chorus%28%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22With%20a%20%22%20%2B%20sound%20%2B%20%22%20%22%20%2B%20sound%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2B%20%22%20here%20and%20a%20%22%20%2B%20sound%20%2B%20%22%20%22%20%2B%20sound%20%2B%20%22%20there%22%29%3B%0A%20%20%20%20%20%20%20%20System.out.println%28%22Here%20a%20%22%20%2B%20sound%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2B%20%22,%20there%20a%20%22%20%2B%20sound%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2B%20%22,%20everywhere%20a%20%22%20%2B%20sound%20%2B%20%22%20%22%20%2B%20sound%29%3B%0A%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20intro%28%29%3B%0A%20%20%20%20%20%20%20%20verse%28%22cow%22,%20%22moo%22%29%3B%0A%20%20%20%20%20%20%20%20intro%28%29%3B%0A%20%20%20%20%20%20%20%20verse%28%22duck%22,%20%22quack%22%29%3B%0A%20%20%20%20%20%20%20%20intro%28%29%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D&amp;cumulative=false&amp;curInstr=34&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">Java
      visualizer</url> and watch how the argument are saved in the parameter
      variables with each call to the <c>verse</c> method.
    </p>

    <activity>
      <statement>
        <p>
          Click on the next button below the code to step through the code and
          watch the red arrow jump to the method that is being run and watch how
          the arguments are passed into the parameter variables.
        </p>
      </statement>

      <program interactive="codelens" language="java" label="codelensSong2" xml:id="codelensSong2">
        <code>
public class OldMacDonaldSong
{
  public static void intro()
  {
    System.out.println("Old MacDonald had a farm");
    chorus();
  }

  public static void chorus()
  {
    System.out.println("E-I-E-I-O");
  }

  public static void verse(String animal, String sound)
  {
    System.out.println("And on this farm, they had a " + animal);
    chorus();
    System.out.println("With a " + sound + " " + sound
                   + " here and a " + sound + " " + sound + " there");
    System.out.println("Here a " + sound
                   + ", there a " + sound
                   + ", everywhere a " + sound + " " + sound);
  }

  public static void main(String[] args)
  {
    intro();
    verse("cow", "moo");
    intro();
    verse("duck", "quack");
    intro();
  }
}
        </code>
      </program>
    </activity>

    <p>
      Let’s try adding another verse to the song with a goose that honks.
    </p>

    <activity label="OldMacDonaldSong2">
      <statement>
        <p>
          Run the following code to see the song Old MacDonald using the verse
          and chorus methods. You can also see this code run in the visualizer
          by clicking on the Show Code Lens button below. Scroll down to the
          main method, and add another verse with the animal goose and the sound
          honk by calling the verse method with the appropriate arguments. Then
          call intro again. Repeat with another animal and sound of your choice.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class OldMacDonaldSong
{
    public static void intro()
    {
        System.out.println("Old MacDonald had a farm");
        chorus();
    }

    public static void chorus()
    {
        System.out.println("E-I-E-I-O");
    }

    public static void verse(String animal, String sound)
    {
        System.out.println("And on this farm, they had a " + animal);
        chorus();
        System.out.println("With a " + sound + " " + sound
                     + " here and a " + sound + " " + sound + " there");
        System.out.println("Here a " + sound
                     + ", there a " + sound
                     + ", everywhere a " + sound + " " + sound);
    }

    public static void main(String[] args)
    {
        intro();
        verse("cow","moo");
        intro();
        verse("duck","quack");
        intro();
        // TODO:
        // Call verse again with goose and honk
        //   and then call intro again


        // Call verse again with another animal and sound
        //  and then call intro again


     }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testThree()
    {
        boolean passed = checkCodeContains("verse with goose and honk", "verse(\"goose\", \"honk\");");
        assertTrue(passed);
    }
    @Test
    public void test1()
    {
        String code = getCode();
        int num = countOccurences(code, "intro();");

        boolean passed = num &gt;= 5;

        passed = getResults("5 or more", "" + num, "Calls to intro", passed);
        assertTrue(passed);
    }
}
        </tests>
      </program>
    </activity>

    <p>
      When a method is called, the right method definition is found by checking
      the <term>method signature</term> or <term>header</term> at the top of the
      method definition to match the method name, the number of arguments, the
      data types for the arguments and the return type. A method signature for a
      method with parameters consists of the method name and the ordered list of
      parameter types. A method signature for a method without parameters
      consists of the method name and an empty parameter list.
    </p>

    <p>
      Here’s what that looks like with the two method calls above. The arguments
      like “cow” and “moo” are saved into the parameter variables <c>animal</c>
      and <c>sound</c> with each method call.
    </p>

    <figure align="center">
      <caption>Matching Arguments to Parameters</caption>
      <image source="Unit1-Using-Objects-and-Methods/Figures/args2paramsFarm.png" width="89%" alt="Arguments to Parameters" />
    </figure>

    <p>
      The method headers contain data types of the parameters because they are
      variable declarations that reserve memory for the parameter variables.
      However, the method calls never contain the parameter types, only the
      values that are passed to the method. The argument values can be
      variables, literals, or expressions that evaluate to the correct data
      type.
    </p>

    <program language="java">
      <code>
// Method headers contain data types for the parameters
public static void verse(String animal, String sound)
{   /* Implementation not shown */
}

// Method calls contain only values for the parameters
verse("cow", "moo");
      </code>
    </program>

    <p>
      Java uses <term>call by value</term> when it passes arguments to methods.
      This means that a copy of the value in the argument is saved in the
      parameter variable. Call by value initializes the parameters with copies
      of the arguments. If the parameter variable changes its value inside the
      method, the original value outside the method is not changed.
    </p>
  </subsection>





  <subsection>
    <title>Overloading</title>
    <idx>overloading</idx>
    <p>
      Methods are said to be <term>overloaded</term> when there are multiple
      methods with the same name but different signatures with a different
      number or types of parameters. For example, the <c>println()</c> method in
      the <url
      href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/io/PrintStream.html"><c>PrintStream</c>
      class</url> is overloaded with different parameter types. The method
      <c>println()</c> with no parameters prints a newline, the method
      <c>println(String x)</c> prints the given string followed by a newline,
      the method <c>println(int x)</c> prints the given int number followed by a
      newline, etc. The compiler determines which method to call based on the
      number and types of arguments passed to the method.
    </p>
  </subsection>

  <subsection>
    <title>Coding Challenge: Song with Parameters</title>
    <p>
      Here’s another song, <url href="https://youtu.be/QPwEZ8Vv2YQ"
      visual="https://youtu.be/QPwEZ8Vv2YQ">The Ants Go Marching</url>, that is
      very similar in its repetitive structure. The verses below have a lot of
      repeated words and phrases. Click on the words or phrases that are
      different in each verse. These will be the arguments that you will pass to
      the methods in your song code.
    </p>

    <activity label="clickDifferentAntSong">
      <statement>
        <p>Click on the phrases that are different in each verse.</p>
      </statement>

      <feedback>
        <p>Look for words that are different in verse 1, 2, and 3.</p>
      </feedback>

      <areas>
        <cline><area correct="no">The ants go marching </area> <area correct="yes"> one by one</area><area correct="no">, hurrah, hurrah</area></cline>
        <cline><area correct="no">The ants go marching </area> <area correct="yes"> one by one</area><area correct="no">, hurrah, hurrah</area></cline>
        <cline><area correct="no">The ants go marching </area> <area correct="yes"> one by one</area></cline>
        <cline><area correct="no">The little one stops to </area> <area correct="yes"> suck a thumb</area></cline>
        <cline><area correct="no">And they all go marching down to the ground</area></cline>
        <cline><area correct="no">To get out of the rain, BOOM! BOOM! BOOM! BOOM!</area></cline>
        <cline></cline>
        <cline><area correct="no">The ants go marching </area> <area correct="yes"> two by two</area><area correct="no">, hurrah, hurrah</area></cline>
        <cline><area correct="no">The ants go marching </area> <area correct="yes"> two by two</area><area correct="no">, hurrah, hurrah</area></cline>
        <cline><area correct="no">The ants go marching </area> <area correct="yes"> two by two</area></cline>
        <cline><area correct="no">The little one stops to </area> <area correct="yes"> tie a shoe</area></cline>
        <cline><area correct="no">And they all go marching down to the ground</area></cline>
        <cline><area correct="no">To get out of the rain, BOOM! BOOM! BOOM! BOOM!</area></cline>
        <cline></cline>
        <cline><area correct="no">The ants go marching </area> <area correct="yes"> three by three</area><area correct="no">, hurrah, hurrah</area></cline>
        <cline><area correct="no">The ants go marching </area> <area correct="yes"> three by three</area><area correct="no">, hurrah, hurrah</area></cline>
        <cline><area correct="no">The ants go marching </area> <area correct="yes"> three by three</area></cline>
        <cline><area correct="no">The little one stops to </area> <area correct="yes"> climb a tree</area></cline>
        <cline><area correct="no">And they all go marching down to the ground</area></cline>
        <cline><area correct="no">To get out of the rain, BOOM! BOOM! BOOM! BOOM!</area></cline>
      </areas>
    </activity>

    <project label="challenge-1-9-song">
      <statement>
        <p>
          Write code in the main method that calls the verse method to print out
          all three verses for the Ants Go Marching song above.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class AntsSong
{
    public static void chorus(String num)
    {
        System.out.println("The ants go marching " + num
                         + " by " + num + " hurrah, hurrah");
        System.out.println("The ants go marching " + num
                         + " by " + num + " hurrah, hurrah");
    }

    public static void verse(String num, String action)
    {
        System.out.println("The ants go marching " + num + " by " + num);
        System.out.println("The little one stops to " + action);
        System.out.println("And they all go marching down to the ground");
        System.out.println("To get out of the rain, BOOM! BOOM! BOOM! BOOM!\n");
    }

    public static void main(String args[])
    {
        // Call the chorus and verse methods
        // with the correct arguments
        // to print out all three verses above.



    }
}
        </code>
        <tests>
import static org.junit.Assert.*;
import org.junit.*;
import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void checkCodeContains1()
    {
        String code = getCode();
        int actual = countOccurences(code, "chorus(");
        String expected = "3";

        boolean passed = actual &gt;= 3;
        getResults(
                expected,
                "" + actual,
                "Checking that code contains 3 calls to  chorus",
                passed);
        assertTrue(passed);
    }
    @Test
    public void checkCodeContains2()
    {
        String code = getCode();
        int actual = countOccurences(code, "verse(");
        String expected = "3";

        boolean passed = actual &gt;= 3;
        getResults(
                expected,
                "" + actual,
                "Checking that code contains three calls to verse method",
                passed);
        assertTrue(passed);
    }
    @Test
     public void testMain() throws IOException
     {
         String output = getMethodOutput("main");

         String expect =
            "The ants go marching one by one, hurrah, hurrah\n"
                    + "The ants go marching one by one, hurrah, hurrah\n"
                    + "The ants go marching one by one\n"
                    + "The little one stops to suck a thumb\n"
                    + "And they all go marching down to the ground\n"
                    + "To get out of the rain, BOOM! BOOM! BOOM! BOOM!\n"
                    + "\n"
                    + "The ants go marching two by two, hurrah, hurrah\n"
                    + "The ants go marching two by two, hurrah, hurrah\n"
                    + "The ants go marching two by two\n"
                    + "The little one stops to tie a shoe\n"
                    + "And they all go marching down to the ground\n"
                    + "To get out of the rain, BOOM! BOOM! BOOM! BOOM!\n"
                    + "\n"
                    + "The ants go marching three by three, hurrah, hurrah\n"
                    + "The ants go marching three by three, hurrah, hurrah\n"
                    + "The ants go marching three by three\n"
                    + "The little one stops to climb a tree\n"
                    + "And they all go marching down to the ground\n"
                    + "To get out of the rain, BOOM! BOOM! BOOM! BOOM!";

               boolean passed =
               getResults(expect, output, "Expected output from main");
               assertTrue(passed);
         }

}
        </tests>
      </program>
    </project>
  </subsection>

  <subsection>
    <title>Summary</title>
    <activity label="vocab1_9">
      <statement>
        <p>
          Drag the definition from the left and drop it on the correct concept
          on the right. Click the "Check Me" button to see if you are correct.
        </p>
      </statement>

      <feedback>
        <p>Review the summary below.</p>
      </feedback>

      <cardsort>
        <match>
          <premise order="1">named block of code to perform a task</premise>
          <response>method</response>
        </match>

        <match>
          <premise order="2">where execution starts</premise>
          <response>main method</response>
        </match>

        <match>
          <premise order="3">method name and parameter list</premise>
          <response>method signature</response>
        </match>

        <match>
          <premise order="4">a variable declared in the header of a method</premise>
          <response>parameter</response>
        </match>

        <match>
          <premise order="5">value passed into a method when it is called</premise>
          <response>argument</response>
        </match>
      </cardsort>
    </activity>

    <p>
      <ul>
        <li>
          <p>
            (AP 1.9.A.1) A <term>method</term> is a named block of code that
            only runs when it is called. A block of code is any section of code
            that is enclosed in braces.
          </p>
        </li>

        <li>
          <p>
            (AP 1.9.A.1) <term>Procedural abstraction</term> allows a programmer
            to use a method by knowing what the method does even if they do not
            know how the method was written.
          </p>
        </li>

        <li>
          <p>
            (AP 1.9.B.5) A method call interrupts the sequential execution of
            statements, causing the program to first execute the statements in
            the method before continuing. Once the last statement in the method
            has been executed or a return statement is executed, the flow of
            control is returned to the point immediately following where the
            method was called.
          </p>
        </li>

        <li>
          <p>
            (AP 1.9.A.2) A <term>parameter</term> is a variable declared in the
            header of a method or constructor and can be used inside the body of
            the method. This allows values or arguments to be passed and used by
            a method or constructor.
          </p>
        </li>

        <li>
          <p>
            (AP 1.9.A.2) A <term>method signature</term> for a method with
            parameters consists of the method name and the ordered list of
            parameter types. A method signature for a method without parameters
            consists of the method name and an empty parameter list.
          </p>
        </li>

        <li>
          <p>
            (AP 1.9.B.3) An <term>argument</term> is a value that is passed into
            a method when the method is called. The arguments passed to a method
            must be compatible in number and order with the types identified in
            the parameter list of the method signature. When calling methods,
            arguments are passed using call by value.
          </p>
        </li>

        <li>
          <p>
            (AP 1.9.B.3) <term>Call by value</term> initializes the parameters
            with copies of the arguments.
          </p>
        </li>

        <li>
          <p>
            (AP 1.9.B.4) Methods are said to be <term>overloaded</term> when
            there are multiple methods with the same name but different
            signatures.
          </p>
        </li>
      </ul>
    </p>
  </subsection>

  <subsection>
    <title>AP Practice</title>
    <activity label="AP-trace-method-calls">
      <statement>
        <p>Consider the following class definition.</p>
        <program language="java">
          <code>
public class Cat
{
    public static void sound1()
    {
        System.out.print("meow ");
    }

    public static void sound2()
    {
        System.out.print("purr ");
    }

    public static void hello()
    {
        sound2();
        sound1();
    }
}
          </code>
        </program>

        <p>
          Which of the following code segments, if located in a method inside
          the Cat class, will cause the message “purr meow purr” to be printed?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP-trace-method-calls_opt_a">
            <program language="java">
              <code>
hello();
              </code>
            </program>
          </statement>

          <feedback id="AP-trace-method-calls_opt_a">
            <p>This would print “purr meow “</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP-trace-method-calls_opt_b">
            <program language="java">
              <code>
hello();
sound2();
              </code>
            </program>
          </statement>

          <feedback id="AP-trace-method-calls_opt_b">
            <p>Correct!</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-trace-method-calls_opt_c">
            <program language="java">
              <code>
sound1()
sound2();
sound1();
              </code>
            </program>
          </statement>

          <feedback id="AP-trace-method-calls_opt_c">
            <p>
              This would print out “meow purr meow” instead of “purr meow purr”.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-trace-method-calls_opt_d">
            <program language="java">
              <code>
purr();
meow();
purr()
              </code>
            </program>
          </statement>

          <feedback id="AP-trace-method-calls_opt_d">
            <p>
              This would cause a syntax error since those are not the names of
              the methods.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="progresscheck-u1-part2">
    <title>AP Classroom Progress Check Unit 1 Part 2</title>
    <p>
      This lesson ends the section for the College Board Unit 1 part 2. You can
      now do the College Board Progress Check for Unit 1 Part 1 in the AP
      Classroom.
    </p>
  </subsection>
</section>
