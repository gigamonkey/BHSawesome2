<?xml version="1.0" encoding="utf-8"?>

<scratch>
  <p>
    Remember that a <term>class</term> in Java defines a blueprint for creating
    objects. When you create <term>objects</term>, you create new
    <term>instances</term> of that class and what you can do with those
    instances is determined by what methods are defined in the class.
  </p>

  <p>
    You can create instances of the <c>Person</c> class with <c>new</c> as in
    <c>new Person()</c> And you can declare variables that can hold a reference
    to a <c>Person</c> object with <c>Person variableName</c>. Or put it
    altogether to declare some variables and initialize each one with a
    reference to a new <c>Person</c> as shown here.
  </p>

  <program>
    Person ada = new Person();
    Person charles = new Person();
  </program>

  <p>
    The real meat of a class is in the <term>methods</term> which define the
    behaviors of the objects of that class. Remember that most methods either do
    things (like the <c>Turtle</c> methods that moved the turtle on the screen)
    or return values like the <c>getXPos</c> and <c>getYPos</c> on
    <c>Turtle</c>. The methods of the class share access to the object’s
    instance variables and when a method is called on an object it uses the
    instance variables for that object. For example in the <c>Turtle</c> class
    the <c>forward</c> method changes an instance variable <c>xPos</c>. When you
    call <c>forward</c> on <c>yertle</c> it changes <c>xPos</c> on the
    <c>yertle</c> object and when you call it on <c>myrtle</c> it changes the
    <c>xPos</c> on the <c>myrtle</c> object.
  </p>

  <p>
    Putting it all together, the three main anatomical features of a class are
    the <term>instance variables</term> which hold values associated with each
    object, the <term>constructors</term> whose job is to initialize the
    instance variables, and the <term>methods</term> who contain the code that
    gives the objects their behavior and which can use the instance variables
    defined in the class.
  </p>

  <program>
    public class Person {
        // instance variables

        // constructors

        // methods

    }
  </program>

  <p>
    And finally one last bit of weird anatomy, kind of like the human appendix
    which is only sometimes needed: any Java class can have a <c>main</c> method
    which can be used to run that class as a program either to test that one
    class or sometimes as the entry point to a whole program made up of many
    classes and objects.
  </p>

  <subsection xml:id="designing-a-class">
    <title>Designing a Class</title>

    <p>
      Now that we know what the skeleton of a class looks like and the elements
      that make up the body of the class, we’re ready to create our own class.
      Let’s start with a quick look at how to design a class such as
      <c>Person</c>.
    </p>

    <p>
      One important question we have to ask when designing a class is, what data
      does it represent? In this case we can ask, what would we want to know
      about a person? Our answer will depend on what problem we are trying to
      solve. In one program, perhaps an address book, we might want to know the
      person’s name and phone number and email. In another program, such as a
      medical application, we might need to know their vital signs such as their
      blood pressure, temperature, and pulse rate.
    </p>

    <p>
      For now let’s go with the address book example. Here’s a fleshed out
      <c>Person</c> class with instance variables, a constructor, and methods.
      We’ll go through the details in the next few sections but for now you can
      run the code to see how it constructs 2 <c>Person</c> objects and fills in
      their data. Remember that execution always starts in the <c>main</c>
      method. When a method like <c>print</c> is called, the code defined in the
      method runs but when it gets the values of <c>name</c>, <c>email</c>, and
      <c>phoneNumber</c> it gets the specific values of those variables that
      were set by the constructor when the particular object we called
      <c>print</c> on was created. Click on the Show CodeLens button below and
      the Next button to run the code step by step.
    </p>

    <activity label="PersonClass">
      <statement>
        <p>
          The following Person class keeps track of the name, email, and phone
          number of a person. Try changing the Person p2 object in the main
          method to your name. Click on the Show CodeLens button and then Next
          to step through the code.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class Person {
              // instance variables
              private String name;
              private String email;
              private String phoneNumber;

              // constructor: construct a Person copying in the data into the instance
              // variables
              public Person(String initName, String initEmail, String initPhone) {
                  name = initName;
                  email = initEmail;
                  phoneNumber = initPhone;
              }

              // Print all the data for a person
              public void print() {
                  System.out.println("Name: " + name);
                  System.out.println("Email: " + email);
                  System.out.println("Phone Number: " + phoneNumber);
              }

              // main method for testing
              public static void main(String[] args) {
                  // call the constructor to create a new person
                  Person p1 = new Person("Sana", "sana@gmail.com", "123-456-7890");
                  // call p1's print method
                  p1.print();
                  Person p2 = new Person("Jean", "jean@gmail.com", "404 899-9955");
                  p2.print();
              }
          }
        </code>

        <tests>
          // Test for Lesson 5.1.0 - Person class - should pass if/when they run code
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testMain() throws IOException {
                  String output = getMethodOutput("main");
                  String expect =
                          "Name: Sana\n"
                                  + "Email: sana@gmail.com\n"
                                  + "Phone Number: 123-456-7890\n"
                                  + "Name: Jean\n"
                                  + "Email: jean@gmail.com\n"
                                  + "Phone Number: 404 899-9955";

                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="data-encapsulation">
    <title>Data encapsulation</title>

    <p>
      <term>Data encapsulation</term> is an object-oriented design technique in
      which the implementation details of a class are kept hidden from external
      classes. The keywords <c>public</c> and <c>private</c> are called
      <term>access modifiers</term>, and they affect how you can the access
      classes, data, constructors, and methods. The keyword <c>public</c> means
      anyone can access this; it allows access from classes outside the
      declaring class. The keyword <c>private</c> restricts access to the
      declaring class which means that variables or methods marked private are
      only accessible inside the class where they are defined. In general,
      instance variables in a class should be declared <c>private</c> to ensure
      data encapsulation.
    </p>
  </subsection>

  <figure align="center">
    <caption>Person Class and Objects</caption>

    <image source="Unit3-Class-Creation/Figures/PersonClassWithCookies.png" width="100%">
      <shortdescription>Person data encapsulation</shortdescription>
    </image>
  </figure>

  <p>
    Access to attributes should be kept internal to the class in order to
    accomplish encapsulation. It is good programming practice to designate the
    instance variables as <c>private</c> in order to ensure <term>data
    encapsulation</term> where the data (instance variables) and the code acting
    on the data (methods) are wrapped together into a single unit and the
    implementation details are hidden. Only code in the class can access or
    change the values of <c>private</c> instance variables. This keeps the data
    secure and makes it a lot easier to keep track of how your program works
    than if you had to worry that any code anywhere in a much larger program
    could possibly change the values of the variables.
  </p>

  <p>
    Code in other classes can only interact with the <c>public</c> methods you
    provide and cannot directly access the <c>private</c> instance variables
    (shown in the pink box above). When designing a class you get to decide what
    data to make accessible or modifiable from other classes by what
    <c>public</c> methods you provide.
  </p>

  <subsection xml:id="design-a-class-for-your-community">
    <title>Design a Class for your Community</title>

    <p>
      In this unit, you will design a class of your own choice that is relevant
      to your community. You will improve the class in each lesson of this unit.
      We suggest that you work in pairs on this project. If you would rather
      work on this project as 1 stand-alone lab project rather than a piece at a
      time at the end of each lesson, you can do this in this <url
      href="community-challenge.html">lesson</url> at the end of the unit.
    </p>

    <p>
      <ol>
        <li>
          <p>
            Make your own copy of this <url
            href="https://docs.google.com/document/d/11QMyHAZYhPwNLInhURqkTffeY9re05yH97xAsiSJhLg/edit?usp=sharing">worksheet</url>
            from the File menu. For question 1, brainstorm and ask people in
            your community what would be important or useful for them to track
            in a community organization or activity or to help your community.
            For example, you could create a Java class to keep track of
            community events, club activities, athletic games or statistics,
            community leaders, performers or performances, health tracking, or
            another subject of your choice.
          </p>
        </li>

        <li>
          <p>
            Come up with the class name for your community data-tracking class
            (it should be a category of people or things, not a specific person
            or thing). Come up with at least 3 instance variables that are
            attributes of things in that class. Think about what data type each
            variable should be.You can use the <url
            href="https://docs.google.com/document/d/11QMyHAZYhPwNLInhURqkTffeY9re05yH97xAsiSJhLg/edit?usp=sharing">worksheet</url>
            to design your class. Optionally, you may want to draw a UML class
            diagram for your class on paper or using <url
            href="https://app.diagrams.net/">app.diagrams.net</url> or <url
            href="https://creately.com">Creately.com</url> (see <url
            href="https://medium.com/@smagid_allThings/uml-class-diagrams-tutorial-step-by-step-520fd83b300b">tutorial
            on class diagrams</url>).
          </p>
        </li>

        <li>
          <p>
            Type in your class name and declare the instance variables for your
            class in the active code exercise below. Click on run. Your class
            will not print out anything yet, but it should run without errors.
            You will add constructors and other methods to this class in the
            next lessons.
          </p>
        </li>
      </ol>
    </p>

    <project label="community-challenge1">
      <statement>
        <p>
          Come up with the class name for your community data-tracking class (it
          should be a category of people or things, not a specific person or
          thing) and at least 3 instance variables that are attributes of things
          in that class. Your class will not print out anything yet, but it
          should run without errors.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class          // Add your class name here!
          {
              // write 3 instance variables for class: private type variableName;



              public static void main(String[] args)
              {
                // Run your code to check for errors.
                // It will not print anything yet.
                // You will add more in the next lesson.
              }
          }
        </code>

        <tests>
          <![CDATA[

          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void testPrivateVariables() {
                  String expect = "3 Private";
                  String output = testPrivateInstanceVariables();
                  boolean passed = false;
                  if (Integer.parseInt(expect.substring(0, 1)) <= Integer.parseInt(output.substring(0, 1)))
                      passed = true;
                  passed = getResults(expect, output, "Checking private instance variable(s)", passed);
                  assertTrue(passed);
              }
          }

          ]]>
        </tests>
      </program>
    </project>
  </subsection>

  <subsection xml:id="class-hierarchy-and-inheritance">
    <title>Class Hierarchy and Inheritance</title>

    <idx>inheritance</idx>
    <idx>superclass</idx>
    <idx>subclass</idx>
    <idx>Object</idx>
    <p>
      Another important concept in object-oriented programming is
      <term>inheritance</term>. Although the AP CSA exam no longer covers
      inheritance, you should know what it means. <term>Inheritance</term> is a
      way to create a new class that is based on an existing class. The new
      class, called a <term>subclass</term>, inherits the attributes and
      behaviors of the existing class, called a <term>superclass</term>. In
      Java, all classes are subclasses of a superclass called
      <term>Object</term>.
    </p>

    <p>
      For example, you could have a superclass called <c>Pet</c> with attributes
      like <c>name</c> and <c>age</c> and behaviors like <c>eat</c> and
      <c>sleep</c>. You could then have subclasses like <c>Dog</c> and
      <c>Cat</c> and <c>Turtle</c> that inherit the attributes and behaviors of
      the <c>Pet</c> class. Each subclass could add attributes and behaviors
      specific to that type of pet. For example, a <c>Dog</c> subclass could
      have an attribute called <c>breed</c> and a behavior called <c>bark</c>.
    </p>

    <figure align="center">
      <caption>
        Inheritance hierarchy for Pet superclass with the subclasses Dog, Cat,
        and Turtle
      </caption>

      <image source="Unit1-Using-Objects-and-Methods/Figures/inheritance-hierarchy-pet.png" width="89%" />
    </figure>
  </subsection>

  <p>
    You can also think of a class as defining a new data type. In this lesson,
    we will use the class <c>Turtle</c> to make animated turtle objects. Just
    like you use <c>int</c> to declare variables that hold numbers, you can use
    <c>Turtle</c> to declare many variables, animated turtle objects, who are
    <term>instances</term> of the <c>Turtle</c> class.
  </p>

  <program>
    // Creating 2 Turtle objects called yertle and myrtle
    Turtle yertle;
    Turtle myrtle;
  </program>

  <activity label="cats">
    <statement>
      <p>
        Discuss with your class: What are some attributes of cats? What are some
        behaviors of cats? (Note that attributes are often nouns or adjectives
        describing features of cats, and behaviors are often verbs).
      </p>
    </statement>

    <response />
  </activity>

  <introduction>
    <p>
      Within an instance method or a constructor, the keyword <c>this</c> acts
      as a special variable that holds a reference to the current object—the
      object whose method or constructor is being called.
    </p>

    <p>
      For example, in the following Class Person, when we create an object p1
      and call the constructor or p1.setEmail(), the word “this” refers to p1.
      And when we make the same method calls with object p2, “this” refers to
      p2. Run the code below and also check it out in the Java visualizer with
      the Show CodeLens button which shows how this refers to different objects
      when the code is run.
    </p>

    <p>
      The <c>this</c> variable can only be used in instance methods and
      constructors. Class methods cannot refer to <c>this</c> or instance
      variables because they are called with the classname, not an object, so
      there is no <c>this</c> object.
    </p>
  </introduction>

  <activity label="PersonClassThis">
    <statement>
      <p>
        Observe the use of the keyword this in the code below. Click on the
        CodeLens button and then forward to see the memory in action.
      </p>
    </statement>

    <program interactive="activecode">
      <code>
        public class Person {
            // instance variables
            private String name;
            private String email;
            private String phoneNumber;

            // constructor
            public Person(String name) {
                this.name = name;
            }

            // accessor methods - getters
            public String getName() {
                return this.name;
            }

            public String getEmail() {
                return this.email;
            }

            public String getPhoneNumber() {
                return this.phoneNumber;
            }

            // mutator methods - setters
            public void setName(String name) {
                this.name = name;
            }

            public void setEmail(String email) {
                this.email = email;
            }

            public void setPhoneNumber(String phoneNumber) {
                this.phoneNumber = phoneNumber;
            }

            public String toString() {
                return this.name + " " + this.email + " " + this.phoneNumber;
            }

            // main method for testing
            public static void main(String[] args) {
                Person p1 = new Person("Sana");
                System.out.println(p1);
                Person p2 = new Person("Jean");
                p2.setEmail("jean@gmail.com");
                p2.setPhoneNumber("404 899-9955");
                System.out.println(p2);
            }
        }
      </code>

      <tests>
        import static org.junit.Assert.*;

        import org.junit.*;

        import java.io.*;

        public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
                super("Person");
            }

            @Test
            public void testMain() throws IOException {
                String output = getMethodOutput("main");
                String expect = "Sana null null\nJean jean@gmail.com 404 899-9955";

                boolean passed = getResults(expect, output, "Expected output from main", true);
                assertTrue(passed);
            }
        }
      </tests>
    </program>
  </activity>

  <subsection xml:id="this-instancevariable">
    <title><c>this</c>.instanceVariable</title>

    <p>
      The keyword this is sometimes used by programmers to distinguish between
      variables. Programmers can give the parameter variables the same names as
      the instance variables and this can distinguish them and avoid a naming
      conflict. For example, both the instance variable and the parameter
      variable are called name in the code below, but <c>name</c> on its own
      looks for the closest local variable, the parameter variable, whereas
      <c>this.name</c> refers to this object's instance variable.
    </p>

    <note>
      <p>
        <c>this.instanceVariable</c> can be used to distinguish between this
        object’s instance variables and local parameter variables that may have
        the same variable names.
      </p>
    </note>

    <program>
      // instance variables
      private String name;

      // constructor
      public Person(String name)
      {
         // Set this object's instance variable name to the parameter variable name
         this.name = name;
      }
    </program>
  </subsection>

  <subsection>
    <title>Old constructors intro</title>

    <idx><h>class</h><h>constructor</h></idx>
    <idx>constructors</idx>
    <idx>new</idx>
    <p>
      A Java class defines what objects of the class know (attributes) and what
      they can do (behaviors). Each class has <term>constructors</term> which
      are used to initialize the attributes in a newly created object.
      <term>Constructors</term> have the same name as the class.
    </p>

    <p>
      A new object is created with the <c>new</c> keyword followed by the class
      name which is a call to the constructor (<c>new ClassName()</c>). For
      example, <c>new World()</c> creates and initializes a new object of the
      <c>World</c> class, and <c>new Turtle(habitat)</c> creates and initializes
      a new <c>Turtle</c> object in the World habitat. The new object is saved
      in a variable of a <term>reference type</term> which holds an object
      reference or <c>null</c> if there is no object.
    </p>

    <program>
      // To create a new object and call a constructor write:
      // ClassName variableName = new ClassName(arguments);
      World habitat = new World();    // create a new World object
      Turtle t = new Turtle(habitat); // create a new Turtle object
    </program>
  </subsection>

  <subsection xml:id="instance-methods">
    <title>Writing methods</title>

    <idx><h>class</h><h>method</h></idx>
    <p>
      But that also means we can only call instance methods if we have an
      instance of the class to call them on. We’ve used instance methods
      previously such as the <c>indexOf</c> and <c>substring</c> methods on the
      <c>String</c> class.
    </p>

    <p>
      Up until now we’ve written methods marked with <c>static</c> which like
      <c>Math.random()</c> which were called with the classname. Instance
      methods are not marked static and are always called using an object of the
      class and can access the object’s instance variables.
    </p>

    <p>
      Methods are defined in the class after the instance variables and
      constructors. They are usually marked as <c>public</c> so they can be
      accessed from inside or outside the class. Methods designated as
      <c>private</c> are not accessible outside of the class; they can only be
      used as helper methods by other methods inside the same class.
    </p>

    <p>
      The <c>Person</c> class above has a <c>print</c> method that prints out
      all the data stored for a person object. Notice that it is marked as
      <c>public</c> and after <c>public</c> comes the return type. The
      <c>void</c> return type is used to indicate that the method does not
      return anything but has some effect such as printing to the screen. After
      the return type comes the method name followed by parentheses containing
      the list of parameters. In this case there are no parameters but we still
      need the <c>()</c>s. The body of the method is in <c>{}</c>s. As we’ve
      discussed, the method can access and use the instance variables defined in
      the class: <c>name</c>, <c>email</c>, and <c>phoneNumber</c> but will get
      the values specific to the object we called <c>print</c> on.
    </p>

    <program>
      public void print()
      {
        System.out.println("Name: " + name);
        System.out.println("Email: " + email);
        System.out.println("Phone Number: " + phoneNumber);
      }
    </program>

    <p>
      To call a method, we need an object that is an instance of the class such
      as we get by calling its constructor. Then we use the dot (<c>.</c>)
      operator to call its <c>public</c> methods, for example <c>p1.print()</c>
      means call the <c>print</c> method on the object <c>p1</c>.
    </p>

    <program>
      // call the constructor to create a new person
      Person p1 = new Person("Sana", "sana@gmail.com", "123-456-7890");
      // call p1's print method
      p1.print();
    </program>

    <activity label="name_methods">
      <statement>
        <p>
          Click on all the lines of code that are part of a method in the
          following class.
        </p>
      </statement>

      <feedback>
        <p>
          Methods follow the constructor. They include a return type in case
          they returns something from the method.
        </p>
      </feedback>

      <areas>
        <cline><area correct="no">public class Name</area></cline>
        <cline><area correct="no">{</area></cline>
        <cline>    <area correct="no">private String first;</area></cline>
        <cline>    <area correct="no">private String last;</area></cline>
        <cline />
        <cline>    <area correct="no">public Name(String theFirst, String theLast)</area></cline>
        <cline>    <area correct="no">{</area></cline>
        <cline>        <area correct="no">first = theFirst;</area></cline>
        <cline>        <area correct="no">last = theLast;</area></cline>
        <cline>    <area correct="no">}</area></cline>
        <cline />
        <cline>    <area correct="yes">public void setFirst(String theFirst)</area></cline>
        <cline>    <area correct="yes">{</area></cline>
        <cline>        <area correct="yes">first = theFirst;</area></cline>
        <cline>    <area correct="yes">}</area></cline>
        <cline />
        <cline>    <area correct="yes">public void setLast(String theLast)</area></cline>
        <cline>    <area correct="yes">{</area></cline>
        <cline>        <area correct="yes">last = theLast;</area></cline>
        <cline>    <area correct="yes">}</area></cline>
        <cline />
        <cline><area correct="no">}</area></cline>
      </areas>
    </activity>

    <activity label="class-add-print-method">
      <statement>
        <p>
          The following Name class keeps track of the first and last name of a
          person. Add a method print that prints out the instance variables
          first and last. Note that the methods have direct access and share the
          instance variables.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class Name {
              private String first;
              private String last;

              public Name(String theFirst, String theLast) {
                  first = theFirst;
                  last = theLast;
              }

              // Complete the print method below to print out the
              // first and last instance variables with a space in between
              public void print() {}

              public static void main(String[] args) {
                  Name n = new Name("Ada", "Lovelace");
                  n.print();
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              public RunestoneTests() {
                  super("Name"); // class name / location of main
                  Object[] values = new Object[] {"Mickey", "Mouse"};
                  setDefaultValues(values);
              }

              @Test
              public void testMain() {
                  String output = getMethodOutput("main");
                  String expect = "Ada Lovelace";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }

              @Test
              public void testPrint() {
                  String output = getMethodOutput("print");
                  String expect = "Mickey Mouse";
                  boolean passed =
                          getResults(
                                  expect,
                                  output,
                                  "Expected output from print method with object Mickey Mouse");
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="defining-and-calling-methods">
    <title>Defining and Calling Methods</title>

    <p>
      A <term>method</term> is a block of code that performs a specific task.
      Methods are defined inside a class and can access the instance variables
      of the class. For example, the print() method below prints the instance
      variables of the Person class. Methods are usually public.
    </p>

    <program>
      public class Person {
          // instance variables
          private String name;
          private String email;

          // Method definition: uses instance variables name and email
          public void print() {
              System.out.println("Name: " + name);
              System.out.println("Email: " + email);
          }

          public static void main(String[] args) {
              Person p = new Person();
              p.print(); // Method call
          }
      }
    </program>

    <p>There are three steps to creating and calling a method:</p>

    <p>
      <ol>
        <li>
          <p>
            <term>Object of the Class</term>: Declare an object of your class in
            the main method or from outside the class.
          </p>

          <program>
            // Step 1: declare an object in main or from outside the class
            Classname objectName = new Classname();
          </program>
        </li>

        <li>
          <p>
            <term>Method Call</term>: whenever you want to use the method, call
            objectName.methodName();
          </p>

          <program>
            // Step 2: call the object's method
            objectName.methodName(); //Step 2
          </program>
        </li>

        <li>
          <p>
            <term>Method Definition</term>: write the method’s
            <term>header</term> and <term>body</term> code like below:
          </p>

          <program>
            // Step 3: Define the method in the class
            // method header
            public void methodName()
            {
                  // method body for the code
            }
          </program>
        </li>
      </ol>
    </p>

    <p>
      The following flowchart can be used to compare three different ways of
      calling methods. Class (static) methods are called using the class name.
      Instance methods which are discussing in this lesson are called using an
      object of the class. If you are calling the instance method from the main
      method or from another class, you must first create an object of that
      class and then call its methods using <c>object.methodName()</c>. If you
      are calling the method from within the same class, you can just call the
      method using <c>methodName()</c> which will refer to the current object.
    </p>

    <figure align="center">
      <caption>Comparing Method Calls to Static and Instance Methods</caption>

      <image source="Unit3-Class-Creation/Figures/FlowChartCallingMethods.png" width="98%">
        <shortdescription>
          Comparing method calls to static and instance methods
        </shortdescription>
      </image>
    </figure>

    <activity label="PersonPrint">
      <statement>
        <p>
          Try the following code. Add a print() method in the Person class that
          prints out all the attributes (name, email, phonenumber) of a person
          object.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class Person {
              // instance variables
              private String name;
              private String email;
              private String phonenumber;

              // Constructor
              public Person(String n, String e, String p) {
                  name = n;
                  email = e;
                  phonenumber = p;
              }

              // TODO: Add a print() method that prints out all the attributes (name, email, phonenumber)

              public static void main(String[] args) {
                  Person p1 = new Person("Taylor", "swift@gmail.com", "123-456-7890");
                  p1.print();
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper {
              @Test
              public void test1() {
                  String target = "public void print()";
                  boolean passed = checkCodeContains("public void print() method", target);
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="void-methods">
    <title>void Methods</title>

    <p>
      A <term>void method</term> is a method that does not return a value. It is
      used when you want to perform an action but do not need to return a value.
      The method header for a void method looks like this:
    </p>

    <program>
      public void methodName()
      {
          // method body
      }
    </program>

    <p>
      The <c>print</c> method above is a void method. It does not return a
      value, but it does print out the name and email of the person. In the
      sections below, we will learn about setter methods that are also void
      methods.
    </p>
  </subsection>

  <subsection xml:id="non-void-methods-1">
    <title>Non-void Methods</title>

    <p>
      A <term>non-void method</term> is a method that returns a single value.
      Its body must have a <term>return</term> statement, usually at the end,
      that returns a variable’s value or an expression. Its header includes the
      <term>return type</term> (the type of the value in the return statement)
      in place of the keyword <c>void</c>. The method header for a non-void
      method looks like this:
    </p>

    <program>
      public returnType methodName()
      {
          // method body
          return value;
      }
    </program>

    <p>
      In Unit 1, we used static non-void methods like `` Math.random()`` which
      returned a random number. We also used non-void methods that belonged to
      Turtle objects like <c>getXPos()</c> and <c>getYPos()</c> that returned
      the x and y coordinates of the turtle. The most common non-void methods in
      Java are methods that start with <c>get</c> and return the value of an
      instance variable. We will learn about these in the next section.
    </p>

    <p>
      In non-void methods, a return expression compatible with the return type
      is evaluated, and the value is returned. This is referred to as
      <term>return by value</term>. The <c>return</c> keyword is used to return
      the flow of control to the point where the method or constructor was
      called. Any code that is sequentially after a return statement will never
      be executed, so usually non-void methods end with a return statement.
      Executing a return statement inside a selection or iteration statement
      will halt the statement and exit the method or constructor.
    </p>

    <note>
      <p>Some common errors when writing and using non-void methods are:</p>

      <p>
        <ul>
          <li>
            <p>
              Forgetting a return type like <c>int</c> before the method name.
            </p>
          </li>

          <li>
            <p>
              Forgetting to use the <c>return</c> keyword to return a value at
              the end of the method.
            </p>
          </li>

          <li>
            <p>
              Returning too soon from a method. If you have a return statement
              in a selection or iteration statement, the method will exit at
              that point and not execute the rest of the code.
            </p>
          </li>

          <li>
            <p>
              Forgetting to do something with the value returned from a method,
              like assigning it to a variable or printing it out.
            </p>
          </li>
        </ul>
      </p>
    </note>
  </subsection>

  <subsection xml:id="parameters">
    <title>Parameters</title>

    <p>
      The setter methods above contained parameters. A <term>parameter</term> is
      a variable in a method’s header that is used to pass in data that the
      method needs to do its job. In a setter, the parameter is the new value
      that you want to assign to the instance variable. Methods with parameters
      receive values through those parameters and use those values in
      accomplishing the method’s task.
    </p>

    <p>
      An <term>argument</term> is a value that is passed into a method when the
      method is called. It is saved into a parameter variable. The arguments
      passed to a method must be compatible in number and order with the types
      identified in the parameter list of the method signature. When calling
      methods, arguments are passed using call by value. <term>Call by
      value</term> initializes the parameters with copies of the arguments. When
      an argument is a primitive value, the parameter is initialized with a copy
      of that value. Changes to the parameter have no effect on the
      corresponding argument.
    </p>

    <figure align="center">
      <caption>
        Method signatures with parameters and method calls arguments
      </caption>

      <image source="Unit3-Class-Creation/Figures/method-param-arg.png" width="98%">
        <shortdescription>Method parameters and arguments</shortdescription>
      </image>
    </figure>
  </subsection>

  <subsection>
    <title>Old intro</title>

    <idx>instance methods</idx>
    <idx>object methods</idx>
    <idx>method</idx>
    <idx>parameter</idx>
    <idx>argument</idx>
    <p>
      In object-oriented programming, <term>methods</term> define the behavior
      and actions that an object can perform. For example, <c>Turtle</c> objects
      can go forward or turn left using method calls like
      <c>yertle.forward()</c> and <c>yertle.turnRight()</c> to change its
      position. These methods are sometimes called <term>instance methods</term>
      or <term>object methods</term> because they are called using an instance
      or object of the class, in this case a specific <c>Turtle</c> object like
      <c>yertle</c>.
    </p>
  </subsection>

  <p>
    The <term>method signature</term> defines the method’s name and the number
    and types of parameters it takes. In a class definition or in documentation
    of a library, instance methods are usually defined after the instance
    variables (attributes) and constructors in a class. For example, see the
    <c>Student</c> class below. Notice that the methods do not use the keyword
    <c>static</c>. They are instance methods that are called using an object of
    the class and can access and change the object’s attributes.
  </p>

  <figure align="center">
    <caption>
      A Student class showing instance variables, constructors, and methods
    </caption>

    <image source="Unit1-Using-Objects-and-Methods/Figures/StudentClass.png" width="89%">
      <shortdescription>
        A Student class showing instance variables, constructors, and methods
      </shortdescription>
    </image>
  </figure>

  <p>
    The following flowchart can be used to compare three different ways of
    calling methods. Class (static) methods are called using the class name.
    Instance methods are called using an object of the class. If you are calling
    the instance method from the main method or from another class, you must
    first create an object of that class and then call its methods using
    <c>object.methodName()</c>. If you are calling the method from within the
    same class, you can just call the method using <c>methodName()</c> which
    will refer to the current object.
  </p>

  <figure align="center">
    <caption>Comparing Method Calls to Static and Instance Methods</caption>

    <image source="Unit1-Using-Objects-and-Methods/Figures/FlowChartCallingMethods.png" width="98%">
      <shortdescription>
        Comparing method calls to static and instance methods
      </shortdescription>
    </image>
  </figure>

  <subsection xml:id="methods-calls-with-arguments">
    <title>Methods Calls with Arguments</title>

    <p>
      In the last lessons, we used simple <term>methods</term> like
      <c>forward</c> and <c>turnRight</c> to make the turtle draw lines. You may
      have noticed that <c>forward()</c> and <c>backward()</c> always move the
      same number of pixels (100 pixels), and <c>turnRight()</c> and
      <c>turnLeft()</c> always turn at right angles (90 degrees). This is a
      little limiting. What if we wanted to draw a triangle or the letter A?
      These require smaller angles to draw diagonal lines and different length
      lines. Luckily, there are more complex methods in the <c>Turtle</c> class
      that let you specify the number of pixels to move forward or the number of
      degrees to turn. These values that you can give to methods to help them do
      their job are called <term>arguments</term> or <term>parameters</term>.
      For example, we can give the argument 200 in <c>forward(200)</c> to make
      the turtle go forward 200 pixels instead of the default of 100 or the
      argument 30 in <c>turn(30)</c> to make the turtle turn 30 degrees instead
      of 90 degrees.
    </p>

    <note>
      <p>
        <c>object.method(arguments);</c> is used to call an object’s method and
        give it some argument values that it will need to do its job.
      </p>
    </note>

    <p>
      When you create your own method, the variables you define for it are
      called <term>parameters</term>. When you call the method to do its job,
      you give or pass in <term>arguments</term> to it that are then saved in
      the parameter variables. So, in the definition of the <c>forward</c>
      method, it has a parameter variable called <c>pixels</c>, and in the call
      to <c>forward(200)</c>, the argument is the value 200 which will get saved
      in the parameter variable pixels. You will learn to write your own methods
      in Unit 3. In this unit, you will learn to call methods that are already
      written for you.
    </p>

    <figure align="center">
      <caption>
        Method signatures with parameters and method calls arguments
      </caption>

      <image source="Unit1-Using-Objects-and-Methods/Figures/method-param-arg.png" width="98%">
        <shortdescription>Method parameters and arguments</shortdescription>
      </image>
    </figure>
  </subsection>
</scratch>
