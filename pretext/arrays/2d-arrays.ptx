<?xml version="1.0" encoding="utf-8"?>

<section xml:id="two-dimensional-arrays">
  <title>Two-dimensional arrays</title>

  <idx>2D Arrays</idx>
  <idx>row</idx>
  <idx>column</idx>
  <idx><h>arrays</h><h>2D</h></idx>
  <idx><h>2D Array</h><h>definition</h></idx>
  <idx><h>2D Array</h><h>row</h></idx>
  <idx><h>2D Array</h><h>column</h></idx>
  <idx><h>2D Array</h><h>declaration</h></idx>
  <idx><h>2D Array</h><h>creation</h></idx>
  <introduction>
    <p>
      The arrays we’ve been dealing with so far are also called, more
      specifically, <term>one-dimensional arrays</term> because the elements are
      arranged along a one dimension like numbers on the number line or people
      on line to get a cinnamon bun or slice of pizza that’s gone viral on
      TikTok. In order to indicate which element we want out of a
      one-dimensional array we need just one number, the index.
    </p>

    <p>
      But sometimes it’s useful to think of data arranged in more than one
      dimension. For instance many things are arranged in horizontal
      <term>rows</term> and vertical <term>columns</term> like spreadsheets,
      chess boards, bingo cards, and theater seats. And all the images on a
      computer screen are ultimately made up of tiny pixels arranged into a
      two-dimensional arrangement of rows and columns. In the picture below
      there are three rows of lockers and six columns.
    </p>

    <figure align="center">
      <caption>Lockers in rows and columns</caption>

      <image source="Unit4-Data-Collections/Figures/2DLockers.jpg" width="63%" />
    </figure>

    <p>
      In Java we can also make <term>two-dimensional arrays</term> or <term>2d
      arrays</term> which can be indexed with two indices which we can think of
      as rows and columns or x and y. Though as it turns out, Java’s 2d arrays
      are really just 1d arrays that happen to contain 1d arrays as their
      elements. So if we fully understand how arrays work in general, there’s
      not much more to learn about 2d arrays.
    </p>
  </introduction>

  <subsection>
    <title>Declaring 2d arrays</title>

    <p>
      The key to understanding 2d arrays is to understanding that 1d arrays can
      contain any kind of value, which includes other arrays. So, to review, if
      we want to make an array of <c>int</c> values, we use <c>int[]</c>. And
      for an array of <c>String</c> values we use <c>String[]</c>.
    </p>

    <p>
      Which means if we want to make an array whose values are <c>int[]</c>,
      that is, one-dimensional arrays, we use <c>int[][]</c>, adding another
      pair of square brackets <c>[]</c> after the element type. Thus we can
      think of an <c>int[][]</c> either as a 2d array (which is how we normally
      think of it) or as a 1d array whose elements are <c>int[]</c>.
    </p>

    <p>Here are two declarations of 2d array variables:</p>

    <program>
      int[][] ticketInfo;
      String[][] seatingChart;
    </program>

    <p>
      As with any array declarations, declaring a variable doesn’t cause an
      actual array to be created so these variables will be <c>null</c> until
      they are initialized. And we have no idea how big the arrays will be that
      these variables will eventually reference.
    </p>
  </subsection>

  <subsection>
    <title>Creating 2d arrays</title>

    <p>
      The array creation expressions and array initializers we used with
      one-dimensional arrays also work to create 2d arrays. The main difference
      is that when we want to construct a 2d array of a specific size, we need
      to specify the size of both dimensions and when we use an array
      initializer we need use nested <c>{}</c> to provide initial values in two
      dimensions.
    </p>

    <p>
      For example, here’s how to create array values of a particular size and
      assign them to the <c>ticketInfo</c> and <c>seatingChart</c> declared
      above:
    </p>

    <program>
      ticketInfo = new int[2][3];
      seatingChart = new String[3][2];
    </program>

    <p>
      Those array creation expressions create an outer array which has the
      length specified by the number in the first set of <c>[]</c> and then
      creates that many inner arrays whose length is specified in the second set
      of <c>[]</c>. Typically (and always on the AP exam) we think of the first
      dimension as rows and the second as columns. So we’d describe
      <c>ticketInfo</c> as two rows of three columns each while
      <c>seatingChart</c> is three rows of two columns each. Each row of a 2d
      array is represented by a 1d array containing the actual values in that
      row and each column.
    </p>

    <p>
      The values in the inner arrays are filled with the appropriate zero type
      for their element type, <c>int</c> for the inner arrays of
      <c>ticketInfo</c> and <c>String</c> for the inner ararys of
      <c>seatingChart</c>. So in total ticketInfo contains six <c>int</c> zeros
      arranged into two three-element inner arrays while <c>seatingChart</c>
      contains six <c>null</c> refernces arranged into three two-element inner
      arrays.
    </p>

    <p>
      We can also use array initializers to create array values with specific
      values. We write the inner arrays as array initializers nested within an
      outer set of <c>{}</c>. As with a one-dimensional array initializer we
      don’t need to specify the dimensions of the array in the <c>[]</c> because
      it’s implicit in the number of values provided. Here are initializers for
      our two variables that set them to arrays of the same shape (number of
      rows and columns) as the previous array creation expressions, though this
      time with specific, non-zero values in the inner arrays.
    </p>

    <program>
      // Using array initializer
      ticketInfo = new int[][] { { 25, 20, 25 }, { 25, 20, 25 } };
      seatingInfo = new String[][] { { "Jamal", "Maria" }, {"Jake", "Suzy" }, { "Emma", "Luke" } };
    </program>

    <p>
      Also similar to creating 1d arrays we can use array initializers to
      provide specific values. In this case, the syntactic sugar of not having
      to include the <c>new</c> and the type of the arrays when we’re
      initializing a newly declared array variable, makes things pretty compact
      and readable:
    </p>

    <program>
      int[][] ticketInfo = { { 25, 20, 25}, { 25, 20, 25} };
      String[][] seatingInfo = { { "Jamal", "Maria" }, { "Jake", "Suzy" }, { "Emma", "Luke" } };
    </program>

    <activity label="twodaGetElfill">
      <statement>
        <p>
          What is the value at <c>seatingInfo[2][1]</c> after the code above
          executes?
        </p>

        <p>
          Remember that indices start at 0, and the first index is for rows and
          the second index is for columns.
        </p>

        <p>
          <fillin answer="Luke" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>
              Correct! The string at row index 2 and column index 1 is "Luke."
            </feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              Remember, indices start at 0, and the row index comes first,
              followed by the column index.
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <note>
      <p>
        There are other ways to create arrays that are outside of the scope of
        the AP curriculum. For instance, we can make a new array with the second
        dimension unspecified like <c>new int[10][]</c> which will create a
        ten-element array initialized with <c>null</c> values that can latter be
        assigned references to any <c>int[]</c>. And those arrays don’t
        necessarily all have be the same length, giving us a non-rectangular
        array. Similarly with array initializers we can make arbitrarily shaped
        arrays. But all 2d arrays on the AP exam will be rectangular, meaning
        every row will be the same length.
      </p>
    </note>

    <activity label="twodaNumElfill">
      <statement>
        <p>How many elements are in <c>ticketInfo</c>?</p>

        <p>
          <fillin answer="6" mode="string" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>Correct! 2 × 3 = 6.</feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>
              Multiply the number of rows and the number of columns.
            </feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="twoDArrayCreate">
      <statement>
        <p>
          What will the following code print out? Can you change ticketInfo to
          be an array of 5 rows and 10 columns? Can you declare another array
          called studentNames that has 10 rows and 5 columns? The length
          property of arrays will be explained below.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class TicketInfo {
            public static void main(String[] args) {
              // declare arrays
              int[][] ticketInfo = new int[2][3];
              System.out.println(ticketInfo.length + " rows");
              System.out.println(ticketInfo[0].length + " columns");
            }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("TicketInfo");
            }

            @Test
            public void test1() {
              String output = getMethodOutput("main");
              String expected = "5 rows\n10 columns";

              boolean passed = output.contains(expected);
              passed = getResults(expected, output, "Changed ticketInfo to 5 rows and 10 columns", passed);

              assertTrue(passed);
            }

            @Test
            public void test2() {
              String expected = "studentNames = new String[10][5]";

              boolean passed = checkCodeContains(expected);
              assertTrue(passed);
            }
          }
        </tests>
      </program>
    </activity>

    <p>
      Try to answer the following questions. Click on the value or values to
      select them. Click again to unselect a value.
    </p>

    <activity label="clicktd1">
      <statement>
        <p>Click on all the values in the row at index 2</p>
      </statement>

      <feedback>
        <p>
          Rows are horizontal and columns are vertical and both start with index
          0.
        </p>
      </feedback>

      <areas>
        <table>
          <tabular>
            <col top="minor" />
            <col top="minor" />
            <col top="minor" />
            <col top="minor" />
            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="no">8</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-2</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">3</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-1</area>
              </cell>
            </row>

            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="no">4</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">5</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">0</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-7</area>
              </cell>
            </row>

            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="yes">2</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="yes">-3</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="yes">-4</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="yes">-5</area>
              </cell>
            </row>
          </tabular>
        </table>
      </areas>
    </activity>

    <activity label="clicktd2">
      <statement>
        <p>Click on all the values in the column at index 1</p>
      </statement>

      <feedback>
        <p>
          Rows are horizontal and columns are vertical and both start with index
          0.
        </p>
      </feedback>

      <areas>
        <table>
          <tabular>
            <col top="minor" />
            <col top="minor" />
            <col top="minor" />
            <col top="minor" />
            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="no">8</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="yes">-2</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">3</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-1</area>
              </cell>
            </row>

            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="no">4</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="yes">5</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">0</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-7</area>
              </cell>
            </row>

            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="no">2</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="yes">-3</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-4</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-5</area>
              </cell>
            </row>
          </tabular>
        </table>
      </areas>
    </activity>

    <activity label="clicktd3">
      <statement>
        <p>Click on the value at row index 2 and column index 1</p>
      </statement>

      <feedback>
        <p>
          Rows are horizontal and columns are vertical and both start with index
          0.
        </p>
      </feedback>

      <areas>
        <table>
          <tabular>
            <col top="minor" />
            <col top="minor" />
            <col top="minor" />
            <col top="minor" />
            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="no">8</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-2</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">3</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-1</area>
              </cell>
            </row>

            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="no">4</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">5</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">0</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-7</area>
              </cell>
            </row>

            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="no">2</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="yes">-3</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-4</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-5</area>
              </cell>
            </row>
          </tabular>
        </table>
      </areas>
    </activity>

    <activity label="clicktd4">
      <statement>
        <p>Click on the value at row index 0 and column index 2</p>
      </statement>

      <feedback>
        <p>
          Rows are horizontal and columns are vertical and both start with index
          0.
        </p>
      </feedback>

      <areas>
        <table>
          <tabular>
            <col top="minor" />
            <col top="minor" />
            <col top="minor" />
            <col top="minor" />
            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="no">8</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-2</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="yes">3</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-1</area>
              </cell>
            </row>

            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="no">4</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">5</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">0</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-7</area>
              </cell>
            </row>

            <row left="minor">
              <cell bottom="minor" right="minor">
                <area correct="no">2</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-3</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-4</area>
              </cell>

              <cell bottom="minor" right="minor">
                <area correct="no">-5</area>
              </cell>
            </row>
          </tabular>
        </table>
      </areas>
    </activity>

    <activity label="clicktd5">
      <statement>
        <p>Click on the value at row index 1 and column index 1</p>
      </statement>

      <feedback>
        <p>
          Rows are horizontal and columns are vertical and both start with index
          0.
        </p>
      </feedback>

      <areas>
        <table>
          <tabular bottom="minor" right="minor" top="minor" left="minor">
            <row>
              <cell><area correct="no">8</area></cell>
              <cell><area correct="no">-2</area></cell>
              <cell><area correct="no">3</area></cell>
              <cell><area correct="no">-1</area></cell>
            </row>

            <row>
              <cell><area correct="no">4</area></cell>
              <cell><area correct="yes">5</area></cell>
              <cell><area correct="no">0</area></cell>
              <cell><area correct="no">-7</area></cell>
            </row>

            <row>
              <cell><area correct="no">2</area></cell>
              <cell><area correct="no">-3</area></cell>
              <cell><area correct="no">-4</area></cell>
              <cell><area correct="no">-5</area></cell>
            </row>
          </tabular>
        </table>
      </areas>
    </activity>
  </subsection>

  <subsection xml:id="set-values-in-a-2d-array">
    <title>Accessing values in a 2d array</title>

    <idx><h>2D Array</h><h>initialization</h></idx>
    <idx><h>2D Array</h><h>set value</h></idx>

    <p>
      Another similarity between one-dimensional and 2d arrays is the way we
      access the values. Normally we want to get and set the actual values in
      the array, such as the <c>int</c> values in an <c>int[][]</c>. Just like
      with a one-dimensional array we use an array access expression, but this
      time with two pairs of <c>[]</c> rather than just one. The expression in
      the first pair gives us the index into the outer array, or the row index,
      and the expression in the second pair gives the column index used to index
      into the inner array.
    </p>

    <p>
      Here’s some code that initializes some arrays and then accesses some
      values, getting the value from row one, column zero of <c>ticketInfo</c>
      and from row zero, column one of <c>seatingInfo</c>. It then assigns a new
      value to row zero, column zero of <c>ticketInfo</c>:
    </p>

    <program>
      int[][] ticketInfo = { {25,20,25}, {25,20,25} };
      String[][] seatingInfo = { {"Jamal", "Maria"}, {"Jake", "Suzy"}, {"Emma", "Luke"} };

      int value = ticketInfo[1][0];
      String name = seatingInfo[0][1];
      ticketInfo[0][0] = 15;
    </program>

    <activity label="qa2dab_2">
      <statement>
        <p>What is the value of <c>name</c> after the code above executes?</p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>Jamal</p>
          </statement>

          <feedback>
            <p>
              This would be true for if <c>name</c> was set to
              <c>seatingInfo[0][0];</c> instead.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>Maria</p>
          </statement>

          <feedback>
            <p>Maria is the value of <c>seatingInfo[0][1];</c>.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Jake</p>
          </statement>

          <feedback>
            <p>
              This would be true for if <c>name</c> was set to
              <c>seatingInfo[1][0];</c> instead.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Suzy</p>
          </statement>

          <feedback>
            <p>
              This would be true for if <c>name</c> was set to
              <c>seatingInfo[1][1];</c> instead.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Emma</p>
          </statement>

          <feedback>
            <p>
              This would be true for if <c>name</c> was set to
              <c>seatingInfo[2][1];</c> instead.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>


    <activity label="twoDArraySet">
      <statement>
        <p>
          Try to predict what the code below will print then run it. Did it
          print what you expected? If it didn’t, open the Hint below for an
          explanation. After you’ve run it once, edit the code to add an extra
          row to the <c>seatingChart</c> array and add your name and a friend’s
          name in the columns of this extra row using assignment statements.
        </p>
      </statement>

      <hint>
        <p>
          While <c>System.out.println</c> can turn any value into a
          <c>String</c> to print it, not all reference types to a particularly
          useful string representation. Arrays, in particular, turn into the
          gibberish you see when you run this program.
        </p>

        <p>
          In the next lesson, we’ll learn how to use nested loops to print out a
          whole 2D Array. Right now, you can use the CodeLens button to see what
          the values are after this code runs. Or you can add this line at the
          top of the code.
        </p>

        <program>
          import java.util.Arrays;
        </program>

        <p>
          and the change the two <c>System.out.println</c> lines to:
        </p>

        <program>
          System.out.println(Arrays.deepToString(ticketInfo));
          System.out.println(Arrays.deepToString(seatingChart));
        </program>

        <p>
          to get more readable representations of the two arrays.
        </p>
      </hint>

      <program interactive="activecode">
        <code>
          public class TwoDArraySet {
            public static void main(String[] args) {
              // declare arrays
              int[][] ticketInfo;
              String[][] seatingChart;

              // create arrays
              ticketInfo = new int[2][3];
              seatingChart = new String[3][2];

              // initialize the array elements
              ticketInfo[0][0] = 15;
              ticketInfo[0][1] = 10;
              ticketInfo[0][2] = 15;
              ticketInfo[1][0] = 25;
              ticketInfo[1][1] = 20;
              ticketInfo[1][2] = 25;
              seatingChart[0][0] = "Jamal";
              seatingChart[0][1] = "Maria";
              seatingChart[1][0] = "Jacob";
              seatingChart[1][1] = "Suzy";
              seatingChart[2][0] = "Emma";
              seatingChart[2][1] = "Luke";

              // print the contents
              System.out.println(ticketInfo);
              System.out.println(seatingChart);
            }
          }
        </code>

        <tests>
          <![CDATA[

          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("TwoDArraySet");
            }

            @Test
            public void test1() {
              String output = getMethodOutput("main");
              String expected = "[[I@", expected2 = "[[Ljava.lang.String;@";

              boolean passed = output.contains(expected) && output.contains(expected2);

              passed = getResults("true", "" + passed, "Prints two 2D arrays");
              assertTrue(passed);
            }

            @Test
            public void test2() {
              String code = getCode();
              String expected = "new String[4][2]";

              boolean passed = code.contains(expected);

              passed = getResults("true", "" + passed, "Add another row to seatingChart");
              assertTrue(passed);
            }

            @Test
            public void test3() {
              String code = getCode();
              String expected1 = "seatingChart[3][0]";
              String expected2 = "seatingChart[3][1]";

              boolean passed = code.contains(expected1) && code.contains(expected2);

              passed = getResults("true", "" + passed, "Give values to new elements");
              assertTrue(passed);
            }
          }

          ]]>
        </tests>
      </program>
    </activity>

    <activity label="qa2dab_1">
      <statement>
        <p>
          Which of the following sets the value for the 3rd row and 2nd column
          of a 2D array called <c>nums</c>?
        </p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>nums[3][2] = 5;</p>
          </statement>

          <feedback>
            <p>Remember that the indices start at 0.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>nums[1][2] = 5;</p>
          </statement>

          <feedback>
            <p>Remember that the row is first then the column.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>nums[2][1] = 5;</p>
          </statement>

          <feedback>
            <p>This will set the value of the 3rd row and 2nd column.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>nums[2][3] = 5;</p>
          </statement>

          <feedback>
            <p>
              Remember that the row is first and then the column and that the
              indices start at 0.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>



    <activity label="twoDArrayInitGet">
      <statement>
        <p>
          Add another row to seatingInfo initialized to your name and a friend’s
          name. Get these names out of the array using the correct indices and
          then print them out.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class TwoDArrayInitGet {
            public static void main(String[] args) {
              String[][] seatingInfo = {
                {"Jamal", "Maria"},
                {"Jake", "Suzy"},
                {"Emma", "Luke"}
              };
              String name = seatingInfo[0][0];
              System.out.println(name + " is at [0,0]");
            }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("TwoDArrayInitGet");
            }

            @Test
            public void test1() {
              String output = getMethodOutput("main");
              String expected = "Jamal is at [0,0]";

              boolean passed = output.contains(expected);

              passed = getResults("true", "" + passed, "Output contains " + expected);
              assertTrue(passed);
            }

            @Test
            public void test2() {
              String output = getMethodOutput("main");
              String[] lines = output.split("\n");

              String expected = "[3,0]";
              String actual = "";

              boolean passed = false;

              for (String l : lines) {
                if (l.replaceAll(" ", "").contains(expected)) {
                  actual = l;
                  passed = true;
                }
              }

              passed =
                  getResults(
                      "Name is at " + expected, actual, "Add one name to new row and print it out", passed);
              assertTrue(passed);
            }

            @Test
            public void test3() {
              String output = getMethodOutput("main");
              String[] lines = output.split("\n");

              String expected = "[3,1]";
              String actual = "";

              boolean passed = false;

              for (String l : lines) {
                if (l.replaceAll(" ", "").contains(expected)) {
                  actual = l;
                  passed = true;
                }
              }

              passed =
                  getResults(
                      "Name is at " + expected,
                      actual,
                      "Add second name to new row and print it out",
                      passed);
              assertTrue(passed);
            }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="d-array-row-and-column-length">
    <title>2D array sizes</title>

    <idx><h>2D Array</h><h>number of rows</h></idx>
    <idx><h>2D Array</h><h>number of columns</h></idx>
    <idx>length</idx>
    <p>
      As we know, we can get the length of a one-dimensional aarray using it’s
      <c>length</c> property. That property of course exists on 2d arrays too,
      because they are just one-dimensional arrays that happen to contain other
      arrays. So the <c>length</c> of a 2d array is the number of rows in the
      array and the <c>length</c> of any of those rows is the number of columns.
      Traditionally programmers will use <c>array[0].length</c> since as long as
      the array has any rows it has a row <c>0</c>.
    </p>

    <program>
      ticketInfo.length    // number of rows
      ticketInfo[0].length // number of columns
    </program>

    <p>
      As always, the length of an array determines what indices are valid. So
      the valid row indices of a 2d array, <c>grid</c> are from <c>0</c> to
      <c>grid.length - 1</c>, inclusive, and the valid column indices are from
      <c>0</c> to <c>grid[0].length - 1</c>, also inclusive. Using an index
      value outside of these ranges will result in an
      <c>ArrayIndexOutOfBoundsException</c>.
    </p>

    <note>
      <p>
        Using the length of the zeroth row as number of columns only works if
        the array is rectangular, meaning all the rows contain the same number
        of columns. That will be true of all 2d arrays on the AP exam but is not
        necessarily true in general.
      </p>
    </note>

    <activity label="qa2ldb_2">
      <statement>
        <p>
          How many rows does <c>a</c> have if it is created as follows
          <c>int[][] a = { {2, 4, 6, 8}, {1, 2, 3, 4}};</c>?
        </p>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>2</p>
          </statement>

          <feedback>
            <p>The size of outer list is the number of rows.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>4</p>
          </statement>

          <feedback>
            <p>The size of the inner list is the number of columns.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>8</p>
          </statement>

          <feedback>
            <p>This is the total number of items in the array.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qa2ldb_3">
      <statement>
        <p>
          Which of the following could be used to get the value in the third row
          and second column from a 2D array called <c>nums</c>?
        </p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>nums[3][2]</p>
          </statement>

          <feedback>
            <p>
              This would be true if array indices started with 1 but they start
              with 0.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>nums[2][3]</p>
          </statement>

          <feedback>
            <p>
              This would be true if array indices started with 1 and the column
              was specified first. However, array indices start at 0 and the row
              is given first in row-major order.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>nums[2][1]</p>
          </statement>

          <feedback>
            <p>
              Array indices start with 0 so the third row has an index of 2 and
              the second column has an index of 1.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>nums[1][2]</p>
          </statement>

          <feedback>
            <p>
              This would be true if the column index was first, but in row-major
              order the row index is first.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="coding-challenge-ascii-art">
    <title>Coding Challenge: ASCII Art</title>

    <p>
      ASCII is a commonly used character encoding standard where each key you
      press on the keyboard is translated to an ASCII number to be stored in the
      computer. ASCII has been mostly replaced by UNICODE which includes
      characters in other languages like Chinese. In the days before good
      graphics, some people made ASCII art just using the keyboard characters.
      Take a look at this <url href="https://www.asciiart.eu/">ASCII art</url>
      collection!
    </p>

    <p>
      We can represent ASCII art in a 2D array of rows and columns. What do you
      think the following code will print out? Try to guess before you run it.
      The loops to print out the 2D array will be explained in the next lesson.
      Then, do the following:
    </p>

    <p>
      <ol>
        <li>
          <p>
            Change the code to use 2 assignment statements with the 2D array
            <c>asciiArt</c> to change the “o” characters to “@” characters. You
            should figure out what the row and column indices should be for the
            “o” characters and use them with the array name to set that
            character to “@”. After testing this code, comment it out so that
            your teacher can still see it.
          </p>
        </li>

        <li>
          <p>
            Add a new <c>asciiArt</c> array with a different <url
            href="https://www.asciiart.eu/">ASCII art</url> from the collection
            or of your own design. Be careful with the special characters like
            <c>"</c> and <c>\</c>. You will need to put another backslash in
            front of these to print them out like <c>\"</c> and <c>\\</c>.
          </p>
        </li>
      </ol>
    </p>

    <project label="challenge-8-1-ascii-art">
      <statement>
        <p>
          Part 1: Add 2 assignment statements for the 2D array asciiArt to
          change the “o” characters to “@” characters. Part 2: Create a new
          asciiArt array and print it out.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class AsciiArt {
            public static void main(String[] args) {

              String[][] asciiArt = {
                {" ", " ", "_", "_", "_", " ", " "},
                {" ", "(", "o", " ", "o", ")", " "},
                {"(", " ", " ", "V", " ", " ", ")"},
                {" ", "-", "m", "-", "m", "-", " "},
              };

              // Part 1: Add 2 assignment statements to change "o" to "@"

              // print the asciiArt for Part 1
              System.out.println("ASCII Art:");
              for (String[] row : asciiArt) {
                for (String column : row) System.out.print(column);
                System.out.println();
              }

              // Part 2: Create your own ASCII art array and print it out!

            }
          }
        </code>

        <tests>
          <![CDATA[

          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("AsciiArt");
            }

            @Test
            public void test0() {
              String output = getMethodOutput("main");
              String expect = "ASCII Art: \n___  \n (@ @) \n(  V  )\n -m-m-";

              boolean passed = getResults(expect, output, "Running main()", true);
              assertTrue(passed);
            }

            /* removed because doesn't work if their own art has o
            @Test
            public void test1()
            {
                String output = getMethodOutput("main");
                String expect = "ASCII Art: \n___  \n (@ @) \n(  V  )\n -m-m-";

                boolean passed = output.contains("@") && !output.contains("o");
                passed = getResults(expect, output, "changed o to @", passed);
                assertTrue(passed);
            }
            */

            @Test
            public void test2() {
              String output = getMethodOutput("main");
              String expect = "___  \n (@ @) \n(  V  )\n -m-m-";

              if (output.contains("-m-m-")) {
                int i = output.indexOf("-m-m-") + "-m-m-".length();
                output = output.substring(i);
              }

              String[] lines = output.split("\n");

              boolean passed = output.length() >= 10 && lines.length >= 3;

              passed =
                  getResults(
                      "Your art", output, "added your own ascii art (should be at least 3 x 3)", passed);
              assertTrue(passed);
            }

            @Test
            public void test3() {
              String expect = "asciiArt[#][#] = \"@\"";
              String code = getCode();
              int num = countOccurencesRegex(code, expect);

              boolean passed = num >= 2;

              getResults("2", "" + num, "Number of asciiArt[#][#] = \"@\" lines in code", passed);

              assertTrue(passed);
            }
          }

          ]]>
        </tests>
      </program>
    </project>
  </subsection>

  <subsection xml:id="summary-38">
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 4.11.A.1) A <term>2D array</term> is stored as an array of
            arrays. Therefore, the way 2D arrays are created and indexed is
            similar to 1D array objects. The size of a 2D array is established
            at the time of creation and cannot be changed. 2D arrays can store
            either primitive data or object reference data. Nonrectangular 2D
            array objects (with varying column length for each row) are outside
            the scope of the AP Computer Science A course and exam.
          </p>
        </li>

        <li>
          <p>
            2D arrays are declared and created with the following syntax:
            <c>datatype[][] variableName = new
            datatype[numberRows][numberCols]</c>;
          </p>
        </li>

        <li>
          <p>
            (AP 4.11.A.2) When a 2D array is created using the keyword
            <c>new</c>, all of its elements are initialized to the default
            values for the element data type. The default value for <c>int</c>
            is <c>0</c>, for <c>double</c> is <c>0.0</c>, for <c>boolean</c> is
            <c>false</c>, and for a reference type is <c>null</c>.
          </p>
        </li>

        <li>
          <p>
            (AP 4.11.A.3) The initializer list used to create and initialize a
            2D array consists of initializer lists that represent 1D arrays; for
            example, <c>int[][] arr2D = { {1, 2, 3}, {4, 5, 6} };</c>.
          </p>
        </li>

        <li>
          <p>
            (AP 4.11.A.4) The square brackets <c>[row][col]</c> are used to
            access and modify an element in a 2D array. For the purposes of the
            AP exam, when accessing the element at <c>arr[first][second]</c>,
            the <c>first</c> index is used for rows, the <c>second</c> index is
            used for columns.
          </p>
        </li>

        <li>
          <p>
            <term>Row-major order</term> refers to an ordering of 2D array
            elements where traversal occurs across each row, while
            <term>column-major order</term> traversal occurs down each column.
          </p>
        </li>

        <li>
          <p>
            (AP 4.11.A.5) A single array that is a row of a 2D array can be
            accessed using the 2D array name and a single set of square brackets
            containing the row index.
          </p>
        </li>

        <li>
          <p>
            (AP 4.11.A.6) The number of rows contained in a 2D array can be
            accessed through the <c>length</c> attribute. The valid row index
            values for a 2D array are <c>0</c> through one less than the number
            of rows or the length of the array, inclusive. The number of columns
            contained in a 2D array can be accessed through the <c>length</c>
            attribute of one of the rows. The valid column index values for a 2D
            array are <c>0</c> through one less than the number of columns or
            the length of any given row of the array, inclusive. For example,
            given a 2D array named <c>values</c>, the number of rows is
            <c>values.length</c> and the number of columns is
            <c>values[0].length`</c>. Using an index value outside of these
            ranges will result in an <c>ArrayIndexOutOfBoundsException</c>.
          </p>
        </li>
      </ul>
    </p>
  </subsection>

  <subsection xml:id="nested-loops">
    <title>Nested Loops</title>

    <idx><h>2D Array</h><h>traversal</h></idx>
    <idx><h>loop</h><h>nested</h></idx>
    <idx>traversal</idx>
    <idx>nested loops</idx>
    <p>
      Nested iteration statements (loops) are used to traverse and access all or
      an ordered sequence of elements in a 2D array. Since 2D arrays are stored
      as arrays of arrays, the way 2D arrays are traversed using <c>for</c>
      loops and enhanced <c>for</c> loops is similar to 1D array objects.
    </p>

    <p>
      Here is an example of a <term>nested for loop</term> (one loop inside of
      another loop) to loop/traverse through all of the elements of a 2D array.
    </p>

    <program>
      <![CDATA[

      int[][] array = { {1,2,3},{4,5,6}};
      for (int row = 0; row < array.length; row++)
      {
          for (int col = 0; col < array[0].length; col++)
          {
               System.out.println( array[row][col] );
          }
       }

      ]]>
    </program>

    <activity label="lcgetAverage">
      <statement>
        <p>
          What does the following code do? Add another row of numbers to the
          matrix. Will the loops traverse this row too? Use the CodeLens button
          to trace through the code. Note that an array can be passed in as an
          argument to a method.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class Test1 {

            public static double getAverage(int[][] a) {
              double total = 0;
              int value = 0;
              for (int row = 0; row < a.length; row++) {
                for (int col = 0; col < a[0].length; col++) {
                  value = a[row][col];
                  total = total + value;
                }
              }
              return total / (a.length * a[0].length);
            }

            public static void main(String[] args) {
              int[][] matrix = {{1, 2, 3}, {4, 5, 6}};
              System.out.println(getAverage(matrix));
            }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {

            @Test
            public void test1() {
              String output = getMethodOutput("main");
              String expected = "3.5";

              boolean passed = !output.contains(expected);

              passed = getResults("true", "" + passed, "Average has changed");
              assertTrue(passed);
            }

            @Test
            public void test2() {
              String code = getCode();
              String expected = "int[][] matrix = { {1,2,3},{4,5,6}};";

              boolean passed = !code.replaceAll(" ", "").contains(expected.replaceAll(" ", ""));

              passed = getResults("true", "" + passed, "Matrix has been changed");
              assertTrue(passed);
            }
          }
        </tests>
      </program>
    </activity>

    <p>Some key things to notice about this code are:</p>

    <p>
      <ul>
        <li>
          <p>
            <c>total</c> is declared to be a double so that the result will be a
            double. If <c>total</c> was declared to be an <c>int</c> then the
            result would be an integer and the values after the decimal point
            would be thrown away.
          </p>
        </li>

        <li>
          <p>The array is passed in as an argument to the method.</p>
        </li>

        <li>
          <p>The number of rows is <c>a.length</c></p>
        </li>

        <li>
          <p>The number of columns is <c>a[0].length</c></p>
        </li>

        <li>
          <p>
            The number of times this loop executes is the number of rows times
            the number of columns.
          </p>
        </li>
      </ul>
    </p>
  </subsection>

  <subsection xml:id="row-major-and-column-major-traversals">
    <title>Row-Major and Column-Major Traversals</title>

    <p>
      Nested iteration statements can be written to traverse the 2D array in
      row-major order, column-major order, or a uniquely defined order.
      <term>Row-major order</term> refers to an ordering of 2D array elements
      where traversal occurs across each row (and is more common), whereas
      <term>column-major order</term> traversal occurs down each column. Here’s
      an example of nested loops that traverse the 2D array in column-major
      order.
    </p>

    <activity label="ColumnMajorTraversal">
      <statement>
        <p>
          What will the following code print out? Try to guess before you run
          it.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class ColumnMajorTraversal {
            public static void main(String[] args) {
              int[][] array = {{1, 2, 3}, {4, 5, 6}};
              for (int col = 0; col < array[0].length; col++) {
                for (int row = 0; row < array.length; row++) {
                  System.out.println(array[row][col]);
                }
              }
            }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            @Test
            public void test1() {
              String output = getMethodOutput("main");
              String expected = "1\n4\n2\n5\n3\n6";

              boolean passed = getResults(expected, output, "main()", true);
              assertTrue(passed);
            }
          }
        </tests>
      </program>
    </activity>

    <activity label="AP-2DArrays">
      <statement>
        <p>
          Consider the following code segment. What is the last row of numbers
          printed when this code segment is executed?
        </p>

        <program>
          <![CDATA[

          int[][] points = { {11, 12, 13, 14, 15},
                              {21, 22, 23, 24, 25},
                              {31, 32, 33, 34, 35},
                              {41, 42, 43, 44, 45}};
           for (int row = 0; row < points.length; row++)
           {
               for (int col = points[0].length - 1; col >= row; col--)
               {
                    System.out.print(points[row][col] + " ");
               }
               System.out.println();
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>45 44 43 42 41</p>
          </statement>

          <feedback>
            <p>
              Trace through the code. Notice that the inner loop stops at index
              row.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>45</p>
          </statement>

          <feedback>
            <p>
              Trace through the code. Notice that the inner loop stops at index
              row.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>41 42</p>
          </statement>

          <feedback>
            <p>
              Trace through the code. Notice that the inner loop works through
              the row backwards.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>45 44</p>
          </statement>

          <feedback>
            <p>Correct!</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>44 45</p>
          </statement>

          <feedback>
            <p>
              Trace through the code. Notice that the inner loop works through
              the row backwards.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="enhanced-for-each-loop-for-2d-arrays">
    <title>Enhanced For-Each Loop for 2D Arrays</title>

    <idx><h>2D Array</h><h>for-each loop</h></idx>
    <idx>enhanced for loop</idx>
    <p>
      Since 2D arrays are really arrays of arrays you can also use a nested
      enhanced for (for each) loop to loop through all elements in an array.
      Enhanced for loops are much simpler to use since you don’t have to use the
      indices and the []’s, but you can only use them if you are not going to
      change the values in an array of primitive types since the variable
      <c>val</c> below will not change the original array.
    </p>

    <program>
      String[][] array;
      // Nested For-each loops that traverse a 2D String array
      for (String[] innerArray : array)
      {
         for (String val : innerArray)
         {
             System.out.println(val);
         }
      }
    </program>

    <p>
      Memorize this pattern. The outer loop of a nested enhanced <c>for</c> loop
      used to traverse a 2D array traverses the rows. Therefore, the enhanced
      <c>for</c> loop variable must be the type of each row, which is a 1D array
      (<c>String[] innerArray</c> in the outer loop in the example above). The
      inner loop traverses a single row. Therefore, the inner enhanced
      <c>for</c> loop variable must be the same type as the elements stored in
      the 1D array (<c>String val</c> in the inner loop in the example above).
      The type of the variables in the for-each loops must match the type of the
      array.
    </p>

    <p>
      It is important to remember the limitations of enhanced <c>for</c> loops.
      They cannot change the array. Assigning a new value to the enhanced
      <c>for</c> loop variable (<c>val</c> above) does not change the value
      stored in the array.
    </p>

    <activity label="getAvgForEach">
      <statement>
        <p>
          Nested for-each loops demo. Click on the CodeLens button to trace
          through the code.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class Average {

            public static double getAvg(int[][] a) {
              double total = 0;
              for (int[] innerArray : a) {
                for (int val : innerArray) {
                  total = total + val;
                }
              }
              return total / (a.length * a[0].length);
            }

            public static void main(String[] args) {
              int[][] theArray = {{80, 90, 70}, {20, 80, 75}};
              System.out.println(getAvg(theArray));
            }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            @Test
            public void testMain() throws IOException {
              String output = getMethodOutput("main");
              String expect = "69.16666666666667";
              boolean passed = getResults(expect, output, "Expected output from main", true);
              assertTrue(passed);
            }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="summary-39">
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 4.12.A.1) Nested iteration statements (loops) are used to
            traverse and access all or an ordered sequence of elements in a 2D
            array. Since 2D arrays are stored as arrays of arrays, the way 2D
            arrays are traversed using <c>for</c> loops and enhanced <c>for</c>
            loops is similar to 1D array objects.
          </p>
        </li>

        <li>
          <p>
            (AP 4.12.A.1) Nested iteration statements can be written to traverse
            the 2D array in row-major order, column-major order, or a uniquely
            defined order. <term>Row-major order</term> refers to an ordering of
            2D array elements where traversal occurs across each row, whereas
            <term>column-major order</term> traversal occurs down each column.
          </p>
        </li>

        <li>
          <p>
            (AP 4.12.A.2) The outer loop of a nested enhanced <c>for</c> loop
            used to traverse a 2D array traverses the rows. Therefore, the
            enhanced <c>for</c> loop variable must be the type of each row,
            which is a 1D array. The inner loop traverses a single row.
            Therefore, the inner enhanced <c>for</c> loop variable must be the
            same type as the elements stored in the 1D array. Assigning a new
            value to the enhanced <c>for</c> loop variable does not change the
            value stored in the array.
          </p>
        </li>

        <li>
          <p>
            The 2D array’s length gives the number of rows. A row’s length
            array[0].length gives the number of columns.
          </p>
        </li>
      </ul>
    </p>
  </subsection>

  <subsection xml:id="ap-practice-24">
    <title>AP Practice</title>

    <activity label="AP-2DArrays2">
      <statement>
        <p>
          Consider the following code segment. What is the value of sum as a
          result of executing the code segment?
        </p>

        <program>
          <![CDATA[

          int[][] arr = { {1, 2, 3, 4},
                          {5, 6, 7, 8},
                          {9, 10, 11, 12} };
          int sum = 0;
          for (int[] x : arr)
          {
              for (int y = 0; y < x.length - 1; y++)
              {
                   sum += x[y];
              }
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>36</p>
          </statement>

          <feedback>
            <p>Trace through the code.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>54</p>
          </statement>

          <feedback>
            <p>Correct!</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>63</p>
          </statement>

          <feedback>
            <p>Trace through the code.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>68</p>
          </statement>

          <feedback>
            <p>Trace through the code.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>78</p>
          </statement>

          <feedback>
            <p>
              Notice that the inner loop goes up to but not including x.length -
              1.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <hidden>
      <datafile label="arch" filename="arch.jpg">
        <image source="_static/arch.jpg" />
      </datafile>

      <datafile label="pictureLab" filename="pictureLab.jar" editable="no" hide="yes">
        <pre>

        import java.awt.Image;
        import java.awt.image.BufferedImage;

        /**
         * Interface to describe a digital picture.  A digital picture can have an
         * associated file name.  It can have a title.  It has pixels
         * associated with it and you can get and set the pixels.  You
         * can get an Image from a picture or a BufferedImage.  You can load
         * it from a file name or image.  You can show a picture.  You can
         * explore a picture.  You can create a new image for it.
         *
         * @author Barb Ericson ericson@cc.gatech.edu
         */
        public interface DigitalPicture
        {
          public String getFileName(); // get the file name that the picture came from
          public String getTitle(); // get the title of the picture
          public void setTitle(String title); // set the title of the picture
          public int getWidth(); // get the width of the picture in pixels
          public int getHeight(); // get the height of the picture in pixels
          public Image getImage(); // get the image from the picture
          public BufferedImage getBufferedImage(); // get the buffered image
          public int getBasicPixel(int x, int y); // get the pixel information as an int
          public void setBasicPixel(int x, int y, int rgb); // set the pixel information
          public Pixel getPixel(int x, int y); // get the pixel information as an object
          public Pixel[] getPixels(); // get all pixels in row-major order
          public Pixel[][] getPixels2D(); // get 2-D array of pixels in row-major order
          public void load(Image image); // load the image into the picture
          public boolean load(String fileName); // load the picture from a file
          public void show(); // show the picture
          public boolean write(String fileName); // write out a file
        }

        import java.awt.Color;

        /**
         * Class that references a pixel in a picture. Pixel
         * stands for picture element where picture is
         * abbreviated pix.  A pixel has a column (x) and
         * row (y) location in a picture.  A pixel knows how
         * to get and set the red, green, blue, and alpha
         * values in the picture.  A pixel also knows how to get
         * and set the color using a Color object.
         *
         * @author Barb Ericson ericson@cc.gatech.edu
         */
        public class Pixel
        {

          ////////////////////////// fields ///////////////////////////////////

          /** the digital picture this pixel belongs to */
          private DigitalPicture picture;

          /** the x (column) location of this pixel in the picture; (0,0) is top left */
          private int x;

          /** the y (row) location of this pixel in the picture; (0,0) is top left */
          private int y;

          ////////////////////// constructors /////////////////////////////////

          /**
           * A constructor that takes the x and y location for the pixel and
           * the picture the pixel is coming from
           * @param picture the picture that the pixel is in
           * @param x the x location of the pixel in the picture
           * @param y the y location of the pixel in the picture
           */
          public Pixel(DigitalPicture picture, int x, int y)
          {
            // set the picture
            this.picture = picture;

            // set the x location
            this.x = x;

            // set the y location
            this.y = y;

          }

          ///////////////////////// methods //////////////////////////////

          /**
           * Method to get the x location of this pixel.
           * @return the x location of the pixel in the picture
           */
          public int getX() { return x; }

          /**
           * Method to get the y location of this pixel.
           * @return the y location of the pixel in the picture
           */
          public int getY() { return y; }

          /**
           * Method to get the row (y value)
           * @return the row (y value) of the pixel in the picture
           */
          public int getRow() { return y; }

          /**
           * Method to get the column (x value)
           * @return the column (x value) of the pixel
           */
          public int getCol() { return x; }

          /**
           * Method to get the amount of alpha (transparency) at this pixel.
           * It will be from 0-255.
           * @return the amount of alpha (transparency)
           */
          public int getAlpha() {

            /* get the value at the location from the picture as a 32 bit int
             * with alpha, red, green, blue each taking 8 bits from left to right
             */
            int value = picture.getBasicPixel(x,y);

            // get the alpha value (starts at 25 so shift right 24)
            // then and it with all 1's for the first 8 bits to keep
            // end up with from 0 to 255
            int alpha = (value &gt;&gt; 24) &amp; 0xff;

            return alpha;
          }

          /**
           * Method to get the amount of red at this pixel.  It will be
           * from 0-255 with 0 being no red and 255 being as much red as
           * you can have.
           * @return the amount of red from 0 for none to 255 for max
           */
          public int getRed() {

            /* get the value at the location from the picture as a 32 bit int
             * with alpha, red, green, blue each taking 8 bits from left to right
             */
            int value = picture.getBasicPixel(x,y);

            // get the red value (starts at 17 so shift right 16)
            // then AND it with all 1's for the first 8 bits to
            // end up with a resulting value from 0 to 255
            int red = (value &gt;&gt; 16) &amp; 0xff;

            return red;
          }

          /**
           * Method to get the red value from a pixel represented as an int
           * @param value the color value as an int
           * @return the amount of red
           */
          public static int getRed(int value)
          {
            int red = (value &gt;&gt; 16) &amp; 0xff;
            return red;
          }

          /**
           * Method to get the amount of green at this pixel.  It will be
           * from 0-255 with 0 being no green and 255 being as much green as
           * you can have.
           * @return the amount of green from 0 for none to 255 for max
           */
          public int getGreen() {

            /* get the value at the location from the picture as a 32 bit int
             * with alpha, red, green, blue each taking 8 bits from left to right
             */
            int value = picture.getBasicPixel(x,y);

            // get the green value (starts at 9 so shift right 8)
            int green = (value &gt;&gt;  8) &amp; 0xff;

            return green;
          }

          /**
           * Method to get the green value from a pixel represented as an int
           * @param value the color value as an int
           * @return the amount of green
           */
          public static int getGreen(int value)
          {
            int green = (value &gt;&gt; 8) &amp; 0xff;
            return green;
          }

          /**
           * Method to get the amount of blue at this pixel.  It will be
           * from 0-255 with 0 being no blue and 255 being as much blue as
           * you can have.
           * @return the amount of blue from 0 for none to 255 for max
           */
          public int getBlue() {

            /* get the value at the location from the picture as a 32 bit int
             * with alpha, red, green, blue each taking 8 bits from left to right
             */
            int value = picture.getBasicPixel(x,y);

            // get the blue value (starts at 0 so no shift required)
            int blue = value &amp; 0xff;

            return blue;
          }

          /**
           * Method to get the blue value from a pixel represented as an int
           * @param value the color value as an int
           * @return the amount of blue
           */
          public static int getBlue(int value)
          {
            int blue = value &amp; 0xff;
            return blue;
          }

          /**
           * Method to get a color object that represents the color at this pixel.
           * @return a color object that represents the pixel color
           */
          public Color getColor()
          {
             /* get the value at the location from the picture as a 32 bit int
             * with alpha, red, green, blue each taking 8 bits from left to right
             */
            int value = picture.getBasicPixel(x,y);

            // get the red value (starts at 17 so shift right 16)
            // then AND it with all 1's for the first 8 bits to
            // end up with a resulting value from 0 to 255
            int red = (value &gt;&gt; 16) &amp; 0xff;

            // get the green value (starts at 9 so shift right 8)
            int green = (value &gt;&gt;  8) &amp; 0xff;

            // get the blue value (starts at 0 so no shift required)
            int blue = value &amp; 0xff;

            return new Color(red,green,blue);
          }

          /**
           * Method to set the pixel color to the passed in color object.
           * @param newColor the new color to use
           */
          public void setColor(Color newColor)
          {
            // set the red, green, and blue values
            int red = newColor.getRed();
            int green = newColor.getGreen();
            int blue = newColor.getBlue();

            // update the associated picture
            updatePicture(this.getAlpha(),red,green,blue);
          }

          /**
           * Method to update the picture based on the passed color
           * values for this pixel
           * @param alpha the alpha (transparency) at this pixel
           * @param red the red value for the color at this pixel
           * @param green the green value for the color at this pixel
           * @param blue the blue value for the color at this pixel
           */
          public void updatePicture(int alpha, int red, int green, int blue)
          {
            // create a 32 bit int with alpha, red, green blue from left to right
            int value = (alpha &lt;&lt; 24) + (red &lt;&lt; 16) + (green &lt;&lt; 8) + blue;

            // update the picture with the int value
            picture.setBasicPixel(x,y,value);
          }

          /**
           * Method to correct a color value to be within 0 to 255
           * @param the value to use
           * @return a value within 0 to 255
           */
          private static int correctValue(int value)
          {
            if (value &lt; 0)
              value = 0;
            if (value &gt; 255)
              value = 255;
            return value;
          }

          /**
           * Method to set the red to a new red value
           * @param value the new value to use
           */
          public void setRed(int value)
          {
            // set the red value to the corrected value
            int red = correctValue(value);

            // update the pixel value in the picture
            updatePicture(getAlpha(), red, getGreen(), getBlue());
          }

          /**
           * Method to set the green to a new green value
           * @param value the value to use
           */
          public void setGreen(int value)
          {
            // set the green value to the corrected value
            int green = correctValue(value);

            // update the pixel value in the picture
            updatePicture(getAlpha(), getRed(), green, getBlue());
          }

          /**
           * Method to set the blue to a new blue value
           * @param value the new value to use
           */
          public void setBlue(int value)
          {
            // set the blue value to the corrected value
            int blue = correctValue(value);

            // update the pixel value in the picture
            updatePicture(getAlpha(), getRed(), getGreen(), blue);
          }

           /**
           * Method to set the alpha (transparency) to a new alpha value
           * @param value the new value to use
           */
          public void setAlpha(int value)
          {
            // make sure that the alpha is from 0 to 255
            int alpha = correctValue(value);

            // update the associated picture
            updatePicture(alpha, getRed(), getGreen(), getBlue());
          }

          /**
          * Method to get the distance between this pixel's color and the passed color
          * @param testColor the color to compare to
          * @return the distance between this pixel's color and the passed color
          */
         public double colorDistance(Color testColor)
         {
           double redDistance = this.getRed() - testColor.getRed();
           double greenDistance = this.getGreen() - testColor.getGreen();
           double blueDistance = this.getBlue() - testColor.getBlue();
           double distance = Math.sqrt(redDistance * redDistance +
                                       greenDistance * greenDistance +
                                       blueDistance * blueDistance);
           return distance;
         }

         /**
          * Method to compute the color distances between two color objects
          * @param color1 a color object
          * @param color2 a color object
          * @return the distance between the two colors
          */
         public static double colorDistance(Color color1,Color color2)
         {
           double redDistance = color1.getRed() - color2.getRed();
           double greenDistance = color1.getGreen() - color2.getGreen();
           double blueDistance = color1.getBlue() - color2.getBlue();
           double distance = Math.sqrt(redDistance * redDistance +
                                       greenDistance * greenDistance +
                                       blueDistance * blueDistance);
           return distance;
         }

         /**
          * Method to get the average of the colors of this pixel
          * @return the average of the red, green, and blue values
          */
         public double getAverage()
         {
           double average = (getRed() + getGreen() + getBlue()) / 3.0;
           return average;
         }

          /**
           * Method to return a string with information about this pixel
           * @return a string with information about this pixel
           */
          public String toString()
          {
            return "Pixel row=" + getRow() +
              " col=" + getCol() +
              " red=" + getRed() +
              " green=" + getGreen() +
              " blue=" + getBlue();
          }

        }

        import javax.imageio.ImageIO;
        import java.awt.image.BufferedImage;
        import javax.swing.ImageIcon;
        import java.awt.*;
        import java.io.*;
        import java.awt.geom.*;

        import java.io.ByteArrayOutputStream;
        //import javax.xml.bind.DatatypeConverter;
        import java.util.Base64;

        import java.util.Scanner;

        /**
         * A class that represents a simple picture.  A simple picture may have
         * an associated file name and a title.  A simple picture has pixels,
         * width, and height.  A simple picture uses a BufferedImage to
         * hold the pixels. You can also explore a simple picture.
         *
         * @author Barb Ericson ericson@cc.gatech.edu
         */
        public class SimplePicture implements DigitalPicture
        {

          /////////////////////// Fields /////////////////////////

          /**
           * the file name associated with the simple picture
           */
          private String fileName;

          /**
           * the path name for the file
           */
          private String pathName;

          /**
           * the title of the simple picture
           */
          private String title;

          /**
           * buffered image to hold pixels for the simple picture
           */
          private BufferedImage bufferedImage;

          /**
           * extension for this file (jpg or bmp)
           */
          private String extension;


         /////////////////////// Constructors /////////////////////////

         /**
          * A Constructor that takes no arguments.  It creates a picture with
          * a width of 200 and a height of 100 that is all white.
          * A no-argument constructor must be given in order for a class to
          * be able to be subclassed.  By default all subclasses will implicitly
          * call this in their parent's no-argument constructor unless a
          * different call to super() is explicitly made as the first line
          * of code in a constructor.
          */
         public SimplePicture()
         {this(200,100);}

         /**
          * A Constructor that takes a file name and uses the file to create
          * a picture
          * @param fileName the file name to use in creating the picture
          */
         public SimplePicture(String fileName)
         {

           // load the picture into the buffered image
           load(fileName);

         }

         /**
          * A constructor that takes the width and height desired for a picture and
          * creates a buffered image of that size.  This constructor doesn't
          * show the picture.  The pixels will all be white.
          * @param width the desired width
          * @param height the desired height
          */
         public  SimplePicture(int width, int height)
         {
           bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
           title = "None";
           fileName = "None";
           extension = "jpg";
           setAllPixelsToAColor(Color.white);
         }

         /**
          * A constructor that takes the width and height desired for a picture and
          * creates a buffered image of that size.  It also takes the
          * color to use for the background of the picture.
          * @param width the desired width
          * @param height the desired height
          * @param theColor the background color for the picture
          */
         public  SimplePicture(int width, int height, Color theColor)
         {
           this(width,height);
           setAllPixelsToAColor(theColor);
         }

         /**
          * A Constructor that takes a picture to copy information from
          * @param copyPicture the picture to copy from
          */
         public SimplePicture(SimplePicture copyPicture)
         {
           if (copyPicture.fileName != null)
           {
              this.fileName = new String(copyPicture.fileName);
              this.extension = copyPicture.extension;
           }
           if (copyPicture.title != null)
              this.title = new String(copyPicture.title);
           if (copyPicture.bufferedImage != null)
           {
             this.bufferedImage = new BufferedImage(copyPicture.getWidth(),  copyPicture.getHeight(), BufferedImage.TYPE_INT_RGB);
             this.copyPicture(copyPicture);
           }
         }

         /**
          * A constructor that takes a buffered image
          * @param image the buffered image
          */
         public SimplePicture(BufferedImage image)
         {
           this.bufferedImage = image;
           title = "None";
           fileName = "None";
           extension = "jpg";
         }

         ////////////////////////// Methods //////////////////////////////////

         /**
          * Method to get the extension for this picture
          * @return the extension (jpg, bmp, giff, etc)
          */
         public String getExtension() { return extension; }

         /**
          * Method that will copy all of the passed source picture into
          * the current picture object
          * @param sourcePicture  the picture object to copy
          */
         public void copyPicture(SimplePicture sourcePicture)
         {
           Pixel sourcePixel = null;
           Pixel targetPixel = null;

           // loop through the columns
           for (int sourceX = 0, targetX = 0;
                sourceX &lt; sourcePicture.getWidth() &amp;&amp;
                targetX &lt; this.getWidth();
                sourceX++, targetX++)
           {
             // loop through the rows
             for (int sourceY = 0, targetY = 0;
                  sourceY &lt; sourcePicture.getHeight() &amp;&amp;
                  targetY &lt; this.getHeight();
                  sourceY++, targetY++)
             {
               sourcePixel = sourcePicture.getPixel(sourceX,sourceY);
               targetPixel = this.getPixel(targetX,targetY);
               targetPixel.setColor(sourcePixel.getColor());
             }
           }

         }

         /**
          * Method to set the color in the picture to the passed color
          * @param color the color to set to
          */
         public void setAllPixelsToAColor(Color color)
         {
           // loop through all x
           for (int x = 0; x &lt; this.getWidth(); x++)
           {
             // loop through all y
             for (int y = 0; y &lt; this.getHeight(); y++)
             {
               getPixel(x,y).setColor(color);
             }
           }
         }

         /**
          * Method to get the buffered image
          * @return the buffered image
          */
         public BufferedImage getBufferedImage()
         {
            return bufferedImage;
         }

         /**
          * Method to get a graphics object for this picture to use to draw on
          * @return a graphics object to use for drawing
          */
         public Graphics getGraphics()
         {
           return bufferedImage.getGraphics();
         }

         /**
          * Method to get a Graphics2D object for this picture which can
          * be used to do 2D drawing on the picture
          */
         public Graphics2D createGraphics()
         {
           return bufferedImage.createGraphics();
         }

         /**
          * Method to get the file name associated with the picture
          * @return  the file name associated with the picture
          */
         public String getFileName() { return fileName; }

         /**
          * Method to set the file name
          * @param name the full pathname of the file
          */
         public void setFileName(String name)
         {
           fileName = name;
         }

         /**
          * Method to get the title of the picture
          * @return the title of the picture
          */
         public String getTitle()
         { return title; }

         /**
          * Method to set the title for the picture
          * @param title the title to use for the picture
          */
         public void setTitle(String title)
         {
           this.title = title;
         }

         /**
          * Method to get the width of the picture in pixels
          * @return the width of the picture in pixels
          */
         public int getWidth() { return bufferedImage.getWidth(); }

         /**
          * Method to get the height of the picture in pixels
          * @return  the height of the picture in pixels
          */
         public int getHeight() { return bufferedImage.getHeight(); }

         /**
          * Method to get an image from the picture
          * @return  the buffered image since it is an image
          */
         public Image getImage()
         {
           return bufferedImage;
         }

         /**
          * Method to return the pixel value as an int for the given x and y location
          * @param x the x coordinate of the pixel
          * @param y the y coordinate of the pixel
          * @return the pixel value as an integer (alpha, red, green, blue)
          */
         public int getBasicPixel(int x, int y)
         {
            return bufferedImage.getRGB(x,y);
         }

         /**
          * Method to set the value of a pixel in the picture from an int
          * @param x the x coordinate of the pixel
          * @param y the y coordinate of the pixel
          * @param rgb the new rgb value of the pixel (alpha, red, green, blue)
          */
         public void setBasicPixel(int x, int y, int rgb)
         {
           bufferedImage.setRGB(x,y,rgb);
         }

         /**
          * Method to get a pixel object for the given x and y location
          * @param x  the x location of the pixel in the picture
          * @param y  the y location of the pixel in the picture
          * @return a Pixel object for this location
          */
         public Pixel getPixel(int x, int y)
         {
           // create the pixel object for this picture and the given x and y location
           Pixel pixel = new Pixel(this,x,y);
           return pixel;
         }

         /**
          * Method to get a one-dimensional array of Pixels for this simple picture
          * @return a one-dimensional array of Pixel objects starting with y=0
          * to y=height-1 and x=0 to x=width-1.
          */
         public Pixel[] getPixels()
         {
           int width = getWidth();
           int height = getHeight();
           Pixel[] pixelArray = new Pixel[width * height];

           // loop through height rows from top to bottom
           for (int row = 0; row &lt; height; row++)
             for (int col = 0; col &lt; width; col++)
               pixelArray[row * width + col] = new Pixel(this,col,row);

           return pixelArray;
         }

         /**
          * Method to get a two-dimensional array of Pixels for this simple picture
          * @return a two-dimensional array of Pixel objects in row-major order.
          */
         public Pixel[][] getPixels2D()
         {
           int width = getWidth();
           int height = getHeight();
           Pixel[][] pixelArray = new Pixel[height][width];

           // loop through height rows from top to bottom
           for (int row = 0; row &lt; height; row++)
             for (int col = 0; col &lt; width; col++)
               pixelArray[row][col] = new Pixel(this,col,row);

           return pixelArray;
         }

         /**
          * Method to load the buffered image with the passed image
          * @param image  the image to use
          */
         public void load(Image image)
         {
           // get a graphics context to use to draw on the buffered image
           Graphics2D graphics2d = bufferedImage.createGraphics();

           // draw the image on the buffered image starting at 0,0
           graphics2d.drawImage(image,0,0,null);

           // show the new image
           show();
         }

         /**
          * Method to show the picture in a picture frame
          */
         public void show()
         {
             try {
                 ByteArrayOutputStream output = new ByteArrayOutputStream();
                 ImageIO.write(this.bufferedImage, "png", output);
                 String result = Base64.getEncoder().encodeToString(output.toByteArray());
                 //BH: using Base64 instead of DatatypeConverter.printBase64Binary(output.toByteArray());
                 System.out.println("&amp;lt;img src=\'data:image/" + this.extension + ";base64," + result + "\'/&gt;");
             } catch (IOException e) {
                 System.out.println("Errors occured in image conversion");
             }
         }

         /**
          * Method to open a picture explorer on a copy (in memory) of this
          * simple picture
          */
         /*
         public void explore()
         {
           // create a copy of the current picture and explore it
           new PictureExplorer(new SimplePicture(this));
         }
         */

         /**
          * Method to load the picture from the passed file name
          * @param fileName the file name to use to load the picture from
          * @throws IOException if the picture isn't found
          */
         public void loadOrFail(String fileName) throws IOException
         {
            // set the current picture's file name
           this.fileName = fileName;

           // set the extension
           int posDot = fileName.lastIndexOf('.');
           if (posDot &gt;= 0)
             this.extension = fileName.substring(posDot + 1);

            // get file location
            String[] paths = fileName.split("/");
            this.pathName = "";
            if(paths.length != 1) {
                for(int i = 0; i &lt; paths.length - 1; i++) {
                    this.pathName = this.pathName + paths[i] + "/";
                }
            }
           // if the current title is null use the file name
           if (title == null)
             title = fileName;

           File file = new File(this.fileName);


           if (!file.canRead())
           {
             throw new IOException(this.fileName +
                                 " could not be opened. Check that you specified the path");
           }
           this.bufferedImage = ImageIO.read(file);


         }

         /**
          * Method to read the contents of the picture from a filename
          * without throwing errors
          * @param fileName the name of the file to write the picture to
          * @return true if success else false
          */
         public boolean load(String fileName)
         {
             try {
                 this.loadOrFail(fileName);
                 return true;

             } catch (Exception ex) {
                 System.out.println("There was an error trying to open " + fileName);
                 bufferedImage = new BufferedImage(600,200,
                                                   BufferedImage.TYPE_INT_RGB);
                 addMessage("Couldn't load " + fileName,5,100);
                 return false;
             }

         }

         /**
          * Method to load the picture from the passed file name
          * this just calls load(fileName) and is for name compatibility
          * @param fileName the file name to use to load the picture from
          * @return true if success else false
          */
         public boolean loadImage(String fileName)
         {
             return load(fileName);
         }

         /**
          * Method to draw a message as a string on the buffered image
          * @param message the message to draw on the buffered image
          * @param xPos  the x coordinate of the leftmost point of the string
          * @param yPos  the y coordinate of the bottom of the string
          */
         public void addMessage(String message, int xPos, int yPos)
         {
           // get a graphics context to use to draw on the buffered image
           Graphics2D graphics2d = bufferedImage.createGraphics();

           // set the color to white
           graphics2d.setPaint(Color.white);

           // set the font to Helvetica bold style and size 16
           graphics2d.setFont(new Font("Helvetica",Font.BOLD,16));

           // draw the message
           graphics2d.drawString(message,xPos,yPos);

         }

         /**
          * Method to draw a string at the given location on the picture
          * @param text the text to draw
          * @param xPos the left x for the text
          * @param yPos the top y for the text
          */
         public void drawString(String text, int xPos, int yPos)
         {
           addMessage(text,xPos,yPos);
         }

         /**
           * Method to create a new picture by scaling the current
           * picture by the given x and y factors
           * @param xFactor the amount to scale in x
           * @param yFactor the amount to scale in y
           * @return the resulting picture
           */
          public Picture scale(double xFactor, double yFactor)
          {
            // set up the scale transform
            AffineTransform scaleTransform = new AffineTransform();
            scaleTransform.scale(xFactor,yFactor);

            // create a new picture object that is the right size
            Picture result = new Picture((int) (getHeight() * yFactor),
                                         (int) (getWidth() * xFactor));

            // get the graphics 2d object to draw on the result
            Graphics graphics = result.getGraphics();
            Graphics2D g2 = (Graphics2D) graphics;

            // draw the current image onto the result image scaled
            g2.drawImage(this.getImage(),scaleTransform,null);

            return result;
          }

          /**
           * Method to create a new picture of the passed width.
           * The aspect ratio of the width and height will stay
           * the same.
           * @param width the desired width
           * @return the resulting picture
           */
          public Picture getPictureWithWidth(int width)
          {
            // set up the scale transform
            double xFactor = (double) width / this.getWidth();
            Picture result = scale(xFactor,xFactor);
            return result;
          }

          /**
           * Method to create a new picture of the passed height.
           * The aspect ratio of the width and height will stay
           * the same.
           * @param height the desired height
           * @return the resulting picture
           */
          public Picture getPictureWithHeight(int height)
          {
            // set up the scale transform
            double yFactor = (double) height / this.getHeight();
            Picture result = scale(yFactor,yFactor);
            return result;
          }

         /**
          * Method to load a picture from a file name and show it in a picture frame
          * @param fileName the file name to load the picture from
          * @return true if success else false
          */
         public boolean loadPictureAndShowIt(String fileName)
         {
           boolean result = true;  // the default is that it worked

           // try to load the picture into the buffered image from the file name
           result = load(fileName);

           // show the picture in a picture frame
           show();

           return result;
         }

         /**
          * Method to write the contents of the picture to a file with
          * the passed name
          * @param fileName the name of the file to write the picture to
          */
         public void writeOrFail(String fileName) throws IOException
         {
           String extension = this.extension; // the default is current

           // create the file object
           File file = new File(this.pathName + fileName);
           //File fileLoc = file.getParentFile(); // directory name

           // if there is no parent directory use the current media dir
           //if (fileLoc == null)
           //{
             //fileName = FileChooser.getMediaPath(fileName);
             //file = new File(fileName);
             //fileLoc = file.getParentFile();
           //}

           // check that you can write to the directory
           //if (!fileLoc.canWrite()) {
            //    throw new IOException(fileName +
            //    " could not be opened. Check to see if you can write to the directory.");
           //}

           // get the extension
           int posDot = fileName.indexOf('.');
           if (posDot &gt;= 0)
               extension = fileName.substring(posDot + 1);

           // write the contents of the buffered image to the file
           ImageIO.write(bufferedImage, extension, file);

         }

         /**
          * Method to write the contents of the picture to a file with
          * the passed name without throwing errors
          * @param fileName the name of the file to write the picture to
          * @return true if success else false
          */
         public boolean write(String fileName)
         {
             try {
                 this.writeOrFail(fileName);
                 return true;
             } catch (Exception ex) {
                 System.out.println("There was an error trying to write " + fileName);
                 ex.printStackTrace();
                 return false;
             }

         }

          /**
           * Method to get the coordinates of the enclosing rectangle after this
           * transformation is applied to the current picture
           * @return the enclosing rectangle
           */
          public Rectangle2D getTransformEnclosingRect(AffineTransform trans)
          {
            int width = getWidth();
            int height = getHeight();
            double maxX = width - 1;
            double maxY = height - 1;
            double minX, minY;
            Point2D.Double p1 = new Point2D.Double(0,0);
            Point2D.Double p2 = new Point2D.Double(maxX,0);
            Point2D.Double p3 = new Point2D.Double(maxX,maxY);
            Point2D.Double p4 = new Point2D.Double(0,maxY);
            Point2D.Double result = new Point2D.Double(0,0);
            Rectangle2D.Double rect = null;

            // get the new points and min x and y and max x and y
            trans.deltaTransform(p1,result);
            minX = result.getX();
            maxX = result.getX();
            minY = result.getY();
            maxY = result.getY();
            trans.deltaTransform(p2,result);
            minX = Math.min(minX,result.getX());
            maxX = Math.max(maxX,result.getX());
            minY = Math.min(minY,result.getY());
            maxY = Math.max(maxY,result.getY());
            trans.deltaTransform(p3,result);
            minX = Math.min(minX,result.getX());
            maxX = Math.max(maxX,result.getX());
            minY = Math.min(minY,result.getY());
            maxY = Math.max(maxY,result.getY());
            trans.deltaTransform(p4,result);
            minX = Math.min(minX,result.getX());
            maxX = Math.max(maxX,result.getX());
            minY = Math.min(minY,result.getY());
            maxY = Math.max(maxY,result.getY());

            // create the bounding rectangle to return
            rect = new Rectangle2D.Double(minX,minY,maxX - minX + 1, maxY - minY + 1);
            return rect;
          }

          /**
           * Method to get the coordinates of the enclosing rectangle after this
           * transformation is applied to the current picture
           * @return the enclosing rectangle
           */
          public Rectangle2D getTranslationEnclosingRect(AffineTransform trans)
          {
            return getTransformEnclosingRect(trans);
          }

         /**
          * Method to return a string with information about this picture
          * @return a string with information about the picture
          */
         public String toString()
         {
           String output = "Simple Picture, filename " + fileName +
             " height " + getHeight() + " width " + getWidth();
           return output;
         }

        } // end of SimplePicture class
        </pre>
      </datafile>
    </hidden>
  </subsection>

  <subsection>
    <title>Implementing 2D Array Algorithms</title>

    <p>
      All of the array algorithms can be applied to 2D arrays too. There are
      standard algorithms that utilize 2D array traversals to:
    </p>

    <p>
      <ul>
        <li>
          <p>
            determine a minimum or maximum value of all the elements or for a
            designated row, column, or other subsection
          </p>
        </li>

        <li>
          <p>
            compute a sum or average of all the elements or for a designated
            row, column, or other subsection
          </p>
        </li>

        <li>
          <p>
            determine if at least one element has a particular property in the
            entire 2D array or for a designated row, column, or other subsection
          </p>
        </li>

        <li>
          <p>
            determine if all elements of the 2D array or a designated row,
            column, or other subsection have a particular property
          </p>
        </li>

        <li>
          <p>
            determine the number of elements in the 2D array or in a designated
            row, column, or other subsection having a particular property
          </p>
        </li>

        <li>
          <p>access all consecutive pairs of elements</p>
        </li>

        <li>
          <p>
            determine the presence or absence of duplicate elements in the 2D
            array or in a designated row, column, or other subsection
          </p>
        </li>

        <li>
          <p>
            shift or rotate elements in a row left or right or in a column up or
            down
          </p>
        </li>

        <li>
          <p>reverse the order of the elements in a row or column</p>
        </li>
      </ul>
    </p>

    <p>
      Remember that with 1D arrays, many algorithms followed the following
      patterns with a for loop or enhanced for loop.
    </p>

    <program>
      <![CDATA[

      // 1 Dimensional Array Traversal
      for (int value : array)
      {
          if (value ....)
              ...
      }

      for(int i=0; i < array.length; i++)
      {
         if (array[i] ....)
             ...
      }

      ]]>
    </program>

    <p>
      But with 2D arrays, you will need to use nested loops to traverse the rows
      and columns of the 2D array. We often use indexed for loops for this to
      better control the row and column index values, but you can also use
      enhanced for loops.
    </p>

    <program>
      <![CDATA[

      // 2 Dimensional Array Traversal
      for (int row = 0; row < array.length; row++)
      {
          for (int col = 0; col < array[0].length; col++)
          {
              if (array[row][col] ....)
                  ...
          }
      }

      // enhanced for loops
      for (int[] row : array)
      {
          for (int value : row)
          {
              if (value ....)
                  ...
          }
      }

      ]]>
    </program>
  </subsection>

  <subsection xml:id="sum-average-min-max-2d-array-algorithms">
    <title>Sum, Average, Min, Max 2D Array Algorithms</title>

    <p>
      For example, counting and searching algorithms work very similarly in 1D
      and 2D arrays. The following code adds all of the values in a given row.
    </p>

    <activity label="lca2dloopPart">
      <statement>
        <p>
          What will the following code print out? Can you complete the method
          called <c>getTotalForCol</c> that gets the total for a column? To do
          this, you must loop through the rows. The array’s length will tell you
          how many rows you have since it is an array of arrays, while the
          length of the array’s first element will tell you how many columns.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class Total {

            public static int getTotalForRow(int row, int[][] a) {
              int total = 0;
              for (int col = 0; col < a[0].length; col++) {
                total = total + a[row][col];
              }
              return total;
            }

            // Complete the method getTotalForCol below
            public static int getTotalForCol(int col, int[][] a) {
              int total = 0;
              // Add a loop here to total a column col

              return total;
            }

            public static void main(String[] args) {
              int[][] matrix = {{1, 2, 3}, {4, 5, 6}};
              System.out.println(getTotalForRow(0, matrix));
              System.out.println(getTotalForCol(0, matrix));
            }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("Total");
            }

            @Test
            public void testMain() throws IOException {
              String output = getMethodOutput("main");
              String expect = "6\n5";
              boolean passed = getResults(expect, output, "Expected output from main");
              assertTrue(passed);
            }

            @Test
            public void test2() {
              int[][] array = {{1, 4, 8}, {6, 7, 9}};
              int value = 0;
              Object[] args = {value, array};

              String output = getMethodOutput("getTotalForCol", args);
              String expect = "7";

              boolean passed =
                  getResults(expect, output, "Testing getTotalForCol(0, { {1, 4,8},{6, 7, 9} })");
              assertTrue(passed);
            }
          }
        </tests>
      </program>
    </activity>

    <activity label="max2DArrayParsons" numbered="yes" adaptive="yes" indentation="show" language="java">
      <statement>
        <p>
          The following has the correct code to find the largest value in a 2D
          array. Drag the blocks from the left into the correct order on the
          right. Check your solution by clicking on the Check button. You will
          be told if any of the blocks are in the wrong order.
        </p>
      </statement>

      <blocks>
        <block order="3">
          <cline>public int getLargest(int[][] arr)</cline>
          <cline>{</cline>
        </block>

        <block order="7">
          <cline> int largest = arr[0][0];</cline>
          <cline> int current = 0;</cline>
          <cline> for(int r=0;r &lt; arr.length;r++)</cline>
          <cline> {</cline>
          <cline></cline>
        </block>

        <block order="2">
          <cline>   for(int c=0;c &lt; arr[0].length;c++)</cline>
          <cline>   {</cline>
          <cline></cline>
        </block>

        <block order="8">
          <cline>     current = arr[r][c];</cline>
          <cline>     if (current &gt; largest)</cline>
          <cline>     {</cline>
          <cline></cline>
        </block>

        <block order="9">
          <cline>       largest = current;</cline>
          <cline></cline>
        </block>

        <block order="1">
          <cline>     } // end if</cline>
          <cline></cline>
        </block>

        <block order="5">
          <cline>   } // end column loop</cline>
          <cline></cline>
        </block>

        <block order="6">
          <cline> } // end row loop</cline>
          <cline> return largest;</cline>
        </block>

        <block order="4">
          <cline>} // end method</cline>
        </block>
      </blocks>
    </activity>

    <p>
      You can step through this code using the Java Visualizer by clicking on
      the following <url
      href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+Test+%7B%0A+++%0A+++public+static+int+getLargest(int%5B%5D%5B%5D+arr)++%7B%0A++++int+largest+%3D+arr%5B0%5D%5B0%5D%3B%0A++++for+(int+row+%3D+0%3B+row+%3C+arr.length%3B+row%2B%2B)++%7B%0A++++++for+(int+col+%3D+0%3B+col+%3C+arr%5B0%5D.length%3B+col%2B%2B)++%7B%0A++++++++if+(arr%5Brow%5D%5Bcol%5D+%3E+largest)++%7B%0A++++++++++largest+%3D+arr%5Brow%5D%5Bcol%5D%3B%0A++++++++%7D+//+end+if%0A++++++%7D+//+end+column+loop%0A++++%7D+//+end+row+loop%0A++++return+largest%3B%0A+++%7D+//+end+method%0A+++%0A+++public+static+void+main(String%5B%5D+args)+%7B%0A++++++int%5B%5D%5B%5D+testArray+%3D+%7B%7B-32,+-6,+-3%7D,+%7B-392,+-93,+-2%7D%7D%3B%0A++++++System.out.println(getLargest(testArray))%3B%0A+++%7D%0A%7D&amp;mode=display&amp;curInstr=40">Java
      Visualizer</url>.
    </p>
  </subsection>

  <subsection xml:id="subsection-of-a-2d-array-for-a-property">
    <title>Subsection of a 2D Array for a Property</title>

    <idx><h>2D Array</h><h>loop range</h></idx>
    <p>
      You can loop through just part of a 2D array. You can change the starting
      value and ending value to loop through a subset of a 2D array. The
      following code counts the number of times a value appears in a part of the
      2D array indicated by the row and column start and end values.
    </p>

    <activity label="lca2dloopPart2">
      <statement>
        <p>Looping through just part of a 2D array.</p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class Count {
            public static int countValues(
                int value, int[][] a, int rowStart, int rowEnd, int colStart, int colEnd) {
              int count = 0;
              for (int row = rowStart; row <= rowEnd; row++) {
                for (int col = colStart; col <= colEnd; col++) {
                  if (a[row][col] == value) {
                    count++;
                  }
                }
              }
              return count;
            }

            public static void main(String[] args) {
              int[][] matrix = {{3, 2, 3}, {4, 3, 6}, {8, 9, 3}, {10, 3, 3}};
              System.out.println(countValues(3, matrix, 0, 2, 0, 2));
            }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            @Test
            public void testMain() throws IOException {
              String output = getMethodOutput("main");
              String expect = "4";
              boolean passed = getResults(expect, output, "Expected output from main", true);
              assertTrue(passed);
            }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="duplicates-in-2d-arrays">
    <title>Duplicates in 2D Arrays</title>

    <p>
      You can determine the presence or absence of duplicate elements in the 2D
      array or in a designated row, column, or other subsection. With 1D arrays,
      we sometimes needed 2 nested loops to check for duplicates or pairs. With
      2D arrays, you often need 4 nested loop to check the whole array!
    </p>

    <activity label="noDups2DArray">
      <statement>
        <p>
          The method <c>noDups(nums)</c> returns <c>true</c> if there are no
          repeated (duplicate) items in the array <c>nums</c>. It should return
          false if it does find a repeated element using nested loops.
        </p>
      </statement>

      <program interactive="activecode">
        <![CDATA[

        public class Duplicates {
          public static boolean noDups(int[][] nums) {
            for (int row = 0; row < nums.length; row++) {
              for (int col = 0; col < nums[0].length; col++) {
                for (int row2 = row; row2 < nums.length; row2++) {
                  for (int col2 = col + 1; col2 < nums[0].length; col2++) {
                    if (nums[row][col] == nums[row2][col2]) {
                      return false;
                    }
                  }
                }
              }
            }
            return true;
          }

          public static void main(String[] args) {
            int[][] matrix = {{3, 2, 3}, {4, 3, 6}, {8, 9, 3}, {10, 3, 3}};
            System.out.println(noDups(matrix));
          }
        }

        ]]>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="rotate-and-reverse">
    <title>Rotate and Reverse</title>

    <p>
      We can also rotate or reverse the order of the elements in a row or
      column. The following code rotates the elements in a row to the right by
      one position. This algorithm is very similar to the 1D array rotation
      algorithm since we are dealing with a single row or column.
    </p>

    <activity label="rotate2DArray">
      <statement>
        <p>
          Create a method <c>rotateRowRight</c> that rotates the elements in a
          row to the right by one position. It should return the rotated array.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class Rotate {
            public static int[][] rotateRowRight(int[][] nums, int row) {
              int last = nums[row][nums[0].length - 1];
              // Write a backwards loop through the row's columns
              //  to copy elements at col-1 to col

              // Copy the last element to the first element at col 0

              return nums;
            }

            public static void main(String[] args) {
              int[][] matrix = {{3, 2, 3}, {4, 3, 6}, {8, 9, 3}, {10, 3, 3}};
              int[][] rotated = rotateRowRight(matrix, 1);
              for (int row = 0; row < rotated.length; row++) {
                for (int col = 0; col < rotated[0].length; col++) {
                  System.out.print(rotated[row][col] + " ");
                }
                System.out.println();
              }
            }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            @Test
            public void testMain() throws IOException {
              String output = getMethodOutput("main");
              String expect = "3 2 3\n6 4 3\n8 9 3\n10 3 3\n";
              boolean passed = getResults(expect, output, "Expected output from main", true);
              assertTrue(passed);
            }
            /* // giving strange error converting int to Object array.
            @Test
               public void test2()
               {
                   int[][] array = { {1, 4, 8}, {6, 7, 9}};
                   int value = 0;
                   Object[] args = {array, 0};

                   String output = getMethodOutput("rotateRowRight", args);
                   String expect = "8 1 4\n6 7 9\n";

                   boolean passed =
                           getResults(expect, output, "Testing rotateRowRight({ {1, 4,8},{6, 7, 9} }, 1)");
                   assertTrue(passed);
               }
               */
          }
        </tests>
      </program>
    </activity>
  </subsection>
</section>
