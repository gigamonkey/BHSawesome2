<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-4-5-array-algorithms">
  <title>Array algorithms</title>

  <introduction>
    <idx>array</idx>
    <idx>algorithms</idx>
    <idx><h>array</h><h>algorithms</h></idx>
    <idx><h>array</h><h>FRQ</h></idx>
    <idx>loop algorithms</idx>
    <idx>accumulator</idx>
    <idx>sum</idx>
    <idx>average</idx>
    <idx>minimum</idx>
    <idx>maximum</idx>
    <idx>search</idx>
    <idx>frequency</idx>
    <idx>property</idx>
    <idx>shift</idx>
    <idx>rotate</idx>
    <idx>reverse</idx>
    <idx>pairs</idx>
    <idx>duplicates</idx>
    <p>
      In <xref ref="topic-2-9-loop-algorithms" /> we learned some basic loop
      algorithms for summing, counting, averaging, and finding minimums and
      maximums. Those algorithms become a lot more useful now that we know
      enough to use them with arrays. For instance we can sum or average all the
      elements in an array of numeric values or count the number of elements of
      an array that meet some criteria.
    </p>

    <p>
      Additionally there are some algorithms that are more specific to arrays
      such as those that operate on pairs of elements and algorithms that modify
      the order of elements in an array such as by reversing or rotating the
      elements within an array.
    </p>

    <p>
      In this lesson we’ll look at how to implement these algorithms with
      arrays.
    </p>
  </introduction>

  <subsection xml:id="accumulator-pattern-for-sum-average-1">
    <title>Summing and averaging</title>

    <p>
      As we have seen before with loops, the <term>accumulator pattern</term>
      decribes loops that iterate through a set of values while accumulating
      values into a variable where the accumulation can take on various forms.
      For instance summing numbers is a form of accumulation. The accumulator
      pattern has four steps:
    </p>

    <p>
      <ol>
        <li>
          <p>Initialize the accumulator variable before the loop.</p>
        </li>

        <li>
          <p>Loop through the values.</p>
        </li>

        <li>
          <p>Update the accumulator variable inside the loop.</p>
        </li>

        <li>
          <p>Do something with the accumulated value when the loop is done.</p>
        </li>
      </ol>
    </p>

    <p>
      To apply this pattern to summing the elements of an array we just need to
      recognize that the values to loop through in step 2 are just the elements
      of the array. Since we need to process all the elements in the array to
      sum them and don’t care about their positions, this is a great use for an
      enhanced <c>for</c> loop. And we can compute the average by dividing the
      sum by the array’s length. For example:
    </p>

    <program>
      int[] values = { 6, 2, 1, 7, 12, 5 };

      double sum = 0;

      for (int val : values) {
          sum += val;
      }

      double average = sum / values.length;
      System.out.println("Sum: " + sum + "; Average: " + average);
    </program>

    <activity label="parsons_array_avg" numbered="yes" adaptive="yes" indentation="show" language="java">
      <statement>
        <p>
          The following program has the correct code to return the average of
          the first 3 items in the array a, but the code is mixed up. Drag the
          blocks from the left into the correct order on the right. You will be
          told if any of the blocks are in the wrong order or are indented
          incorrectly.
        </p>
      </statement>

      <blocks>
        <block order="2">
          <cline>public static double avg3(int[] a)</cline>
          <cline>{</cline>
        </block>

        <block order="6">
          <cline>  double total = 0;</cline>
        </block>

        <block order="1">
          <cline>  for (int i = 0; i &lt; a.length &amp;&amp; i &lt; 3; i++)</cline>
          <cline>  {</cline>
        </block>

        <block order="3">
          <cline>    total = total + a[i];</cline>
        </block>

        <block order="5">
          <cline>  } // end for</cline>
          <cline>  return total / 3;</cline>
        </block>

        <block order="4">
          <cline>} // end method</cline>
        </block>
      </blocks>
    </activity>
  </subsection>

  <subsection>
    <title>Minimizing, maximizing, and counting</title>

    <p>
      As you may recall from <xref ref="topic-2-9-loop-algorithms" /> the basic
      pattern for finding the minimum or maximum value in a sequence is also an
      accumulator pattern like summing but rather than adding each value into a
      running total we instead put each smaller (or larger) value we see into
      our accumulator variable. If we want to find the smallest value in an
      array we can use a very similar pattern with an enhanced <c>for</c> loop.
    </p>

    <p>
      In the code below, assuming <c>numbers</c> is a non-empty array of
      <c>int</c> values, after the code below runs, <c>min</c> will contain the
      smallest value in the array:
    </p>

    <program>
      // assume numbers is an int[] variable

      int min = numbers[0];

      for (int num : numbers) {
          min = Math.min(min, num);
      }
    </program>

    <p>
      But we can do fancier versions of finding the extreme values in an array.
      Suppose we had an array of <c>String</c> values containing people’s names
      and wanted to find the longest one. In this case we will compare the
      lengths of the values in the array but save the value. We’ll probably need
      to use an explicit <c>if</c> since there isn’t a convenient method like
      <c>Math.max</c> that we can pass two <c>String</c> arguments and get back
      the longer one. Maybe something like this:
    </p>

    <program>
      <![CDATA[
      // Assume names is a String[] variable containing names

      String longest = names[0];

      for (String name : names) {
          // Check if the new name is longer than the longest we've seen
          if (name.length() > longest.length()) {
              // Save the new name if it's longer
              longest = name;
          }
      }
      ]]>
    </program>

    <activity label="parsons_for_each_largest" numbered="yes" adaptive="yes" indentation="show" language="java">
      <statement>
        <p>
          The following method has the correct code to return the largest value
          in an integer array called <c>vals</c> (an instance variable of the
          current object), but the code is mixed up. Drag the blocks from the
          left into the correct order on the right and indent them correctly as
          well. You will be told if any of the blocks are in the wrong order or
          not indented correctly.
        </p>
      </statement>

      <blocks>
        <block order="6">
          <cline>public int getLargest()</cline>
          <cline>{</cline>
        </block>

        <block order="2">
          <cline>  int largest = vals[0];</cline>
        </block>

        <block order="3">
          <cline>  for (int item : vals)</cline>
          <cline>  {</cline>
        </block>

        <block order="4">
          <cline>    if (item &gt; largest)</cline>
          <cline>    {</cline>
        </block>

        <block order="8">
          <cline>      largest = item;</cline>
        </block>

        <block order="5">
          <cline>    }  // end if</cline>
        </block>

        <block order="1">
          <cline>  } // end for</cline>
          <cline>  return largest;</cline>
        </block>

        <block order="7">
          <cline>} // end method</cline>
        </block>
      </blocks>
    </activity>

    <p>
      If you want to step through the correct code to see what it does in the
      Java Visualizer click on the following <url
      href="http://www.pythontutor.com/java.html#code=public+class+ArrayWorker%0A%7B%0A+++private+int%5B+%5D+values%3B%0A%0A+++public+ArrayWorker(int%5B%5D+theValues)%0A+++%7B%0A++++++values+%3D+theValues%3B%0A+++%7D%0A%0A+++public+double+getAverage()%0A+++%7B%0A+++++double+total+%3D+0%3B%0A+++++for+(int+val+%3A+values)%0A+++++%7B%0A+++++++total++%3D+total+%2B+val%3B%0A+++++%7D%0A+++++return+total+/+values.length%3B%0A+++%7D%0A+++%0A+++public+int+getLargest()%0A+++%7B%0A++%0A+++++int+largest+%3D+values%5B0%5D%3B%0A%0A+++++for+(int+item+%3A+values)%0A+++++%7B%0A%0A+++++++if+(item+%3E+largest)%0A+++++++%7B%0A%0A+++++++++largest+%3D+item%3B%0A%0A+++++++%7D++//+end+if+%0A%0A+++++%7D+//+end+for%0A+++++return+largest%3B%0A%0A+++%7D+//+end+method%0A%0A+++public+static+void+main(String%5B%5D+args)%0A+++%7B%0A+++++int%5B%5D+numArray+%3D++%7B2,+6,+7,+12,+5%7D%3B%0A+++++ArrayWorker+aWorker+%3D+new+ArrayWorker(numArray)%3B%0A+++++System.out.println(aWorker.getLargest())%3B%0A+++%7D%0A%7D%0A%0A&amp;mode=display&amp;curInstr=0">Java
      visualizer link</url>.
    </p>

    <activity label="minmax">
      <statement>
        <p>
          The code below finds the minimum (smallest element) in an array. Try
          it in the <url
          href="http://www.pythontutor.com/visualize.html#code=%20%20public%20class%20MinMax%0A%20%20%20%7B%20%20%20%20%20%20%0A%20%20%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20int%5B%20%5D%20values%20%3D%20%7B6,%202,%201,%207,%2012,%205%7D%3B%0A%20%20%20%20%20%20%20%20int%20min%20%3D%20values%5B0%5D%3B%20//%20initialize%20min%20to%20the%20first%20element%0A%20%20%20%20%20%20%20%20for%20%28int%20val%20%3A%20values%29%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20if%20%28val%20%3C%20min%29%20//%20found%20a%20new%20min!%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20min%20%3D%20val%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20System.out.println%28%22Min%20is%20%22%20%2B%20min%20%29%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%7D&amp;cumulative=false&amp;curInstr=20&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false&amp;curInstr=0">Java
          visualizer</url> with the CodeLens button. Can you change it to find
          the maximum element instead? Can you also compute the average of the
          elements?
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          public class MinMax {
            public static void main(String[] args) {
              int[] values = {6, 2, 1, 7, 12, 5};

              int min = values[0]; // initialize min to the first element

              for (int val : values) {
                if (val < min) { // found a new min!
                  min = val;
                }
              }
              System.out.println("Min is " + min);
            }
          }
          ]]>
        </code>

        <tests>
          <![CDATA[
          // Test for Lesson MinMax
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("MinMax");

              int[] numArray = {2, 6, 7, 12, 5};
              setDefaultValues(new Object[] {numArray});
            }

            @Test
            public void test1() {
              String output = getMethodOutput("main");
              String expect = "Max is 12";

              boolean passed = output.contains(expect);

              passed = getResults(expect, output, "Max element", passed);
              assertTrue(passed);
            }

            @Test
            public void test2() {
              String output = getMethodOutput("main");
              String expect = "Average is 5.5";

              boolean passed = output.contains(expect);

              passed = getResults(expect, output, "Average", passed);
              assertTrue(passed);
            }

            @Test
            public void test3() {
              boolean passed = checkCodeContains("if statement using val >", "if (val >");
              assertTrue(passed);
            }
          }
          ]]>
        </tests>

      </program>
    </activity>

    <p>
      Related to minimizing and maximizing algorithms are counting algorithms
      where we want to count the number of values that have some particular
      property. In counting algorithms we also use an <c>if</c> statement but
      rather than storing new values when we see a larger or smaller one, we
      instead increment a count whenever we see a value that meets our criteria.
    </p>

    <p>
      For instance, suppose we wanted to count how many names in our array were
      longer than ten characters. Compare the code below to the previous
      maximizing code.
    </p>

    <program>
      <![CDATA[
      // names is still a String[] variable containing names

      int count = 0;

      for (String name : names) {
          if (name.length() > 10) {
              count++;
          }
      }
      ]]>
    </program>

    <p>
      In this case our accumulator variable is the <c>int count</c>. And we
      “accumulate” into it with the <c>++</c> operator but only when we see a
      <c>String</c> longer than ten characters.
    </p>

    <activity label="parsons-even-array" numbered="yes" adaptive="yes" indentation="show" language="java">
      <statement>
        <p>
          The following program segment should count the number of elements in
          the array that are even using an enhanced for each loop. But, the
          blocks have been mixed up. Drag the blocks from the left and put them
          in the correct order on the right. Click the Check button to check
          your solution.
        </p>
      </statement>

      <blocks>
        <block order="2">
          <cline>int[] arr = {14, -5, 2, 17, 29, -8, 36};</cline>
          <cline>int count = 0;</cline>
        </block>

        <block order="1">
          <cline>for (int value : arr)</cline>
          <cline>{</cline>
        </block>

        <block order="3">
          <cline>    if (value % 2 == 0)</cline>
          <cline>    {</cline>
        </block>

        <block order="6">
          <cline>        count++;</cline>
        </block>

        <block order="5">
          <cline>    } //end conditional</cline>
        </block>

        <block order="4">
          <cline>} //end for loop</cline>
        </block>
      </blocks>
    </activity>
  </subsection>

  <subsection xml:id="min-max-search-algorithms">
    <title>Searching</title>

    <p>
      When we’re summing, minimizing, maximizing, and counting we have to look
      at every element in the array in order to get our final answer. Searching
      algorithms often don’t have to look at every elemement because their goal
      is to find one element that meets some criteria; as soon as we find an
      element that meets the criteria we’re done and don’t need to look at any
      more values. It’s like when you’re looking for your keys—there’s a long
      list of places you can look but as soon as you find them you stop. Which
      is why your keys are always in the last place you look.
    </p>

    <p>
      The best way to write a searching algorithm is to put the loop into a
      method so that we can <c>return</c> from the method as soon as we find a
      value that meets our criteria. Returning from a method will break us out
      of the loop immediately, even if the loop would otherwise have run for
      more iterations. Here’s a method that returns the first name longer than
      ten characters in the array it is passed.
    </p>

    <program>
      <![CDATA[
      public static String findLongName(String[] names) {
          for (String name : names) {
              if (name.length() > 10) {
                  return name;
              }
          }
          return null;
      }
      ]]>
    </program>

    <p>
      When this method runs it will return the first name in the array that is
      longer than ten characters. There may be many long names in the array but
      the goal of this method is just to find the first one. Note the <c>return
      null</c> at the end of the method. Because the return type of the method
      is <c>String</c> we have to return something even if we didn’t find any
      name that met our criteria in the array. Returning <c>null</c> is a
      traditional way to deal with that situation and makes some sense since it
      indicates “no object”. That is, the method did not find any actual
      <c>String</c> longer than ten characters. There are some problems with
      this idiom and Java gives some better ways to handle this kind of
      situation but they are beyond the scope of this course. If we were
      searching for a value in a an array of some primitive type, we couldn’t
      return <c>null</c> but would have to return some other <term>distinguished
      value</term> that would not be a possible actual value to be found. For
      instance methods that are intended to searching in an array of positive
      <c>int</c> values, often use -1 as a distinguished value.
    </p>

    <p>
      Note that when searching for an element, while we <c>return</c> from
      inside the <c>if</c> when we find what we’re looking for, if we don’t find
      it we need to keep looking and only return <c>null</c> or our other
      distinguished value after the loop has completed.
    </p>

    <activity label="early_return_error">
      <title>Giving up too soon</title>

      <statement>
        <p>
          Run the following code. Does it find 7 in the array? Click on Code
          Lens to trace through the code to see why not. Once you’ve found it,
          fix the error.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class FindError {
            public static boolean find(int[] array, int target) {
              for (int val : array) {
                if (val == target) {
                  return true;
                } else {
                  return false;
                }
              }
              return false;
            }

            public static void main(String[] args) {
              int[] values = {6, 2, 1, 7, 12, 5};
              System.out.println(find(values, 7));
            }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("FindError");
            }

            @Test
            public void test1() {
              String output = getMethodOutput("main");
              String expect = "true";

              boolean passed = (output.equals(expect));
              getResults(expect, output, "Testing main() output", passed);
              assertTrue(passed);
            }

            @Test
            public void test2() {
              int[] values = {-1, 0, 1};
              String output = "" + FindError.find(values, 0);
              String expect = "true";

              boolean passed = getResults(expect, output, "Testing find({-1, 0, 1}, 0)");
              assertTrue(passed);
            }
          }
        </tests>

      </program>
    </activity>

    <activity label="mcq_array_error1">
      <statement>
        <p>
          Given that <c>array</c> is an array of integers and <c>target</c> is
          an integer value, which of the following best describes the conditions
          under which the following code segment will return false?
        </p>

        <program>
          public boolean find(int[] array, int target) {
              for (int val : array) {
                  if (val == target) {
                      return true;
                  } else {
                      return false;
                  }
              }
              return false;
          }
        </program>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>
              Whenever the first element in <c>array</c> is not equal to
              <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              Yes, the loop returns as soon as checking the first element,
              whether it is equal to target or not. It needs to check the whole
              array before returning false. The else statement should not be
              included.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              Whenever <c>array</c> contains any element which equals
              <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              This would be true if the else statement was not there, but it
              returns false right away after just checking the first element
              instead of going through all of the elements to makes sure none of
              them are equal to target.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Always</p>
          </statement>

          <feedback>
            <p>
              If the first element is equal to the target, it will return true.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Never</p>
          </statement>

          <feedback>
            <p>
              It will return false with the else statement if the first element
              is not equal to the target.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="mcq_array_error2">
      <statement>
        <p>
          Given that <c>array</c> is an array of integers and <c>target</c> is
          an integer value, which of the following best describes the conditions
          under which the following code segment will return true?
        </p>

        <program>
          boolean temp = false;
          for (int val : array) {
            temp = (target == val);
          }
          return temp;
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>
              Whenever the first element in <c>array</c> is equal to
              <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              This would be true if the loop started at the end of the array and
              moved toward the beginning. But, it will loop from the first
              element to the last.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              Whenever <c>array</c> contains any element which equals
              <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              This would be true if temp was only set to the result of checking
              if the current element in the array is equal to <c>target</c> when
              it is <c>false</c>. But, it is reset each time through the loop.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>
              Whenever the last element in <c>array</c> is equal to
              <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              The variable <c>temp</c> is assigned to the result of checking if
              the current element in the array is equal to <c>target</c>. The
              last time through the loop it will check if the last element is
              equal to <c>val</c>.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              Whenever only 1 element in <c>array</c> is equal to <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              There is no count of the number of times the array element is
              equal to <c>target</c>.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="find_loop_early_return_error">
      <statement>
        <p>
          What is wrong with the code below? The first time through the loop it
          will start with the element at index 0 and check if the item at the
          array index equals the passed target string. If they have the same
          characters in the same order it will return 0, otherwise it will
          return -1. But, it has only processed one element of the array. How
          would you fix the code to work correctly (process all array elements
          before returning)?
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          public class StringWorker {
            private String[] arr = {"Hello", "Hey", "Good morning!"};

            public int findString(String target) {
              String word = null;
              for (int index = 0; index < arr.length; index++) {
                word = arr[index];

                if (word.equals(target)) {
                  return index;
                } else {
                  return -1;
                }
              }
              return -1;
            }

            public static void main(String[] args) {
              StringWorker sWorker = new StringWorker();
              System.out.println(sWorker.findString("Hey"));
            }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("StringWorker");
            }

            @Test
            public void test1() {
              String output = getMethodOutput("main");
              String expect = "1".replaceAll(" ", "\n");

              boolean passed = (output.equals(expect));
              getResults(expect, output, "Testing main() output", passed);
              assertTrue(passed);
            }

            @Test
            public void test2() {
              StringWorker sWorker = new StringWorker();
              String output = "" + sWorker.findString("Good morning!");
              String expect = "2";

              boolean passed = getResults(expect, output, "Testing findString(\"Good morning!\")");
              assertTrue(passed);
            }

            @Test
            public void test3() {
              StringWorker sWorker = new StringWorker();
              String output = "" + sWorker.findString("Hello!");
              String expect = "-1";

              boolean passed = getResults(expect, output, "Testing findString(\"Hello!\")");
              assertTrue(passed);
            }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="test-property">
    <title>Any and all</title>

    <p>
      In searching algorithms we’re looking for one value that meets some
      criteria, like being more than ten characters long. A pair of related
      questions that we can ask about an array is do <em>any</em> elements of
      the array meet some criteria or do <em>all</em> elements meet it.
    </p>

    <p>
      The algorithms to answer these questions are similar to the searching
      algorithm but instead of returning the value we from in the array, we
      return a <c>boolean</c> value that answers the question. On the AP exam
      they will frequently provide a method to use to test the criteria so all
      you’ll have to do is write the right method structure.
    </p>

    <p>
      As with a searching algorithm, these work best in a method so we can use
      <c>return</c> to break out of the loop as soon as we know the answer. One
      way to think about these is as doing a search and using the fact of
      whether you found what you were looking for to answer the any or all
      question. Obviously if any item matches the criteria and you search for
      that criterial you’ll find one. So an any method is structured very
      similar to a search:
    </p>

    <program>
      // Assume hasProperty is a method that tests the criteria we care about
      // and returns a boolean when the value it is passed has the property.

      public static boolean anyHasProperty(int[] values) {
          for (int val : values) {
              if (hasProperty(val)) {
                  return true;
              }
          }
          return false;
      }
    </program>

    <p>
      The difference between this method and a search method just just in the
      return values: at the point where a search method would return the value
      it found, we return <c>true</c>, and where a search method would return
      the distinguished “not found” value, such as null, we return <c>false</c>
      to indicate that no elements of the array met the criteria.
    </p>

    <p>
      You might think that to check whether all elements of an array meet some
      criteria you’d have to loop through the whole array and look at them all.
      It’s right there in the name, right? However, we can flip things around
      and realize that saying <em>all</em> the elements meet some criteria is
      the same as saying there is <em>no</em> element that <em>doesn’t</em> meet
      the criteria. In other words, if we can find just one counter example then
      we know not all the elements meet the criteria. So the all pattern is
      actually almost the same as the any pattern, we just test the opposite
      condition: <c>!hasProperty(value)</c> rather than
      <c>hasProperty(value)</c> and then swap the return values, <c>false</c>
      for <c>true</c> and vice versa:
    </p>

    <program>
      // Assume hasProperty is a method that tests the criteria we care about
      // and returns a boolean when the value it is passed has the property.

      public static boolean allHaveProperty(int[] values) {
          for (int val : values) {
              if (!hasProperty(val)) {
                  return false;
              }
          }
          return true;
      }
    </program>

    <activity label="exAllOdd">
      <statement>
        <p>
          Write the method allOdd to return true if all the values in the array
          are odd. First write the helper function isEven to return true or
          false for one value, using %.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Test1 {
            public static boolean isEven(int value) {
              // 1. TODO: return true if value is even, false otherwise
              return true;
            }

            public static boolean allOdd(int[] array) {
              // 2. TODO: Loop thru the array
              // and return false if any value isEven

              // if all odd, return true
              return true;
            }

            public static void main(String[] args) {
              int[] a1 = {1, 3, 6};
              int[] a2 = {1, 3, 5};
              System.out.println(allOdd(a1));
              System.out.println(allOdd(a2));
            }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            @Test
            public void testMain() throws IOException {
              String output = getMethodOutput("main");
              String expect = "false\ntrue\n";

              boolean passed = getResults(expect, output, "Expected output from main");
              assertTrue(passed);
            }

            @Test
            public void testMethod() {
              int[] nums = {10, 20, 30, 40};
              Object[] args = {nums};

              String output = getMethodOutput("allOdd", args);
              String expect = "false";

              boolean passed = getResults(expect, output, "allOdd({10, 20, 30, 40})");
              assertTrue(passed);
            }

            @Test
            public void testMethod2() {
              int[] nums = {37, 41, 55, 99};
              Object[] args = {nums};

              String output = getMethodOutput("allOdd", args);
              String expect = "true";

              boolean passed = getResults(expect, output, "allOdd({37,41,55,99})");
              assertTrue(passed);
            }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="pairs-and-duplicates-in-array">
    <title>Comparing elements</title>

    <p>
      Sometimes we need to go beyond testing criteria against individiual
      elements of the array and test facts about relationships between elements
      within the array. For instance, suppose we had a sorted array so the
      elements went from smallest to largest. In a sorted array elements with
      the same value will be next to each other in the array so we can test
      whether there are any duplicate elements by looping through the array and
      checking all the pairs at adjacent indices:
    </p>

    <program>
      <![CDATA[
      // check for duplicates next to each other
      public static boolean anyDuplicatesInSorted(int[] values) {
          for (int i = 0; i < values.length - 1; i++) {
              if (values[i] == values[i + 1]) {
                  return true;
              }
          }
          return false;
      }
      ]]>
    </program>

    <p>
      There are a couple things to note about this loop. First off, we need to
      use a regular <c>for</c> loop since we need an index variable to be able
      to access the elements at indicies <c>i</c> and <c>i + 1</c> each time
      through the loop. And we had to adjust the loop header from the canonical
      <c>for</c> loop, changing the limit from the normal <c>values.length</c>
      to <c>values.length - 1</c>. If we looped with a limit of
      <c>values.length</c> then the last iteration of the loop <c>i</c> would be
      the largest legal index and <c>i + 1</c> would be one greater and out of
      bounds.
    </p>

    <p>
      The above algorithm only works if the array is sorted. If the array is not
      necessarily sorted, we need to do a bit more work, using a nested nested
      loop to compare all pairs of elements in the array. Look carefully at the
      two loops. The outer loop is a canonical loop, since we need to consider
      every element of the array against all it’s possible pairs. But the inner
      loop is unusual in that the initializer starts the loop variable not at
      <c>0</c>. Why?
    </p>

    <program>
      <![CDATA[
      // check for duplicates anywhere in the array
      public static boolean anyDuplicates(int[] values) {
          for (int i = 0; i < values.length; i++) {
              for (int j = i + 1; j < values.length; j++) {
                  if (values[i] == values[j]) {
                      return true;
                  }
              }
          }
          return false;
      }
      ]]>
    </program>

    <activity label="sumPairs">
      <statement>
        <p>
          Create a method <c>sumPairs10(nums)</c> returns <c>true</c> if there
          are at least two items in the array <c>nums</c> that are adjacent
          (next to each other) that add up to 10, otherwise return <c>false</c>.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Pairs {
            public static boolean sumPairs10(int[] nums) {
              // TODO: if two adjacent numbers in nums add up to 10, return true
              return false;
            }

            public static void main(String[] args) {
              int[] nums1 = {1, 2, 8};
              System.out.println(sumPairs10(nums1));

              int[] nums2 = {2, 1, 2};
              System.out.println(sumPairs10(nums2));
            }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.IOException;
          import org.junit.Test;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("Pairs");
            }

            @Test
            public void testMain() throws IOException {
              String output = getMethodOutput("main");
              String expect = "true\nfalse\n";
              boolean passed = getResults(expect, output, "Expected output from main");
              assertTrue(passed);
            }

            @Test
            public void testMethod2() {
              int[] nums = {2, 4, 6, 8};
              Object[] args = {nums};

              String output = getMethodOutput("sumPairs10", args);
              String expect = "true";

              boolean passed = getResults(expect, output, "sumPairs10({2, 4, 6, 8})");
              assertTrue(passed);
            }
          }
        </tests>

      </program>
    </activity>

    <activity label="noDups">
      <statement>
        <p>
          Create a method <c>noDups(nums)</c> returns <c>true</c> if there are
          no repeated (duplicate) items in the array <c>nums</c>. It should
          return false if it does find a repeated element using nested loops.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class Pairs {
            public static boolean noDups(int[] nums) {
              // TODO: use nested loops to check if any item appears more than once in nums

              return true;
            }

            public static void main(String[] args) {

              int[] nums1 = {1, 2, 8};
              System.out.println(noDups(nums1));

              int[] nums2 = {3, 3, 3};
              System.out.println(noDups(nums2));
            }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.IOException;
          import org.junit.Test;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("Pairs");
            }

            @Test
            public void testMain() throws IOException {
              String output = getMethodOutput("main");
              String expect = "true\nfalse\n";
              boolean passed = getResults(expect, output, "Expected output from main");
              assertTrue(passed);
            }

            @Test
            public void testMethod2() {
              int[] nums = {2, 4, 6, 2};
              Object[] args = {nums};

              String output = getMethodOutput("noDups", args);
              String expect = "false";

              boolean passed = getResults(expect, output, "noDups({2, 4, 6, 2})");
              assertTrue(passed);
            }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="rotating-array-elements">
    <title>Rotating arrays</title>

    <p>
      Rotating an array means shifting all the elements in the array to the
      right or left by one position. For example, if the array is <c>{ 6, 2, 5,
      3 }</c>, rotating it to the right would give <c>{ 3, 6, 2, 5 }</c> after
      the first three elements have each moved on position to the right and the
      <c>3</c> that was originially the last element is now the first element.
      Rotating the same initial array to the left would give us <c>{ 2, 5, 3, 6
      }</c>.
    </p>

    <activity label="rotateRightParsons" numbered="yes" adaptive="yes" indentation="show" language="java">
      <title>Copying right rotation</title>

      <statement>
        <p>
          The scrambled code below is for a method that should return a new
          <c>int[]</c> that is the same as its argument but rotated one position
          to the right, so <c>{ 6, 2, 5, 3 }</c> returns <c>{ 3, 6, 2, 5 }</c>.
          The blocks also include one block that is not needed in a correct
          solution. Drag the blocks from the left and put them in the correct
          order on the right. Click the Check button to check your solution.
        </p>
      </statement>

      <blocks>
        <block order="3">
          <cline>public static int[] rotateRight(int[] arr) {</cline>
        </block>

        <block order="7">
          <cline>    int[] result = new int[arr.length];</cline>
        </block>

        <block order="2">
          <cline>    result[0] = arr[arr.length-1];</cline>
        </block>

        <block order="8">
          <cline>    for (int i = 0; i &lt; arr.length - 1; i++) {</cline>
        </block>

        <block order="5" correct="no">
          <cline>    for (int i = 0; i &lt; arr.length; i++) {</cline>
        </block>

        <block order="1">
          <cline>        result[i + 1] = arr[i];</cline>
        </block>

        <block order="4">
          <cline>    } //end for loop</cline>
        </block>

        <block order="9">
          <cline>    return result;</cline>
        </block>

        <block order="6">
          <cline>} //end shiftRight method</cline>
        </block>
      </blocks>
    </activity>

    <p>
      We can also rotate in place without constructing another array if we use a
      temporary variable to hold one value while we move all the others to their
      new position in the array. For instance to rotate left, store the value of
      the first element and then shift all the other elements one to the left in
      order. When all the elements have been shifted, put the original first
      element in the last position to complete the rotation.
    </p>

    <activity label="rotate">
      <statement>
        <p>
          The code below rotates array elements to the left in place without
          constructing another array. Try it in the Java visualizer with the
          CodeLens button. Can you change it to rotate the elements to the right
          instead? Hint: use a backwards loop.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          <![CDATA[
          public class Rotate {
            public static void main(String[] args) {
              int[] values = {6, 2, 1, 7, 12, 5};
              int first = values[0];
              for (int i = 0; i < values.length - 1; i++) {
                if (i < values.length - 1) {
                  values[i] = values[i + 1];
                }
              }
              values[values.length - 1] = first;

              // print them out to see the results
              for (int val : values) {
                System.out.print(val + " ");
              }
            }
          }
          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("Rotate");
            }

            @Test
            public void test1() {
              String output = getMethodOutput("main");
              String expect = "5 6 2 1 7 12";

              boolean passed = output.contains(expect);

              passed = getResults(expect, output, "Rotate numbers to the right", passed);
              assertTrue(passed);
            }

            @Test
            public void test3() {
              boolean passed =
                  checkCodeContains("copying values[i-1] into values[i]", "values[i] = values[i-1]");
              assertTrue(passed);
            }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="reversing-an-array">
    <title>Reversing an array</title>

    <p>
      Reversing an array is similar to rotating it. However rather than shifting
      elements one position either up or down, which only requires keeping track
      of one extra value in a temporary variable, when we reverse an array in
      place (meaning we are actually moving the values in the original array,
      not making a new array with the same values in reverse order), we will
      repeatedly <term>swap</term> elements.
    </p>

    <p>
      For intance, clearly after we’ve reversed an array, the original first
      value will be in the last position and the originial last value will be in
      the first. So we need to swap those two elements, using a a temporary
      variable.
    </p>

    <p>
      To see why, imagine that we have a glass of water and a glass of orange
      juice and we want to swap the contents of the two glasses without making a
      huge mess? We would need a third glass to temporarily hold the contents of
      one of the glasses, let’s say the glass of water. Once the water glass is
      empty we can pour the contents of the glass of orange juice into it. Then
      we can pour the water from the third glass into the now empty orange juice
      glass and the contents have been swapped. (At the point we can put the
      third glass in the dishwasher.) This is the same idea behind swapping
      elements in an array.
    </p>

    <figure align="center">
      <caption>Swapping elements in an array</caption>

      <image source="Unit4-Data-Collections/Figures/swap.png" width="54%" />
    </figure>

    <program>
      // Swapping 2 elements at index i and j
      int temp = array[i];  // pour water into a third glass
      array[i] = array[j];  // pour orange juice into original water glass
      array[j] = temp;      // pour water from third glass into original OJ glass
    </program>

    <p>
      To completely reverse a list we need to repeatedly swap elements, starting
      with the first and last, then the second and second to last, and so on,
      until we get to the middle of the list. As when we rotating arrays, we
      will need to use a regular <c>for</c> loop to access the elements at
      specific indices.
    </p>

    <p>
      The following two programs show how to reverse an array in place by
      swapping elements. The first uses a <c>for</c> loop and the second a
      should use a <c>while</c> loop.
    </p>

    <activity label="parsons_array_reverse" numbered="yes" adaptive="yes" indentation="hide" language="java">
      <statement>
        <p>
          The following method reverses an array in place using an indexed for
          loop and a temp variable to swap the first and last items, but the
          code blocks are mixed up. Drag the blocks from the left and put them
          in the correct order on the right. Click the Check button to check
          your solution.
        </p>
      </statement>

      <blocks>
        <block order="8">
          <cline>public static void reverse(int[] a) {</cline>
        </block>

        <block order="5">
          <cline>  int half = a.length / 2;</cline>
          <cline>  int max = a.length - 1;</cline>
        </block>

        <block order="6">
          <cline>  for (int i = 0; i &lt; half; i++) {</cline>
        </block>

        <block order="2">
          <cline>     int temp = a[i];</cline>
        </block>

        <block order="7">
          <cline>     a[i] = a[max - i];</cline>
        </block>

        <block order="3">
          <cline>     a[max - i] = temp;</cline>
        </block>

        <block order="1">
          <cline>  } // end for</cline>
        </block>

        <block order="4">
          <cline>} // end method</cline>
        </block>
      </blocks>
    </activity>

    <activity label="parsons_array_reverse2" numbered="yes" adaptive="yes" indentation="hide" language="java">
      <statement>
        <p>
          The following method reverses an array in place using a while loop and
          a temp variable to swap the first and last items. But, the blocks have
          been mixed up and include two extra blocks that are not needed in a
          correct solution. Drag the blocks from the left and put them in the
          correct order on the right. Click the Check button to check your
          solution.
        </p>
      </statement>

      <blocks>
        <block order="4">
          <cline>public static void reverse(int[] array) {</cline>
        </block>

        <block order="7">
          <cline>   int start = 0;</cline>
          <cline>   int end = array.length - 1;</cline>
        </block>

        <block order="6">
          <cline>   while (start &lt; end) {</cline>
        </block>

        <block order="5" correct="no">
          <cline>   for(int i = start; i &lt; end; i++) {</cline>
        </block>

        <block order="9">
          <cline>     int temp = array[start];</cline>
        </block>

        <block order="2">
          <cline>     array[start] = array[end];</cline>
        </block>

        <block order="10">
          <cline>     array[end] = temp;</cline>
        </block>

        <block order="1">
          <cline>     start++;</cline>
          <cline>     end--;</cline>
        </block>

        <block order="3" correct="no">
          <cline>     start++;</cline>
        </block>

        <block order="8">
          <cline>   }</cline>
          <cline>}</cline>
        </block>
      </blocks>
    </activity>

    <activity label="reverseArrayCode">
      <statement>
        <p>
          Create a method <c>reverse</c> that reverses an array in place using a
          temp variable.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          import java.util.Arrays;

          public class ReverseTest {
            public static void reverse(String[] array) {
              // TODO: reverse array in place using a temp variable to swap elements

            }

            public static void main(String[] args) {
              String[] a1 = {"p", "a", "w", "s"};
              reverse(a1);
              System.out.println(Arrays.toString(a1));
            }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import java.io.*;
          import java.util.Arrays;
          import org.junit.*;

          public class RunestoneTests extends CodeTestHelper {
            public RunestoneTests() {
              super("ReverseTest");
            }

            @Test
            public void testMain() throws IOException {
              String output = getMethodOutput("main");
              String expect = "[s, w, a, p]";
              boolean passed = getResults(expect, output, "Expected output from main");
              assertTrue(passed);
            }

            @Test
            public void testMethod2() {
              String[] a = {"r", "a", "t", "s"};
              ReverseTest.reverse(a);
              String output = Arrays.toString(a);
              String expect = "[s, t, a, r]";

              boolean passed = getResults(expect, output, "reverse({r, a, t, s})");
              assertTrue(passed);
            }
          }
        </tests>

      </program>
    </activity>

    <activity label="mcq_array_infinite">
      <statement>
        <p>
          Given the following code segment, which of the following will cause an
          infinite loop? Assume that <c>temp</c> is an int variable initialized
          to be greater than zero and that <c>a</c> is an array of integers.
        </p>

        <program>
          <![CDATA[
          for (int k = 0; k < a.length; k++) {
             while (a[k] < temp) {
                a[k] *= 2;
             }
          }
          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>
              The values don't matter this will always cause an infinite loop.
            </p>
          </statement>

          <feedback>
            <p>An infinite loop will not always occur in this code segment.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>
              Whenever <c>a</c> includes a value that is less than or equal to
              zero.
            </p>
          </statement>

          <feedback>
            <p>
              When <c>a</c> contains a value that is less than or equal to zero
              then multiplying that value by 2 will never make the result larger
              than the <c>temp</c> value (which was set to some value &gt; 0),
              so an infinite loop will occur.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Whenever <c>a</c> has values larger then <c>temp</c>.</p>
          </statement>

          <feedback>
            <p>
              Values larger then <c>temp</c> will not cause an infinite loop.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>When all values in <c>a</c> are larger than <c>temp</c>.</p>
          </statement>

          <feedback>
            <p>
              Values larger then <c>temp</c> will not cause an infinite loop.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Whenever <c>a</c> includes a value equal to <c>temp</c>.</p>
          </statement>

          <feedback>
            <p>Values equal to <c>temp</c> will not cause the infinite loop.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection>
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 4.5.A.1) There are standard algorithms that utilize array
            traversals to:
          </p>

          <p>
            <ul>
              <li>Determine a minimum or maximum value</li>

              <li>Compute a sum or average</li>

              <li>
                Determine if at least one element has a particular property
              </li>

              <li>Determine if all elements have a particular property</li>

              <li>
                Determine the number of elements having a particular property
              </li>

              <li>Access all consecutive pairs of elements</li>

              <li>Determine the presence or absence of duplicate elements</li>

              <li>Shift or rotate elements left or right</li>

              <li>Reverse the order of the elements</li>
            </ul>
          </p>
        </li>
      </ul>
    </p>
  </subsection>
</section>
