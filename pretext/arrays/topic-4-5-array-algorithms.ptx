<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-4-5-array-algorithms">
  <title>Array algorithms</title>

  <introduction>
    <idx>array</idx>
    <idx>algorithms</idx>
    <idx><h>array</h><h>algorithms</h></idx>
    <idx><h>array</h><h>FRQ</h></idx>
    <idx>loop algorithms</idx>
    <idx>accumulator</idx>
    <idx>sum</idx>
    <idx>average</idx>
    <idx>minimum</idx>
    <idx>maximum</idx>
    <idx>search</idx>
    <idx>frequency</idx>
    <idx>property</idx>
    <idx>shift</idx>
    <idx>rotate</idx>
    <idx>reverse</idx>
    <idx>pairs</idx>
    <idx>duplicates</idx>
    <p>
      In <xref ref="topic-2-9-loop-algorithms" /> we learned some basic loop
      algorithms for summing, counting, averaging, and findind minimums and
      maximums. Those algorithms become a lot more useful now that we know
      enough to use them with arrays. For instance we can sum or average all the
      elements in an array of numeric values or count the number of elements of
      an array that meet some criteria.
    </p>

    <p>
      Additionally there are some algorithms that are more specific to arrays
      such as those that operate on pairs of elements and algorithms that modify
      the order of elements in an array such as by reversing or rotating the
      elements within an array.
    </p>

    <p>
      In this lesson we’ll look at how to implement these algorithms with
      arrays.
    </p>
  </introduction>

  <subsection xml:id="accumulator-pattern-for-sum-average-1">
    <title>Summing and averaging</title>

    <p>
      As we have seen before with loops, the <term>accumulator pattern</term>
      decribes loops that iterate through a set of values while “accumulating”
      values into a variable. For instance summing numbers is a form of
      accumulation. The accumulator pattern has four steps:
    </p>

    <p>
      <ol>
        <li>
          <p>Initialize the accumulator variable before the loop.</p>
        </li>

        <li>
          <p>Loop through the values.</p>
        </li>

        <li>
          <p>Update the accumulator variable inside the loop.</p>
        </li>

        <li>
          <p>Do something with the accumulated value when the loop is done.</p>
        </li>
      </ol>
    </p>

    <p>
      The obvious way to sum the elements of an array is with an accumulating
      loop over the elements of the array. Since we need to process all the
      elements in the array to sum them and don’t care about their positions,
      this is a great use for an enhanced <c>for</c> loop. And we can compute
      the average by dividing the sum by the array’s length. For example:
    </p>

    <program>
      int[] values = { 6, 2, 1, 7, 12, 5 };

      double sum = 0;

      for (int val : values) {
          sum += val;
      }

      double average = sum / values.length;
      System.out.println("Sum: " + sum + "; Average: " + average);
    </program>

    <activity label="parsons_array_avg" numbered="yes" adaptive="yes" indentation="show" language="java">
      <statement>
        <p>
          The following program has the correct code to return the average of
          the first 3 items in the array a, but the code is mixed up. Drag the
          blocks from the left into the correct order on the right. You will be
          told if any of the blocks are in the wrong order or are indented
          incorrectly.
        </p>
      </statement>

      <blocks>
        <block order="2">
          <cline>public static double avg3(int[] a)</cline>
          <cline>{</cline>
        </block>

        <block order="6">
          <cline>  double total = 0;</cline>
        </block>

        <block order="1">
          <cline>  for (int i = 0; i &lt; a.length &amp;&amp; i &lt; 3; i++)</cline>
          <cline>  {</cline>
        </block>

        <block order="3">
          <cline>    total = total + a[i];</cline>
        </block>

        <block order="5">
          <cline>  } // end for</cline>
          <cline>  return total / 3;</cline>
        </block>

        <block order="4">
          <cline>} // end method</cline>
        </block>
      </blocks>
    </activity>
  </subsection>

  <subsection xml:id="min-max-search-algorithms">
    <title>Min, Max, Search Algorithms</title>

    <p>
      In the last lesson, you wrote a spell check algorithm which searched for a
      word in an array of dictionary words. Searching for the minimum or maximum
      follows a similar pattern of a loop with an if statement inside it. The
      pattern to follow is an enhanced for loop or an indexed for loop, with an
      embedded if statement. Remember that enhanced for loops cannot be used to
      modify primitive values in an array or to return an index.
    </p>

    <program>
      <![CDATA[

      for (int value : array)
      {
          if (value ....)
              ...
      }

      for(int i=0; i < array.length; i++)
      {
         if (array[i] ....)
             ...
      }

      ]]>
    </program>

    <activity label="parsons_for_each_largest" numbered="yes" adaptive="yes" indentation="show" language="java">
      <statement>
        <p>
          The following method has the correct code to return the largest value
          in an integer array called
          <title_reference>vals</title_reference>




 (an
          instance variable of the current object), but the code is mixed up.
          Drag the blocks from the left into the correct order on the right and
          indent them correctly as well. You will be told if any of the blocks
          are in the wrong order or not indented correctly.
        </p>
      </statement>

      <blocks>
        <block order="6">
          <cline>public int getLargest()</cline>
          <cline>{</cline>
        </block>

        <block order="2">
          <cline>  int largest = vals[0];</cline>
        </block>

        <block order="3">
          <cline>  for (int item : vals)</cline>
          <cline>  {</cline>
        </block>

        <block order="4">
          <cline>    if (item &gt; largest)</cline>
          <cline>    {</cline>
        </block>

        <block order="8">
          <cline>      largest = item;</cline>
        </block>

        <block order="5">
          <cline>    }  // end if</cline>
        </block>

        <block order="1">
          <cline>  } // end for</cline>
          <cline>  return largest;</cline>
        </block>

        <block order="7">
          <cline>} // end method</cline>
        </block>
      </blocks>
    </activity>

    <p>
      If you want to step through the correct code to see what it does in the
      Java Visualizer click on the following <url
      href="http://www.pythontutor.com/java.html#code=public+class+ArrayWorker%0A%7B%0A+++private+int%5B+%5D+values%3B%0A%0A+++public+ArrayWorker(int%5B%5D+theValues)%0A+++%7B%0A++++++values+%3D+theValues%3B%0A+++%7D%0A%0A+++public+double+getAverage()%0A+++%7B%0A+++++double+total+%3D+0%3B%0A+++++for+(int+val+%3A+values)%0A+++++%7B%0A+++++++total++%3D+total+%2B+val%3B%0A+++++%7D%0A+++++return+total+/+values.length%3B%0A+++%7D%0A+++%0A+++public+int+getLargest()%0A+++%7B%0A++%0A+++++int+largest+%3D+values%5B0%5D%3B%0A%0A+++++for+(int+item+%3A+values)%0A+++++%7B%0A%0A+++++++if+(item+%3E+largest)%0A+++++++%7B%0A%0A+++++++++largest+%3D+item%3B%0A%0A+++++++%7D++//+end+if+%0A%0A+++++%7D+//+end+for%0A+++++return+largest%3B%0A%0A+++%7D+//+end+method%0A%0A+++public+static+void+main(String%5B%5D+args)%0A+++%7B%0A+++++int%5B%5D+numArray+%3D++%7B2,+6,+7,+12,+5%7D%3B%0A+++++ArrayWorker+aWorker+%3D+new+ArrayWorker(numArray)%3B%0A+++++System.out.println(aWorker.getLargest())%3B%0A+++%7D%0A%7D%0A%0A&amp;mode=display&amp;curInstr=0">Java
      visualizer link</url>.
    </p>

    <activity label="minmax">
      <statement>
        <p>
          The code below finds the minimum (smallest element) in an array. Try
          it in the <url
          href="http://www.pythontutor.com/visualize.html#code=%20%20public%20class%20MinMax%0A%20%20%20%7B%20%20%20%20%20%20%0A%20%20%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20int%5B%20%5D%20values%20%3D%20%7B6,%202,%201,%207,%2012,%205%7D%3B%0A%20%20%20%20%20%20%20%20int%20min%20%3D%20values%5B0%5D%3B%20//%20initialize%20min%20to%20the%20first%20element%0A%20%20%20%20%20%20%20%20for%20%28int%20val%20%3A%20values%29%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20if%20%28val%20%3C%20min%29%20//%20found%20a%20new%20min!%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20min%20%3D%20val%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20System.out.println%28%22Min%20is%20%22%20%2B%20min%20%29%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%7D&amp;cumulative=false&amp;curInstr=20&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false&amp;curInstr=0">Java
          visualizer</url> with the CodeLens button. Can you change it to find
          the maximum element instead? Can you also compute the average of the
          elements?
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class MinMax
          {
              public static void main(String[] args)
              {
                  int[] values = {6, 2, 1, 7, 12, 5};
                  int min = values[0]; // initialize min to the first element
                  for (int val : values)
                  {
                      if (val < min) // found a new min!
                      {
                          min = val;
                      }
                  }
                  System.out.println("Min is " + min);
              }
          }

          ]]>
        </code>

        <tests>
          <![CDATA[

          // Test for Lesson MinMax
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("MinMax");

                  int[] numArray = {2, 6, 7, 12, 5};
                  setDefaultValues(new Object[] {numArray});
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect = "Max is 12";

                  boolean passed = output.contains(expect);

                  passed = getResults(expect, output, "Max element", passed);
                  assertTrue(passed);
              }

              @Test
              public void test2()
              {
                  String output = getMethodOutput("main");
                  String expect = "Average is 5.5";

                  boolean passed = output.contains(expect);

                  passed = getResults(expect, output, "Average", passed);
                  assertTrue(passed);
              }

              @Test
              public void test3()
              {
                  boolean passed = checkCodeContains("if statement using val >", "if (val >");
                  assertTrue(passed);
              }
          }

          ]]>
        </tests>
      </program>
    </activity>

    <p>
      When searching for an element or a minimum or maximum, it is important not
      to leave the loop early before finding the correct value and not to
      replace the value with subsequent ones.
    </p>

    <activity label="early_return_error">
      <statement>
        <p>
          Run the following code. Does it find 7 in the array? Click on Code
          Lens to trace through the code to see why not. Fix the early return
          error in the following code.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class FindError
          {
              public static boolean find(int[] array, int target)
              {
                 for (int val : array)
                 {
                    if (val == target)
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                 }
                 return false;
             }

              public static void main(String[] args)
              {
                  int[] values = {6, 2, 1, 7, 12, 5};
                  System.out.println(find(values, 7));
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("FindError");
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect = "true";

                  boolean passed = (output.equals(expect));
                  getResults(expect, output, "Testing main() output", passed);
                  assertTrue(passed);
              }

              @Test
              public void test2()
              {
                  int[] values = {-1, 0, 1};
                  String output = "" + FindError.find(values, 0);
                  String expect = "true";

                  boolean passed = getResults(expect, output, "Testing find({-1, 0, 1}, 0)");
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>

    <activity label="mcq_array_error1">
      <statement>
        <p>
          Given that <c>array</c> is an array of integers and <c>target</c> is
          an integer value, which of the following best describes the conditions
          under which the following code segment will return false?
        </p>

        <program>
          public boolean find(int[] array, int target)
          {
              for (int val : array)
              {
                  if (val == target)
                  {
                      return true;
                  }
                  else
                  {
                      return false;
                  }
              }
              return false;
          }
        </program>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>
              Whenever the first element in <c>array</c> is not equal to
              <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              Yes, the loop returns as soon as checking the first element,
              whether it is equal to target or not. It needs to check the whole
              array before returning false. The else statement should not be
              included.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              Whenever <c>array</c> contains any element which equals
              <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              This would be true if the else statement was not there, but it
              returns false right away after just checking the first element
              instead of going through all of the elements to makes sure none of
              them are equal to target.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Always</p>
          </statement>

          <feedback>
            <p>
              If the first element is equal to the target, it will return true.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Never</p>
          </statement>

          <feedback>
            <p>
              It will return false with the else statement if the first element
              is not equal to the target.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="mcq_array_error2">
      <statement>
        <p>
          Given that <c>array</c> is an array of integers and <c>target</c> is
          an integer value, which of the following best describes the conditions
          under which the following code segment will return true?
        </p>

        <program>
          boolean temp = false;
          for (int val : array)
          {
            temp = ( target == val );
          }
          return temp;
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>
              Whenever the first element in <c>array</c> is equal to
              <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              This would be true if the loop started at the end of the array and
              moved toward the beginning. But, it will loop from the first
              element to the last.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              Whenever <c>array</c> contains any element which equals
              <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              This would be true if temp was only set to the result of checking
              if the current element in the array is equal to <c>target</c> when
              it is <c>false</c>. But, it is reset each time through the loop.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>
              Whenever the last element in <c>array</c> is equal to
              <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              The variable <c>temp</c> is assigned to the result of checking if
              the current element in the array is equal to <c>target</c>. The
              last time through the loop it will check if the last element is
              equal to <c>val</c>.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              Whenever only 1 element in <c>array</c> is equal to <c>target</c>.
            </p>
          </statement>

          <feedback>
            <p>
              There is no count of the number of times the array element is
              equal to <c>target</c>.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="test-property">
    <title>Test Property</title>

    <p>
      Often we loop through an array to see if elements have a particular
      property, for example all the elements are even or at least one is
      negative. On the AP exam, this property is often given as a boolean method
      to use in the if statement to:
    </p>

    <p>
      <ul>
        <li>
          <p>Determine if at least one element has a particular property</p>
        </li>

        <li>
          <p>Determine if all elements have a particular property</p>
        </li>

        <li>
          <p>Determine the number of elements having a particular property</p>
        </li>
      </ul>
    </p>

    <p>
      Here are some patterns. Note that determining if <em>all</em> have a
      certain property means that we need to check all elements before returning
      true, so we often have to check for the negation of the property to return
      false.
    </p>

    <program>
      // see if at least one has the property
      for (int val : values)
      {
          if (isProperty(val))
          {
              return true;
          }
      }
      return false;

      // see if all have the property
      for (int val : values)
      {
          if (!isProperty(val))
          {
              return false;
          }
      }
      return true;

      // count the number of elements with the property
      int count = 0;
      for (int val : values)
      {
          if (isProperty(val))
          {
              count++;
          }
      }
    </program>

    <activity label="parsons-even-array" numbered="yes" adaptive="yes" indentation="show" language="java">
      <statement>
        <p>
          The following program segment should count the number of elements in
          the array that are even using an enhanced for each loop. But, the
          blocks have been mixed up. Drag the blocks from the left and put them
          in the correct order on the right. Click the Check button to check
          your solution.
        </p>
      </statement>

      <blocks>
        <block order="2">
          <cline>int[] arr = {14, -5, 2, 17, 29, -8, 36};</cline>
          <cline>int count = 0;</cline>
        </block>

        <block order="1">
          <cline>for (int value : arr)</cline>
          <cline>{</cline>
        </block>

        <block order="3">
          <cline>    if (value % 2 == 0)</cline>
          <cline>    {</cline>
        </block>

        <block order="6">
          <cline>        count++;</cline>
        </block>

        <block order="5">
          <cline>    } //end conditional</cline>
        </block>

        <block order="4">
          <cline>} //end for loop</cline>
        </block>
      </blocks>
    </activity>

    <activity label="exAllOdd">
      <statement>
        <p>
          Write the method allOdd to return true if all the values in the array
          are odd. First write the helper function isEven to return true or
          false for one value, using %.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class Test1
          {
              public static boolean isEven(int value)
              {
                  // 1. TODO: return true if value is even, false otherwise
                  return true;
              }

              public static boolean allOdd(int[] array)
              {
                  // 2. TODO: Loop thru the array
                  // and return false if any value isEven

                  // if all odd, return true
                  return true;
              }

              public static void main(String[] args)
              {
                  int[] a1 = {1, 3, 6};
                  int[] a2 = {1, 3, 5};
                  System.out.println(allOdd(a1));
                  System.out.println(allOdd(a2));
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "false\ntrue\n";

                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }
              @Test
              public void testMethod()
              {
                  int[] nums = {10, 20, 30, 40};
                  Object[] args = {nums};

                  String output = getMethodOutput("allOdd", args);
                  String expect = "false";

                  boolean passed = getResults(expect, output, "allOdd({10, 20, 30, 40})");
                  assertTrue(passed);
              }
              @Test
              public void testMethod2()
              {
                  int[] nums = {37,41,55,99};
                  Object[] args = {nums};

                  String output = getMethodOutput("allOdd", args);
                  String expect = "true";

                  boolean passed = getResults(expect, output, "allOdd({37,41,55,99})");
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>

    <p>
      Be careful not to jump out of loop too early when you are looking for a
      value in an array. The method below uses <term>return</term> statements to
      stop the execution of the method and return a value to the method that
      called this method. However, you must be careful not to stop the loop too
      soon.
    </p>

    <activity label="find_loop_early_return_error">
      <statement>
        <p>
          What is wrong with the code below? The first time through the loop it
          will start with the element at index 0 and check if the item at the
          array index equals the passed target string. If they have the same
          characters in the same order it will return 0, otherwise it will
          return -1. But, it has only processed one element of the array. How
          would you fix the code to work correctly (process all array elements
          before returning)?
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class StringWorker
          {
              private String[] arr = {"Hello", "Hey", "Good morning!"};

              public int findString(String target)
              {
                  String word = null;
                  for (int index = 0; index < arr.length; index++)
                  {
                      word = arr[index];

                      if (word.equals(target))
                      {
                          return index;
                      }
                      else
                      {
                          return -1;
                      }
                  }
                  return -1;
              }

              public static void main(String[] args)
              {
                  StringWorker sWorker = new StringWorker();
                  System.out.println(sWorker.findString("Hey"));
              }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("StringWorker");
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect = "1".replaceAll(" ", "\n");

                  boolean passed = (output.equals(expect));
                  getResults(expect, output, "Testing main() output", passed);
                  assertTrue(passed);
              }

              @Test
              public void test2()
              {
                  StringWorker sWorker = new StringWorker();
                  String output = "" + sWorker.findString("Good morning!");
                  String expect = "2";

                  boolean passed = getResults(expect, output, "Testing findString(\"Good morning!\")");
                  assertTrue(passed);
              }

              @Test
              public void test3()
              {
                  StringWorker sWorker = new StringWorker();
                  String output = "" + sWorker.findString("Hello!");
                  String expect = "-1";

                  boolean passed = getResults(expect, output, "Testing findString(\"Hello!\")");
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="pairs-and-duplicates-in-array">
    <title>Pairs and Duplicates in Array</title>

    <p>
      Here is a pattern to check for duplicates in an array by accessing a pair
      of elements next to each other, <c>array[i]</c> and <c>array[i+1]</c>.
      Note that we need to use an indexed for loop to get access to the next
      element.
    </p>

    <program>
      <![CDATA[

      // check for duplicates next to each other
      for (int i = 0; i < values.length - 1; i++)
      {
          if (values[i] == values[i + 1])
          {
              return true;
          }
      }
      return false;

      ]]>
    </program>

    <p>
      If we want to check for duplicates anywhere in the array, we need to use a
      nested loop to compare all pairs of elements in the array.
    </p>

    <program>
      <![CDATA[

      // check for duplicates anywhere in the array
      for (int i = 0; i < values.length; i++)
      {
          for (int j = i + 1; j < values.length; j++)
          {
              if (values[i] == values[j])
              {
                  return true;
              }
          }
      }
      return false;

      ]]>
    </program>

    <activity label="sumPairs">
      <statement>
        <p>
          Create a method <c>sumPairs10(nums)</c> returns <c>true</c> if there
          are at least two items in the array <c>nums</c> that are adjacent
          (next to each other) that add up to 10, otherwise return <c>false</c>.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class Pairs
          {
             public static boolean sumPairs10(int[] nums)
             {
                 // TODO: if two adjacent numbers in nums add up to 10, return true


                 return false;
             }

             public static void main(String[] args)
             {

                int[] nums1 = {1, 2, 8};
                System.out.println(sumPairs10(nums1));

                int[] nums2 = {2, 1, 2};
                System.out.println(sumPairs10(nums2));
             }

          }
        </code>

        <tests>
          import static org.junit.Assert.*;
          import org.junit.Test;
          import java.io.IOException;

          public class RunestoneTests extends CodeTestHelper {
             public RunestoneTests()
             {
                super("Pairs");
              }

             @Test
             public void testMain() throws IOException {
                String output = getMethodOutput("main");
                String expect = "true\nfalse\n";
                boolean passed = getResults(expect, output, "Expected output from main");
                assertTrue(passed);
             }
             @Test
             public void testMethod2()
             {
                   int[] nums = {2, 4, 6, 8};
                   Object[] args = {nums};

                   String output = getMethodOutput("sumPairs10", args);
                   String expect = "true";

                   boolean passed = getResults(expect, output, "sumPairs10({2, 4, 6, 8})");
                   assertTrue(passed);
               }
          }
        </tests>
      </program>
    </activity>

    <activity label="noDups">
      <statement>
        <p>
          Create a method <c>noDups(nums)</c> returns <c>true</c> if there are
          no repeated (duplicate) items in the array <c>nums</c>. It should
          return false if it does find a repeated element using nested loops.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class Pairs
          {
             public static boolean noDups(int[] nums)
             {
                 // TODO: use nested loops to check if any item appears more than once in nums


                 return true;
             }

             public static void main(String[] args)
             {

                int[] nums1 = {1, 2, 8};
                System.out.println(noDups(nums1));

                int[] nums2 = {3, 3, 3};
                System.out.println(noDups(nums2));
             }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;
          import org.junit.Test;
          import java.io.IOException;

          public class RunestoneTests extends CodeTestHelper {
             public RunestoneTests()
             {
                super("Pairs");
             }

             @Test
             public void testMain() throws IOException {
                String output = getMethodOutput("main");
                String expect = "true\nfalse\n";
                boolean passed = getResults(expect, output, "Expected output from main");
                assertTrue(passed);
             }
             @Test
             public void testMethod2()
             {
                   int[] nums = {2, 4, 6, 2};
                   Object[] args = {nums};

                   String output = getMethodOutput("noDups", args);
                   String expect = "false";

                   boolean passed = getResults(expect, output, "noDups({2, 4, 6, 2})");
                   assertTrue(passed);
               }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="rotating-array-elements">
    <title>Rotating Array Elements</title>

    <p>
      Rotating an array means shifting all the elements in the array to the
      right or left by one position. For example, if the array is {6, 2, 5, 3},
      rotating it to the right would give {3, 6, 2, 5}. To rotate an array, we
      need to copy the last element to the first position and then copy all the
      other elements to the next position. We can use a temporary variable to
      store the last element before overwriting it. If you do not want to change
      the original array, you can return a new array by copying in the rotated
      elements.
    </p>

    <activity label="rotateRightParsons" numbered="yes" adaptive="yes" indentation="show" language="java">
      <statement>
        <p>
          The following program segment is a method that should return an
          integer array that is rotated to the right – so {6, 2, 5, 3} returns
          {3, 6, 2, 5} (the parameter). Note that the method return type is
          int[] which means it will return an int array. But, the blocks have
          been mixed up and include one extra block that is not needed in a
          correct solution. Drag the blocks from the left and put them in the
          correct order on the right. Click the Check button to check your
          solution.
        </p>
      </statement>

      <blocks>
        <block order="3">
          <cline>public static int[] rotateRight(int[] arr)</cline>
          <cline>{</cline>
        </block>

        <block order="7">
          <cline>    int[] result = new int[arr.length];</cline>
        </block>

        <block order="2">
          <cline>    result[0] = arr[arr.length-1];</cline>
        </block>

        <block order="8">
          <cline>    for (int i = 0; i &lt; arr.length - 1; i++)</cline>
          <cline>    {</cline>
        </block>

        <block order="5" correct="no">
          <cline>    for (int i = 0; i &lt; arr.length; i++)</cline>
          <cline>    {</cline>
        </block>

        <block order="1">
          <cline>        result[i + 1] = arr[i];</cline>
        </block>

        <block order="4">
          <cline>    } //end for loop</cline>
        </block>

        <block order="9">
          <cline>    return result;</cline>
        </block>

        <block order="6">
          <cline>} //end shiftRight method</cline>
        </block>
      </blocks>
    </activity>

    <p>
      We can also rotate in place without constructing another array. We can
      copy the last element to the first position and then copy all the other
      elements to the next position. We need to use an indexed loop to access
      the elements at different indices. When you pass an array to a method,
      you’re actually passing a reference to the array’s memory location. This
      means that any changes made to the array within the method will affect the
      original array.
    </p>

    <activity label="rotate">
      <statement>
        <p>
          The code below rotates array elements to the left in place without
          constructing another array. Try it in the <url
          href="http://www.pythontutor.com/visualize.html#code=public%20class%20Rotate%0A%20%20%20%7B%20%20%20%20%20%20%0A%20%20%20%20%20%20public%20static%20void%20main%28String%5B%5D%20args%29%0A%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20int%5B%20%5D%20values%20%3D%20%7B6,%202,%201,%207,%2012,%205%7D%3B%0A%20%20%20%20%20%20%20%20int%20first%20%3D%20values%5B0%5D%3B%0A%20%20%20%20%20%20%20%20for%20%28int%20i%3D0%3B%20i%20%3C%20values.length%3B%20i%2B%2B%29%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20//%20if%20it's%20not%20the%20last%20element,%20copy%20the%20next%20one%20over%0A%20%20%20%20%20%20%20%20%20%20if%20%28i%20%3C%20values.length%20-%201%29%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20values%5Bi%5D%20%3D%20values%5Bi%2B1%5D%3B%0A%20%20%20%20%20%20%20%20%20%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20//%20last%20element%20gets%20first%0A%20%20%20%20%20%20%20%20%20%20%20%20%20values%5Bi%5D%20%3D%20first%3B%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20//%20print%20them%20out%20to%20see%20the%20results%0A%20%20%20%20%20%20%20%20for%20%28int%20val%20%3A%20values%29%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20System.out.print%28val%20%2B%20%22%20%22%29%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%0A%20%20%20%7D%0A%20%20&amp;cumulative=false&amp;curInstr=47&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false&amp;curInstr=0">Java
          visualizer</url> with the CodeLens button. Can you change it to rotate
          the elements to the right instead? Hint: use a backwards loop.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class Rotate
          {
              public static void main(String[] args)
              {
                  int[] values = {6, 2, 1, 7, 12, 5};
                  int first = values[0];
                  for (int i = 0; i < values.length; i++)
                  {
                      // if it's not the last element, copy the next one over
                      if (i < values.length - 1)
                      {
                          values[i] = values[i + 1];
                      }
                      else
                      {
                          // last element gets first
                          values[i] = first;
                      }
                  }
                  // print them out to see the results
                  for (int val : values)
                  {
                      System.out.print(val + " ");
                  }
              }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("Rotate");
              }

              @Test
              public void test1()
              {
                  String output = getMethodOutput("main");
                  String expect = "5 6 2 1 7 12";

                  boolean passed = output.contains(expect);

                  passed = getResults(expect, output, "Rotate numbers to the right", passed);
                  assertTrue(passed);
              }

              @Test
              public void test3()
              {
                  boolean passed =
                          checkCodeContains("copying values[i-1] into values[i]", "values[i] = values[i-1]");
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="reversing-an-array">
    <title>Reversing an Array</title>

    <p>
      Reversing an array is similar to rotating it. We can copy the first
      element to the last position, the second element to the second-to-last
      position, and so on. We can use a temporary variable to store the value of
      the element we are overwriting. We usually need an indexed loop to access
      the elements at different indices unless we use a temporary array to store
      the reversed elements. Note that arrays are passed as references to
      methods, so any changes made to the array within the method will affect
      the original array.
    </p>

    <p>
      The following programs show how you can reverse an array in place by
      swapping elements. The first uses a while loop and the second an indexed
      for loop. To swap two elements, you need to use a temp variable to store
      the value of the element you are overwriting. Imagine that you have a
      glass of milk and a glass of orange juice. How would you swap the contents
      of the two glasses without making a huge mess? You would need a third
      glass to hold the contents of one of the glasses while you pour the
      contents of the other glass into it. Then you can pour the contents of the
      third glass into the other glass. This is the same idea behind swapping
      elements in an array.
    </p>

    <figure align="center">
      <caption>Swapping elements in an array</caption>

      <image source="Unit4-Data-Collections/Figures/swap.png" width="54%" />
    </figure>

    <program>
      // Swapping 2 elements at index i and j
      int temp = array[i];  // pour milk into temp cup
      array[i] = array[j];  // pour orange juice into milk glass
      array[j] = temp;      // pour milk from temp into oj glass
    </program>

    <activity label="parsons_array_reverse" numbered="yes" adaptive="yes" indentation="hide" language="java">
      <statement>
        <p>
          The following method reverses an array in place using an indexed for
          loop and a temp variable to swap the first and last items, but the
          code blocks are mixed up. Drag the blocks from the left and put them
          in the correct order on the right. Click the Check button to check
          your solution.
        </p>
      </statement>

      <blocks>
        <block order="8">
          <cline>public static void reverse(int[] a)</cline>
          <cline>{</cline>
        </block>

        <block order="5">
          <cline>  int temp = 0;</cline>
          <cline>  int half = a.length / 2;</cline>
          <cline>  int max = a.length - 1;</cline>
        </block>

        <block order="6">
          <cline>  for (int i = 0; i &lt; half; i++)</cline>
          <cline>  {</cline>
        </block>

        <block order="2">
          <cline>     temp = a[i];</cline>
        </block>

        <block order="7">
          <cline>     a[i] = a[max - i];</cline>
        </block>

        <block order="3">
          <cline>     a[max - i] = temp;</cline>
        </block>

        <block order="1">
          <cline>  } // end for</cline>
        </block>

        <block order="4">
          <cline>} // end method</cline>
        </block>
      </blocks>
    </activity>

    <activity label="parsons_array_reverse2" numbered="yes" adaptive="yes" indentation="hide" language="java">
      <statement>
        <p>
          The following method reverses an array in place using a while loop and
          a temp variable to swap the first and last items. But, the blocks have
          been mixed up and include two extra blocks that are not needed in a
          correct solution. Drag the blocks from the left and put them in the
          correct order on the right. Click the Check button to check your
          solution.
        </p>
      </statement>

      <blocks>
        <block order="4">
          <cline>public static void reverse(int[] array)</cline>
          <cline>{</cline>
        </block>

        <block order="7">
          <cline>   int start = 0;</cline>
          <cline>   int end = array.length - 1;</cline>
        </block>

        <block order="6">
          <cline>   while (start &lt; end)</cline>
          <cline>   {</cline>
        </block>

        <block order="5" correct="no">
          <cline>   for(int i = start; i &lt; end; i++)</cline>
          <cline>   {</cline>
        </block>

        <block order="9">
          <cline>     int temp = array[start];</cline>
        </block>

        <block order="2">
          <cline>     array[start] = array[end];</cline>
        </block>

        <block order="10">
          <cline>     array[end] = temp;</cline>
        </block>

        <block order="1">
          <cline>     start++;</cline>
          <cline>     end--;</cline>
        </block>

        <block order="3" correct="no">
          <cline>     start++;</cline>
        </block>

        <block order="8">
          <cline>   }</cline>
          <cline>}</cline>
        </block>
      </blocks>
    </activity>

    <activity label="reverseArrayCode">
      <statement>
        <p>
          Create a method <c>reverse</c> that reverses an array in place using a
          temp variable.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          import java.util.Arrays;

          public class ReverseTest
          {
              public static void reverse(String[] array)
              {
                  // TODO: reverse array in place using a temp variable to swap elements

              }

              public static void main(String[] args)
              {
                  String[] a1 = {"p","a","w","s"};
                  reverse(a1);
                  System.out.println(Arrays.toString(a1));
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;
          import java.util.Arrays;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                super("ReverseTest");
              }

              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "[s, w, a, p]";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }
              @Test
              public void testMethod2()
              {
                  String[] a = {"r","a","t","s"};
                  ReverseTest.reverse(a);
                  String output = Arrays.toString(a);
                  String expect = "[s, t, a, r]";

                  boolean passed = getResults(expect, output, "reverse({r, a, t, s})");
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>

    <activity label="mcq_array_infinite">
      <statement>
        <p>
          Given the following code segment, which of the following will cause an
          infinite loop? Assume that <c>temp</c> is an int variable initialized
          to be greater than zero and that <c>a</c> is an array of integers.
        </p>

        <program>
          <![CDATA[

          for (int k = 0; k < a.length; k++) {
             while (a[k] < temp) {
                a[k] *= 2;
             }
          }

          ]]>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>
              The values don't matter this will always cause an infinite loop.
            </p>
          </statement>

          <feedback>
            <p>An infinite loop will not always occur in this code segment.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>
              Whenever <c>a</c> includes a value that is less than or equal to
              zero.
            </p>
          </statement>

          <feedback>
            <p>
              When <c>a</c> contains a value that is less than or equal to zero
              then multiplying that value by 2 will never make the result larger
              than the <c>temp</c> value (which was set to some value &gt; 0),
              so an infinite loop will occur.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Whenever <c>a</c> has values larger then <c>temp</c>.</p>
          </statement>

          <feedback>
            <p>
              Values larger then <c>temp</c> will not cause an infinite loop.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>When all values in <c>a</c> are larger than <c>temp</c>.</p>
          </statement>

          <feedback>
            <p>
              Values larger then <c>temp</c> will not cause an infinite loop.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Whenever <c>a</c> includes a value equal to <c>temp</c>.</p>
          </statement>

          <feedback>
            <p>Values equal to <c>temp</c> will not cause the infinite loop.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection>
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 4.5.A.1) There are standard algorithms that utilize array
            traversals to:
          </p>

          <p>
            <ul>
              <li>Determine a minimum or maximum value</li>

              <li>Compute a sum or average</li>

              <li>
                Determine if at least one element has a particular property
              </li>

              <li>Determine if all elements have a particular property</li>

              <li>
                Determine the number of elements having a particular property
              </li>

              <li>Access all consecutive pairs of elements</li>

              <li>Determine the presence or absence of duplicate elements</li>

              <li>Shift or rotate elements left or right</li>

              <li>Reverse the order of the elements</li>
            </ul>
          </p>
        </li>
      </ul>
    </p>
  </subsection>
</section>
