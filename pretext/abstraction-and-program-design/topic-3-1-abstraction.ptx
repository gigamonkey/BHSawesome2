<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-3-1-abstraction">
  <title>Abstraction</title>

  <introduction>
    <p>
      An <term>abstraction</term> is something that captures the important idea
      of something while ignoring irrelevant details. Almost all of programming
      is about creating abstractions at various levels so we can think clearly
      about how our programs work without getting mired in a million distracting
      details.
    </p>

    <p>
      By layering abstractions we can build up from the very primitive
      capabalities of the computer (basically to do arithmetic very fast) to
      things humans care about like playing games, browsing the web, editing
      videos, or anything else people use computers for.
    </p>

    <p>
      Learning to manage abstractions is in some sense the key to becoming a
      good programmer.
    </p>

  </introduction>

  <subsection xml:id="naming-abstraction">
    <title>Names as abstraction</title>

    <p>
      The simplest form of abstraction is to give something a name. We do this
      all the time outside of programming: when we talk about “students” we’re
      capturing the abstract idea of a whole group of people and what they have
      in common as members of that group, while ignoring many details that make
      each student a unique individual.
    </p>

    <p>
      In programming we also name things all the time and every name is a bit of
      abstraction. When we declare a variable like:
    </p>

    <program>
      int total = 0;
    </program>

    <p>
      we are creating an abstract notion of a total that could take on different
      values but will always represent the total of something we’re keeping
      track of. We can think of every variable as an abstraction over all the
      values that variable could possibly take on.
    </p>

    <p>
      When we use a variable in an expression like:
    </p>

    <program>
      <![CDATA[
      total > 100
      ]]>
    </program>

    <p>
      then we’re build a slightly higher level abstraction of checking whether a
      our abstract value <c>total</c> is greater than a specific concrete value.
      This expression works for any possible value for total and could be used
      in an <c>if</c> statement to decide whether to do something or not. Of
      course if we had another variable, <c>goal</c>, that abstracted away the
      specific value <c>100</c>, we could write an even more abstract
      expression:
    </p>

    <program>
      <![CDATA[
      total > goal
      ]]>
    </program>

    <p>
      to capture the idea of the total we are accumulating being greater than
      some goal that has been set elsewhere in some way we don’t have to worry
      about when we think about what this expression means.
    </p>

    <p>
      So once we have the ability to name things we have the ability to create
      new higmer levels of abstraction. Let’s look at a few of the main kinds of
      abstraction.
    </p>
  </subsection>

  <subsection xml:id="data-abstraction">
    <title>Data abstraction</title>

    <p>
      <term>Data abstraction</term> is one of the simplest kinds of abstraction.
      A data abstraction hides the exact details of how something is represented
      in the computer’s memory and lets us focus instead of what we can do with
      it.
    </p>

    <p>
      Java’s primitive are a form of data abstraction. While the details of
      exactly how <c>int</c> and <c>double</c> values are represented are
      actually specified (an <c>int</c> is alwaays 32 bits, etc.) most of the
      time we can ignore those details and just focus on what we can do with
      those values—add them, multiply them, etc. That is a lot easier to think
      about than if we had to think about exactly what is happening at the level
      of the bits every time we multiplied two numbers.
    </p>

    <p>
      It’s worth noting that no abstraction is perfect. For example when do
      arithmetic with <c>int</c> values, the abstraction breaks down around the
      limits <c>Integer.MAX_VALUE</c> or <c>Integer.MIN_VALUE</c>. In the
      abstract, adding one to a positive integer should always yield a larger
      number but if we add one to <c>Integer.MAX_VALUE</c> we get a negative
      number because of the way <c>int</c> values are represented! But most of
      the time we don’t have to think about those details.
    </p>

    <p>
      Classes provide an even more flexible form of data abstraction. When we
      write a class we have to specify exactly how the data is stored in
      instance variables but when we <em>use</em> a well-designed class we don’t
      have to care or even know. For example, we can use Java’s <c>String</c>
      class or the turtle library’s <c>Turtle</c> class without needing to know
      exactly how those classes store the information that makes up each
      instance.
    </p>
  </subsection>

  <subsection xml:id="procedural-abstraction">
    <title>Procedural abstraction</title>

    <p>
      A <term>procedural abstraction</term> lets us give a name to a process for
      computing a result or producing some side effect so we can use that
      process without having to think about all the details of how the
      computation is performed.
    </p>

    <p>
      In Java, we create procedural abstractions by writing methods. For
      instance a method named <c>doubled</c> that takes an <c>int</c> argument
      and returns a value that is twice the argument creates an abstraction of
      the idea of doubling a number.
    </p>

    <program>
      <![CDATA[
      public int doubled(int n) {
        // detail hidden here. Could be n * 2 or n + n or even n << 1;
      }
      ]]>
    </program>

    <p>
      We can also abstract computations with side effects. For example, the
      <c>forward</c> method in the <c>Turtle</c> class abstracts the idea of
      moving the turtle forward. We don’t need to know exactly how the turtle is
      animated to move forward to use the method.
    </p>

    <p>
      Procedural abstractions are typically built in layers via <term>method
      decomposition</term>. When we <term>decompose</term> a method we break it
      down into smaller parts which we then implement as their own methods.
      Here’s a toy example:
    </p>

    <program>
      <![CDATA[
      public double hypotenuse(double a, double b) {
        return Math.sqrt(square(a) + square(b));
      }

      public double square(double n) {
        return n * n;
      }
      ]]>
    </program>

    <p>
      The <c>hypotenuse</c> method abstracts the computation of the length of
      the hypotenuse of a right triangle from the lengths of the triangle’s legs
      using the Pythogarean theorem. But it is built on top of two other
      procedural abstractions: <c>Math.sqrt</c> which comes from Java’s
      <c>Math</c> class and <c>square</c>, a method we wrote to abstract the
      idea of squaring a <c>double</c> value.
    </p>

    <p>
      While making a method to abstract <c>n * n</c> is maybe taking things a
      bit too far it demonstrates the idea. By decomposing a method into helper
      methods, each method is an abstraction that we can think about on its own.
      We can ask, does <c>square</c> do what it’s supposed to do? Once we’re
      sure about that we can ask, does <c>hypotenuse</c> correctly implement the
      Pythogarean theorem, if we assume that <c>Math.sqrt</c> and <c>square</c>
      work correctly? Whereas if we had written <c>hypotenuse</c> to do the
      squaring inline as <c>a * a</c> and <c>b * b</c> it would probably still
      be understandable but we’d have decode those two expressions to recognize
      that they are doing the squaring called for my the Pythogarean theorem.
    </p>

    <p>
      In general decomposing methods down to the point where each method can be
      expressed in less than a half dozen lines of code is actually a good idea
      with several benefits:
    </p>

    <p>
      <ul>
        <li>
          <p>
            Avoiding repetition: Putting even small bits of code that are
            duplicated throughout a program into a method and then replacing the
            code with calls to the method can make the overall program shorter
            and easier to understand.
          </p>
        </li>

        <li>
          <p>
            Reducing complexity: even methods that are only used once, help
            divide a program into smaller pieces that are each easier to
            understand and get correct than one big method that does a lot of
            things. Smaller methods are easier to debug and understand because
            they do less.
          </p>
        </li>

        <li>
          <p>
            Maintainability: very little code is written and never changed. When
            methods are decomposed and duplicate code removed by putting it into
            methods it is easier to make changes. If you ever find yourself
            fixing a bug and having to make the same changes in a bunch of
            different places in your program that’s a sign that that code should
            probably have been put into its own method s you could make the fix
            in one place.
          </p>
        </li>
      </ul>
    </p>

    <activity label="OldMacDonaldSongRepeated">
      <statement>
        <p>
          As a review, let’s deconstruct the song “Old MacDonald” into methods with
          parameters to avoid repetition of code, as in Unit 1.
        </p>

        <p>
          Complete the methods <c>chorus()</c> and <c>verse()</c>. Add method
          calls in main.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          public class OldMacDonaldSong
          {
              public static void intro()
              {
                  System.out.println("Old MacDonald had a farm");
                  chorus();
              }

              /* Complete the following method to print E-I-E-I-O */
              public static void chorus()
              {

              }

              /* Complete the following method to print the verse for the given animal and sound.
                 For example, for a cow and moo, it should print out
                 "And on this farm, they had a cow. E-I-E-I-O
                 With a moo moo here and a moo moo there,
                 here a moo, there a moo, everywhere a moo moo".
                 Make sure to use the variables animal and sound and the method chorus()!
              */
              public static void verse(String animal, String sound)
              {

              }

              public static void main(String[] args)
              {
                  intro();
                  verse("cow","moo");
                  intro();
                  // TODO:
                  // Call verse again with duck and quack
                  //   and then call intro again


                  // Call verse again with another animal and sound
                  //  and then call intro again


               }
          }
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testVar1()
              {
                  boolean passed = checkCodeContains("use of animal variable in verse", "+ animal");
                  assertTrue(passed);
              }
              @Test
              public void testVar2()
              {
                  boolean passed = checkCodeContains("use of sound variable in verse", "+ sound");
                  assertTrue(passed);
              }
              @Test
              public void testCall()
              {
                  boolean passed = checkCodeContains("call to verse with duck and quack", "verse(\"duck\", \"quack\");");
                  assertTrue(passed);
              }
              @Test
              public void test1()
              {
                  String code = getCode();
                  int num = countOccurences(code, "intro();");

                  boolean passed = num >= 4;

                  passed = getResults("4 or more", "" + num, "Calls to intro", passed);
                  assertTrue(passed);
              }
               @Test
              public void test2()
              {
                  String code = getCode();
                  int num = countOccurences(code, "chorus();");

                  boolean passed = num >= 2;

                  passed = getResults("2 or more", "" + num, "Call chorus() in intro and verse", passed);
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>
      </program>
    </activity>
  </subsection>


  <subsection xml:id="object-oriented-design">
    <title>Class abstraction</title>

    <p>
      In object-oriented languages like Java we can use <term>class
      abstraction</term> as a yet higher-level kind of abstraction that
      combines data abstraction and procedural abstraction.
    </p>

    <p>
      When designing a program we often start by deciding which classes are
      needed by thinking about the <term>nouns</term> we use when talking about
      the program. The main nouns then become classes in our program and we use
      data abstraction within in the class by defining the instance variables
      that make up the class and procedural abstraction by write the methods
      that define what we can do with instances of the class.
    </p>

    <p>
      For instance, if we wrote a description of the turtle drawing library
      we’ve used in earlier chapters it would probably contain a phrase like,
      “make turtles that can exist on a 2-dimensional world and can draw lines
      by moving around the world”. The main nouns in that description are
      “turtle” and “world” and indeed the classes in the system are
      <c>Turtle</c> and <c>World</c>.
    </p>

    <p>
      Then we can look for <term>verbs</term> like “move” and “draw” to identify
      the things we need to be able to do with these classes.
    </p>

    <activity label="OOD1">
      <statement>
        <p>
          You’ve been hired by your school to create a program that keeps track
          of “students at your school and the courses they are taking”. Name two
          classes that you would create in your program. Name two attributes
          (data kept in instance variables) for each class.
        </p>
      </statement>

      <response />
    </activity>

    <p>
      The two nouns in the problem description above, <term>Student</term> and
      <term>Course</term> would make good class names! Then, you can think about
      what data you need to keep track of for students and courses and what
      methods you need. For example, for the Student class, you might need to
      keep track of the student’s name and grade level. For the Course class,
      you might need to keep track of the course name and the teacher’s name.
      What other attributes did you and your classmates come up with?
    </p>
  </subsection>

  <subsection xml:id="uml-class-diagrams">
    <title>Class diagrams</title>

    <p>
      Sometimes it’s useful, when designing a complex system with lots of
      classes, to make diagrams of the classes that show you at a glance what
      instance variables and methods they have. Often these can just be sketches
      in your notebook or on a whiteboard but there are also more formal systems
      such as the <term>Unified Modeling Language (UML)</term> for drawing these
      diagrams.
    </p>

    <p>
      For example, here is a UML class diagram for the <c>Turtle</c> class which
      includes a list of its attributes and behaviors. <term>Class
      Diagrams</term> are a way to represent the classes in a program and the
      data and procedural abstractions found in each class. The attributes are
      the instance variables and the methods are the behaviors of the class. The
      <c>-</c> in front of the attributes indicate that they are private, and
      the <c>+</c> in front of the methods indicate that they are public. Here
      is a <url
      href="https://medium.com/@smagid_allThings/uml-class-diagrams-tutorial-step-by-step-520fd83b300b">tutorial
      on class diagrams</url> that explains it in more detail if you are curious
      but class diagrams are not on the AP CSA exam. If you want to draw your
      own, <url href="https://app.diagrams.net/">app.diagrams.net</url> or <url
      href="https://creately.com">Creately.com</url> are good free online
      drawing tools for UML class diagrams.
    </p>

    <figure align="center">
      <caption>Turtle Class Diagram</caption>

      <image source="Unit3-Class-Creation/Figures/turtleUMLClassDiagram.png" width="63%">
        <shortdescription>Turtle class diagram</shortdescription>
      </image>
    </figure>

    <p>
      Class diagrams themselves are a knid of abstraction: they shows the main
      structure of a class so we can think about it without showing all the
      details of the code we’d have to write to implement the class.
    </p>
  </subsection>


  <subsection xml:id="group-challenge-game-design">
    <title>Group Challenge: Game Design</title>

    <p>
      Working in groups, let’s explore making a computer game that is an
      adaptation of a board game that you know. Think about what objects are in
      the game. For example, here is the description for Monopoly (trademark
      Hasbro games):
    </p>

    <p>
      <ul>
        <li>
          <p>
            “Buy, sell, dream and scheme your way to riches. Players buy, sell
            and trade to win. Build houses and hotels on your properties and
            bankrupt your opponents to win it all. Chance and Community Chest
            cards can change everything.”
          </p>
        </li>
      </ul>
    </p>

    <p>
      What classes would you need to create a computer version of this game?
      (Remember to look for the nouns). Take one of the classes you listed, and
      try to come up with two pieces of data in that class that will be the
      instance variables. Then, come up with two methods (look for verbs) for
      the class that use the data in the instance variables. Write your answers
      below.
    </p>

    <p>
      If your class has time, you could explore drawing a UML class diagram for
      your class using an online tool like <url
      href="https://creately.com">Creately.com</url> or <url
      href="https://app.diagrams.net/">app.diagrams.net</url> using this <url
      href="https://medium.com/@smagid_allThings/uml-class-diagrams-tutorial-step-by-step-520fd83b300b">tutorial
      on class diagrams</url>
    </p>

    <project label="OOD2">
      <statement>
        <p>
          Say you wanted to make a computer game from a board game that you are
          playing. Think about what objects are in the game. For example, here
          is the description for Monopoly (trademark Hasbro games): “Buy, sell,
          dream and scheme your way to riches. Players buy, sell and trade to
          win. Build houses and hotels on your properties and bankrupt your
          opponents to win it all. Chance and Community Chest cards can change
          everything.” What classes would you need to create a computer version
          of this game? (Remember to look for the nouns). Take one of the
          classes you listed, and try to come up with 2 pieces of data in that
          class that will be the instance variables. Then, come up with 2
          methods (look for verbs) for the class that use the data in the
          instance variables.
        </p>
      </statement>

      <response />
    </project>
  </subsection>

  <subsection xml:id="summary-27">
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 3.1.A.1) <term>Abstraction</term> is the process of reducing
            complexity by focusing on the main idea. By hiding details
            irrelevant to the question at hand and bringing together related and
            useful details, abstraction reduces complexity and allows one to
            focus on the idea.
          </p>
        </li>

        <li>
          <p>
            (AP 3.1.A.2) <term>Data abstraction</term> provides a separation
            between the abstract properties of a data type and the concrete
            details of its representation. Data abstraction manages complexity
            by giving data a name without referencing the specific details of
            the representation. Data can take the form of a single variable or a
            collection of data, such as in a class or a set of data.
          </p>
        </li>

        <li>
          <p>
            (AP 3.1.A.3) An <term>attribute</term> is a type of data abstraction
            that is defined in a class outside any method or constructor. An
            <term>instance variable</term> is an attribute whose value is unique
            to each instance of the class. A <term>class variable</term> is an
            attribute shared by all instances of the class.
          </p>
        </li>

        <li>
          <p>
            (AP 3.1.A.4) <term>Procedural abstraction</term> provides a name for
            a process and allows a method to be used only knowing what it does,
            not how it does it. Through <term>method decomposition</term>, a
            programmer breaks down larger behaviors of the class into smaller
            behaviors by creating methods to represent each individual smaller
            behavior. A procedural abstraction may extract shared features to
            generalize functionality instead of duplicating code. This allows
            for code reuse, which helps manage complexity.
          </p>
        </li>

        <li>
          <p>
            (AP 3.1.A.5) Using parameters allows procedures to be generalized,
            enabling the procedures to be reused with a range of input values or
            arguments.
          </p>
        </li>

        <li>
          <p>
            (AP 3.1.A.6) Using procedural abstraction in a program allows
            programmers to change the internals of a method (to make it faster,
            more efficient, use less storage, etc.) without needing to notify
            method users of the change as long as the method signature and what
            the method does is preserved.
          </p>
        </li>

        <li>
          <p>
            (AP 3.1.A.7) Prior to implementing a class, it is helpful to take
            time to design each class including its attributes and behaviors.
            This design can be represented using natural language or diagrams.
          </p>
        </li>
      </ul>
    </p>
  </subsection>
</section>
