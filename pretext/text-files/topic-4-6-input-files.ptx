<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-4-6-input-files">
  <title>Data from files</title>

  <idx>files</idx>
  <idx>Scanner</idx>
  <idx>IOException</idx>
  <idx>FileNotFoundException</idx>
  <idx>try</idx>
  <idx>catch</idx>
  <idx>throws</idx>
  <idx>data files</idx>
  <introduction>
    <p>
      Files are used to store data in software that we use every day. For
      example, when you play a game on your computer, your game progress is
      saved in a file. The next time you play that game, your game progress is
      loaded in from that file, so you can continue where you left off. In this
      lesson, you will learn how to read in data from a file in Java.
    </p>

    <p>
      A <term>file</term> is storage for data that <em>persists</em> when the
      program is not running. The data in a file can be retrieved during program
      execution. For example in <xref ref="topic-4-4-array-traversal" />, you
      created a <c>SpellChecker</c> class that reads in a dictionary file into
      an array of words, and a <c>spellcheck</c> method that uses this array to
      verify if a word is spelled correctly. Input files like the dictionary
      enable us to handle large amounts of data efficiently. Instead of manually
      entering data into our program every time it runs, we can store the data
      in a file and read it as needed. Another benefit of using files is the
      ability to separate the data from the code, allowing for more modular and
      flexible software design.
    </p>
  </introduction>

  <subsection xml:id="File-Scanner-IOException">
    <title><c>File</c> and <c>Scanner</c></title>

    <p>
      These days there are two sets of classes for interacting with files from
      Java. We’ll start with the more traditional way which is part of the AP
      curriculum. Then later we’ll look at a more modern and slightly more
      convenient way.
    </p>

    <p>
      The first thing we need is an object to represent a file on our computer.
      The traditional way—and the AP way—is with the class <c>File</c> in the
      package <c>java.io</c>. The <c>io</c> in the package name stands for
      <term>I/O</term> which is itself an abbreviation for
      <term>Input/Output</term> since the classes in that package are all
      related to moving data into a program (input) and back out (output).
    </p>

    <p>
      A <c>File</c> object can be constructed with a contstructor that takes a
      <c>String</c> containing the name of the file. For example if we want to
      use a file named <c>data.txt</c> we can construct a <c>File</c> object
      like this:
    </p>

    <program>
      import java.io.*;
      ...
      File dataFile = new File("data.txt");
    </program>

    <p>
      At this point the file doesn’t even need to exist. We just have a way to
      refer to such a file. But if it does exist and we want to read data from
      it we need to <term>open</term> the file with some object that knows how
      to read data from it. There are a number of classes in Java for doing that
      depending on how we want to access the data. In the AP curriculum we use
      the class <c>Scanner</c> which is in the package <c>java.util</c>, the
      same package as <c>ArrayList</c>. If we construct a <c>Scanner</c> with a
      <c>File</c> object as an argument we get a <c>Scanner</c> that we can use
      to read data from the file on our harddrive.
    </p>

    <program>
      import java.io.*;
      import java.util.*;
      ...
      File dataFile = new File("data.txt");
      Scanner data = new Scanner(dataFile);
    </program>

    <p>
      A single <c>Scanner</c> can be used repeatedly to read from the same file.
      It has a number of methods that will each read different data from the
      underlying file and it keeps track of where it left off so calling the
      same method multiple times will probably return different things each time
      as the <c>Scanner</c> advances through the file.
    </p>

    <p>
      The simplest of these methods to use is <c>nextLine</c> which reads the
      next complete line from the file, up to the next newline character or the
      end of the file and returns it as a <c>String</c> with the newline
      removed. Often, as we’ll see in the next section, the easiest way to read
      data from a file is to read it a line at a time and then use various
      methods on <c>String</c> and the wrapper classes <c>Integer</c> and
      <c>Double</c> to take apart the <c>String</c> and convert the parts to the
      data types we actually want.
    </p>

    <p>
      But <c>Scanner</c> does provide some other methods that are part of the AP
      curriculum ande are listed on the <url
      href="https://apcentral.collegeboard.org/media/pdf/ap-computer-science-a-java-quick-reference.pdf">Java
      Quick Reference</url>.
    </p>

    <p>
      <ul>
        <li><c>nextInt</c> - reads the next bit of text and tries to parse it as an <c>int</c> value.</li>
        <li><c>nextDouble</c> - reads the next bit of text and tries to parse it as a <c>double</c> value.</li>
        <li><c>nextBoolean</c> - reads the next bit of text and tries to parse it as an <c>boolean</c> value.</li>
        <li><c>next</c> - reads and return the next <term>token</term> as a <c>String</c></li>
        <li><c>hasNext</c> - returns true if there is another token to read</li>
        <li><c>close</c> - closes the <c>Scanner</c> and the underlying file so
        no more data can be read from it</li>
      </ul>
    </p>

    <p>
      In practice the methods other than <c>nextLine</c> are tricky to use
      because of the way the <c>Scanner</c> decides whether there’s another
      token. One method that is not part of the AP curriculum but which goes
      very well with <c>nextLine</c> is <c>hasNextLine</c> which returns a
      boolean indicating whether it is possible got get another line with
      <c>nextLine</c>.
    </p>

    <p>
      For instance if we wanted to load all the lines from a file into an
      <c>ArrayList</c> we could do it fairly simply with this code:
    </p>

    <program>
      <![CDATA[
      import java.io.*;
      import java.util.*;
      ...
      ArrayList<String> lines = new ArrayList<>();
      File dataFile = new File("data.txt");
      Scanner data = new Scanner(dataFile);

      while (data.hasNextLine()) {
        lines.add(data.nextLine());
      }
      ]]>
    </program>
  </subsection>

  <subsection>
    <title><c>IOException</c></title>
    <p>
      In earlier chapters we saw that if we wrote code that tried to do
      something impossible such as accessing an element of an array at an index
      that didn’t exist or invoking a method on a <c>null</c> reference, Java
      would through an exception like an <c>ArrayIndexOutOfBoundsException</c>
      or <c>NullPointerException</c>.
    </p>

    <p>
      Exceptions are how Java handles situations where a
      <term>precondition</term>, like we discussed in <xref
      ref="topic-1-8-comments" /> is not met causing a bit of code to be unable
      to satisfiy its <term>postcondition</term>. For instance there’s an
      implicit precondition whenever we try to access an array element that the
      index is valid and if it’s not, there’s no way for the array access
      expression to satisfy the postcondition of returning the value at that
      index.
    </p>

    <p>
      Creating a <c>Scanner</c> has a precondition that the file represented by
      the <c>File</c> object actually exists; if it doesn’t there’s no way to
      make a <c>Scanner</c> that can read data from it. This can happen for
      reasons that have nothing to do with bugs in the program. Maybe the user
      misspelled the file name or accidentally deleted it before they ran the
      program.
    </p>

    <p>
      Whatever the reason, if the file does not exist or is otherwise
      inaccessible, the <c>Scanner</c> constructor will <term>throw</term> a
      <c>FileNotFoundException</c>. Exceptions are organized into hierarchies
      and in real-world Java programs there are ways to handle exceptions so
      they don’t crash our program. <c>FilNotFoundException</c> is one of the
      exceptions in the <c>IOException</c> hierarchy which represents various
      things that can go wrong when trying to read and write data.
    </p>

    <p>
      Unlike <c>ArrayIndexOutOfBoundsException</c> and
      <c>NullPointerException</c>, <c>IOException</c> is something called a
      <term>checked exception</term> which means that Java requires us to
      specify what we will do if one is thrown. There are basically two choices.
      The simplest is to add <c>throws IOException</c> after the argument list
      of the method that contains the line creates the <c>Scanner</c>. This is
      basically passin the buck: the method is saying, this bad thing can happen
      and I can’t recover if it does so it is now the responsibility of whatever
      methods call me to deal with it. Those methods can continue to pass the
      buck by adding <c>throws IOException</c> to their own signatures or
      eventually some method could handle the exception using a construct we’ll
      describe below. But within the bounds of the AP curriculum, we should just
      add <c>throws IOException</c> to any method that needs it.
    </p>

    <program>
      import java.io.*;
      import java.util.*;

      public class FileIO {

         // The throws IOException indicates that we are not handling the
         // FileNotFoundException that could be thrown by the Scanner
         // constructor and will just let it crash our program.

         public static void main(String[] args) throws IOException {
            File myFile = new File("data.txt");
            Scanner scan = new Scanner(myFile);
            ...

            scan.close();
         }
      }
    </program>

    <activity label="throws-exception-exercise">
      <statement>
        <p>
          Try the following exercise to practice reading in a file. Notice the
          compiler error “unreported exception FileNotFoundException; must be caught
          or declared to be thrown”. Add <term>throws IOException</term> to the end
          of the main method header to fix the error.
        </p>

        <p>
          Run the code below to see the error message. Add <term>throws</term>
          and the correct exception to the end of the main method header to fix
          the error.
        </p>
      </statement>

      <program interactive="activecode" datafile="dictionary.txt">

        <code>
          import java.io.*;
          import java.util.*;

          public class FileIO {
              public static void main(String[] args) {
                  File myFile = new File("dictionary.txt");
                  Scanner scan = new Scanner(myFile);
                  System.out.println(
                          "The first word in the dictionary file is: " + scan.nextLine());
                  scan.close();
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("FileIO");
              }

              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "The first word in the dictionary file is: a";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }

              @Test
              public void fixedCode()
              {
                  boolean passed = checkCodeContains("throws IOException", "throws IOException");
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>

    <p>
      Another possibility, which is outside the AP curriculum, is to use a
      construct called a <c>try/catch</c> block to handle the exception somehow.
      The right thing to do depends on the context of the program. If the
      program can’t do anything at all without the file, then the best we can do
      is maybe print a useful error message and exit. But in some other program
      it might be possible to ask the user to provide a different file name or
      to use some default data if the file doesn’t exist.
    </p>

    <p>
      Here is an example of a <c>try/catch</c> block that catches the
      <c>FileNotFoundException</c> exception and prints an error message rather
      than letting the exception crash the program.
    </p>

    <p>
      The code that may cause an exception goes in the <c>try</c> block, marked
      by the curly braces after the word <c>try</c>. If the code in the
      <c>try</c> block throws an exception listed in the parentheses after
      <c>catch</c>, then the code in the block marked by the curly braces after
      the <c>catch</c> line will be executed to handle the exception. In this
      case it prints an error message. Then the code continues after the
      <c>catch</c> block
    </p>

    <program>
      try {
          Scanner scan = new Scanner(myFile);
      } catch (FileNotFoundException e) {
          System.out.println("File not found!");
      }
    </program>
  </subsection>

  <subsection>
    <title>Reading user input with <c>Scanner</c></title>

    <p>
      Another way to use <c>Scanner</c> that is handy but not part of the AP
      curriculum, is to read input that the user types. To do that instead of
      constructing a <c>Scanner</c> with a <c>File</c> object we pass it
      <c>System.in</c> which is the counterpart to <c>System.out</c> which we’ve
      been using to print message <em>to</em> the user; <c>System.in</c> is
      where we can read <em>from</em> the user. When we create a <c>Scanner</c>
      wrapped around <c>System.in</c> we can then use the <c>Scanner</c> methods
      to read data the user types.
    </p>

    <p>
      Here’s an example of the <c>nextInt</c> method being used to read from the
      keyboard.
    </p>

    <activity label="calculatorInput">
      <statement>
        <p>
          The code below will read in the two numbers below it and multiply
          them. Try changing the input below the code to decimal numbers like
          2.5 and run to see the <c>InputMismatchException</c>. Then, change the
          code to use <c>nextDouble()</c> instead of <c>nextInt()</c> and change
          the variables to type <c>double</c> to read in decimal numbers.
        </p>
      </statement>

      <program interactive="activecode">

        <code>
          import java.util.Scanner;

          public class Multiply {
               public static void main(String[] args) {
                    Scanner scan = new Scanner(System.in);
                    int num1 = scan.nextInt();
                    int num2 = scan.nextInt();

                    int result = num1 * num2;

                    System.out.println(num1 + " x " + num2 + " = " + result);
                    scan.close();
                }
           }
        </code>

        <stdin>
          2 3
        </stdin>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.Test;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
               @Test
               public void containsnextDouble()
               {
                   boolean passed = checkCodeContains("nextDouble()");
                   assertTrue(passed);
               }
               @Test
               public void containsdouble()
               {
                   boolean passed = checkCodeContains("double");
                   assertTrue(passed);
               }
          }
        </tests>

      </program>
    </activity>

    <p>
      Notice that the <c>nextInt()</c> and <c>nextDouble()</c> methods read in a
      number but leave any space or newline characters on the input stream. This
      can cause problems if you have input to read in multiple lines. Using
      <c>nextLine</c> and the other <c>Scanner</c> methods together on the same
      input source sometimes requires code to adjust for the methods’ different
      ways of handling whitespace. Java programmers will often add in an extra
      call to <c>scan.nextLine();</c> to read in the rest of the line after
      reading in a number.
    </p>
  </subsection>

  <subsection xml:id="loop-read-file">
    <title>Read all the lines in a file</title>

    <p>
      A <c>while</c> loop is usually used to read in a file with multiple lines
      since we don’t know when we open the file how many lines it will contain.
    </p>

    <p>
      The loop can use the method <c>hasNextLine</c> or <c>hasNext</c> as the
      loop condition to detect if the file still contains lines to read. A
      loop with this condition will terminate when there are no more lines to
      read in the file. After the loop is finished reading the data, the
      <c>close</c> method from Scanner should be called to close the file.
    </p>

    <program>
      while (scan.hasNextLine()) {
         String line = scan.nextLine();
         ...
      }
      scan.close();
    </program>

    <activity label="loop-read-file">
      <statement>
        <p>
          Complete the code below to count the number of lines in the dictionary
          file using a <c>while</c> loop. This code will also tell you how many
          lines are in the file.
        </p>
      </statement>

      <program interactive="activecode" datafile="dictionary.txt">

        <code>
          import java.io.*;
          import java.util.*;

          public class FileIOLoop {
              public static void main(String[] args) throws IOException {
                  File myFile = new File("dictionary.txt");
                  Scanner scan = new Scanner(myFile);
                  int count = 0;

                  // 1. Add in the loop condition that checks if scan has another line of input
                  while (         ) {
                      // 2. Read in the next line of the file

                      count++; // increment the line count
                   }

                  System.out.println("This file has " + count + " lines.");

                  scan.close();
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("FileIOLoop");
              }

              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "This file has 10002 lines.";
                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }
              @Test
              public void testNextLine()
              {
                  boolean passed = checkCodeContains("nextLine()");
                  assertTrue(passed);
              }

              @Test
              public void testHasNext()
              {
                  boolean passed = checkCodeContains("hasNext()") || checkCodeContains("hasNextLine()");
                  assertTrue(passed);
              }
          }
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="file-data-array">
    <title>Loading file data</title>

    <p>
      We can save a file line by line into a data structure such as an array or
      an <c>ArrayList</c>. In the <c>SpellChecker</c> class in <xref
      ref="topic-4-4-array-traversal" />, code was provided that read all the
      words into a array. But now that we know about <c>ArrayList</c>s, that’s a
      better data structure to use since we don’t need to know how many lines
      the file contains in order to build up an <c>ArrayList</c> they way we
      would with an array.
    </p>

    <p>
      The following exercise reads in a data file about Pokemon and prints out
      the first ten lines in the file. This file has the extension <em>csv</em>
      which stands for <term>Comma Separated Values</term>. All spreadsheets can
      be saved as CSV text files, and spreadsheet software can easily open CSV
      files as spreadsheets. You can take a look at the <url
      href="external/_static/datasets/pokemon.csv">pokemon.csv</url> file
      contents below:
    </p>

    <datafile label="pokemon" filename="pokemon.csv" editable="no" hide="no">
      <pre source="_static/datasets/pokemon.csv" />
    </datafile>

    <activity label="read-pokemon-file">
      <statement>
        <p>
          Complete the code in the main method below to read in the first ten
          lines of the pokemon file using the <c>Scanner</c> class, printing
          each line and save to the <c>pokemonLines</c> <c>ArrayList</c>.
        </p>
      </statement>

      <program interactive="activecode" datafile="pokemon.csv">
        <code>
          <![CDATA[
          import java.io.*;
          import java.util.*;

          public class ReadData
          {
              public static void main(String[] args) throws IOException
              {
                  File myFile = new File("pokemon.csv");
                  Scanner scan = new Scanner(myFile);
                  ArrayList<String> pokemonLines = new ArrayList<>();

                  int i = 0;
                  // 1. Add a loop condition will stop the loop if there are no more
                  // lines or when we've read ten lines, whichever comes first.
                  while (         )
                  {
                      // 2. Read in the next line of the file

                      // 3. Print the line

                      // 3. Add the line to pokemonLines


                      i++; // line count
                   }
                   scan.close();
             }
          }
          ]]>
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("ReadData");
              }

              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String[] lines = output.split("\\n");
                  boolean passed = lines.length >= 10;

                  passed =
                          getResults(
                                  "10+ lines of output",
                                  lines.length + " lines of output",
                                  "Expected output",
                                  passed);
                  assertTrue(passed);
              }

              @Test
              public void arrayCode()
              {
                  boolean passed = checkCodeContains("adding to  pokemonLines", "pokemonLines.add(");
                  assertTrue(passed);
              }
              @Test
              public void testHasNext()
              {
                  boolean passed = checkCodeContains("hasNext()") || checkCodeContains("hasNextLine()");
                  assertTrue(passed);
              }
              @Test
              public void testHasLess10()
              {
                  boolean passed = checkCodeContains("i < 10");
                  assertTrue(passed);
              }
          }
          ]]>
        </tests>

      </program>
    </activity>
  </subsection>

  <subsection xml:id="reading-in-files-with-java-nio-file">
    <title>Reading files with <c>java.nio.file</c></title>

    <p>
      Although not covered in the AP curriculum, the more modern way (by which
      we mean, it has only been around for fourteen years) to read all the lines
      from a file is using the classes <c>java.nio.file</c> package. The
      <c>nio</c> stands for “new input/output” and was added in Java version 7.
      The two important classes for our purposes in this package are
      <c>Files</c> (note the plural) and <c>Path</c>.
    </p>

    <p>
      <c>Path</c> serves basically the same purpose as <c>java.io.File</c>,
      giving us a way to refer to file on the computer’s hard drive. And
      <c>Files</c> contains a number of utility methods for interacting with files.
    </p>

    <p>
      The one we care about is <c>readAllLines</c> which takes a <c>Path</c> as
      its argument and returns a <c>List</c> of <c>String</c> values, one
      <c>String</c> per line. <c>List</c> is an <term>interface</term>, another
      feature of Java that’s not part of the AP curriculum but which are a key
      part of real Java programming. For now all you need to know is that a
      <c>List</c> is effectively the same as an <c>ArrayList</c>.
    </p>

    <p>
      Like the <c>Scanner</c> constructor, <c>readAllLines</c> method throws an
      <c>IOException</c> if the file cannot be read.
    </p>

    <p>
      The <c>Path</c> equivalent of <c>new File("filename.txt")</c> is
      <c>Path.of("filename.txt")</c> so after importing <c>java.nio.file.*</c>
      we can get all the lines in a file using one line:
    </p>

    <program>
      <![CDATA[
      List<String> lines = Files.readAllLines(Path.of("data.txt"));
      ]]>
    </program>

    <p>
      Under the covers <c>readAllLines</c> is almost certainly using an
      <c>ArrayList</c> which is a kind of <c>List</c>. The advantage of storing
      the lines in a dynamic data structure like an <c>ArrayList</c>, instead of
      an array, is that you do not need to know how many lines you are going to
      store when you create the <c>ArrayList</c> the way you do when you create
      an array. The <c>ArrayList</c> can then grow in size as needed. (If you
      absolutely need an array, you can convert the <c>List</c> to an array
      declared to be the correct size with the <c>toArray</c> method on
      <c>List</c>:
    </p>

    <program>
      <![CDATA[
      String[] array = list.toArray(new String[0]);
      ]]>
    </program>

    <p>
      The empty array passed as an argument to <c>toArray</c> tells Java what
      kind of array to make; it then allocates a new array of the approprite
      size to hold all the elements of the list.
    </p>

    <activity label="read-pokemon-file-nio">
      <statement>
        <p>
          Complete the code in the main method below to reads all lines of the
          file using <c>Files.readAllLines</c> into a <c>List&lt;String&gt;</c>
          named <c>lines</c>. Add a loop that prints out the first 10 pokemon.
        </p>
      </statement>

      <program interactive="activecode" datafile="pokemon.csv">

        <code>
          <![CDATA[
          import java.io.*;
          import java.nio.file.*;
          import java.util.*;

          public class ReadData
          {
              public static void main(String[] args) throws IOException
              {
                  List<String> lines = Files.readAllLines(Path.of("pokemon.csv"));
                  // Add a loop that prints out the first 10 elements of the List lines
                  // You can use the get method with Lists just like ArrayLists

              }
          }
          ]]>
        </code>

        <tests>
          <![CDATA[
          import static org.junit.Assert.*;
          import org.junit.*;
          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("ReadData");
              }

              @Test
              public void testMain() throws IOException
              {
                   String output = getMethodOutput("main");
                   String[] lines = output.split("\\s+");
                   boolean passed = lines.length >= 10;

                   passed = getResults("10+ lines of output", lines.length + " lines of output", "Expected output", passed);
                   assertTrue(passed);
              }
              @Test
              public void getMethodTest()
              {
                 boolean passed = checkCodeContains("call to get method with lines", "lines.get");
                 assertTrue(passed);
              }
           }
          ]]>
        </tests>

      </program>
    </activity>
  </subsection>

</section>
