<?xml version="1.0" encoding="utf-8"?>

<section xml:id="topic-2-2-booleans">
  <title>Where do booleans come from?</title>

  <idx>boolean</idx>
  <idx>boolean expression</idx>
  <idx>relational operator</idx>
  <idx>remainder operator</idx>
  <idx>boolean</idx>
  <idx>&lt;</idx>
  <idx>&gt;</idx>
  <idx>==</idx>
  <idx>!=</idx>
  <introduction>
    <p>
      In the previous section we discussed the different ways we could combine
      <c>if</c> statements to to make one-way, two-way, and multiway selection
      constructs. But in most of the examples we just assumed we had some
      <c>boolean</c> variable already set up to use in the conditions of our
      <c>if</c> statements.
    </p>

    <p>
      But most of the logic that goes into making interesting algorithms comes
      from how we actually compute the <c>boolean</c> values that we use in
      <c>if</c> statements.
    </p>

    <p>
      In this section we’ll look at the operators we can use to produce
      <c>boolean</c> values that don’t come from the literal <c>boolean</c>
      values we mentioned in the previous lesson. There are operators that
      produce <c>boolean</c> values from non-boolean values like <c>int</c> and
      <c>double</c> values and operators that we can use to combine
      <c>boolean</c> values to produce new <c>boolean</c> values.
    </p>
  </introduction>

  <subsection>
    <title>Comparison operators</title>

    <idx>hungry alligator</idx>
    <p>
      In <xref ref="arithmetic-expressions" /> we learned about arithmetic
      operators like <c>+</c> and <c>*</c> that operate on numeric values to
      produce other numeric values. Now we need to learn about <term>comparison
      operators</term> that operate on numbers but produce <c>boolean</c>
      values. Comparison operators can be further divided into four
      <term>relational operators</term> that test ordering relationships between
      numbers and two <term>equality operators</term> which simply check whether
      two numbers are the same or different.
    </p>

    <table>
      <title>Comparison operators</title>

      <tabular>
        <col halign="left" />
        <col halign="center" />
        <col halign="left" />
        <row header="yes">
          <cell bottom="minor" right="minor">Name</cell>
          <cell bottom="minor" right="minor">Written</cell>
          <cell bottom="minor">Value</cell>
        </row>

        <row>
          <cell bottom="minor" right="minor">Less than</cell>
          <cell bottom="minor" right="minor"><c>a &lt; b</c></cell>
          <cell bottom="minor">
            <c>true</c> if <c>a</c> is less than <c>b</c>, <c>false</c>
            otherwise
          </cell>
        </row>

        <row>
          <cell bottom="minor" right="minor">Greater than</cell>
          <cell bottom="minor" right="minor"><c>a &gt; b</c></cell>
          <cell bottom="minor">
            <c>true</c> if <c>a</c> is greater than <c>b</c>, <c>false</c>
            otherwise
          </cell>
        </row>

        <row>
          <cell bottom="minor" right="minor">Less than or equal</cell>
          <cell bottom="minor" right="minor"><c>a &lt;= b</c></cell>
          <cell bottom="minor">
            <c>true</c> if <c>a</c> is less than or equal to <c>b</c>,
            <c>false</c> otherwise
          </cell>
        </row>

        <row>
          <cell bottom="minor" right="minor">Greater than or equal</cell>
          <cell bottom="minor" right="minor"><c>a &gt;= b</c></cell>
          <cell bottom="minor">
            <c>true</c> if <c>a</c> is greater than or equal to <c>b</c>,
            <c>false</c> otherwise
          </cell>
        </row>

        <row>
          <cell bottom="minor" right="minor">Equals</cell>
          <cell bottom="minor" right="minor"><c>a &gt;= b</c></cell>
          <cell bottom="minor">
            <c>true</c> if <c>a</c> is the same value as <c>b</c>, <c>false</c>
            otherwise
          </cell>
        </row>

        <row>
          <cell right="minor">Not equals</cell>
          <cell right="minor"><c>a != b</c></cell>
          <cell>
            <c>true</c> if <c>a</c> and <c>b</c> are different values,
            <c>false</c> otherwise
          </cell>
        </row>
      </tabular>
    </table>

    <p>
      The four relational operators (<c>&lt;</c>, <c>&gt;</c>, <c>&lt;=</c>,
      <c>&gt;=</c>) should be familiar from math class. Note however that due to
      the limitations of character sets traditionally used in programming
      languages, we write <c>&lt;=</c> rather than ≤ and <c>&gt;=</c> instead of
      ≥. To remember the correct order of the two characters in <c>&lt;=</c> and
      <c>&gt;=</c>, just write them in the same order you would say them in
      English: “less than or equal to” not “equal to or less than”.
    </p>

    <p>
      If you need a refresher on these operators, one way to remember which is
      which is the <em>hungry alligator</em> mnemonic beloved by elementary
      school teachers—think of <c>&lt;</c> and <c>&gt;</c> as the mouths of
      hungry alligators who always want to eat the bigger number; a <c>&lt;</c>
      or <c>&gt;</c> expression is only <c>true</c> if the open mouth of the
      alligator is about to chomp the bigger number. (With <c>&lt;=</c> and
      <c>&gt;=</c> the alligator is also okay if the number it’s going to eat is
      the same as the other number.)
    </p>

    <note>
      <p>
        In some programming languages comparison operators like <c>&lt;</c> can
        be used to compare non-numeric values such as strings. But in Java they
        can only be used with numbers. As we’ll see in <xref
        ref="reference-types" /> there are other ways to compare <c>String</c>
        values for both ordering and equality.
      </p>
    </note>

    <activity label="bool2">
      <statement>
        <p>
          Try to guess what the code below will print out before you run it.
          Then, set year to 15 and print the boolean expression for whether age
          is less than or equal to year.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
          <![CDATA[

          public class BoolTest2 {
              public static void main(String[] args) {
                  int age = 15;
                  int year = 14;
                  // Will these print true or false?
                  System.out.println(age < year);
                  System.out.println(age > year);
                  // 1. Set year to 15
                  // 2. Print whether age is less than or equal to year
              }
          }

          ]]>
        </code>

        <tests>
          <![CDATA[

          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "false\ntrue\ntrue\n";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
               @Test
               public void test1()
               {
                   String code ="<=";
                   boolean passed = checkCodeContains(code);
                   assertTrue(passed);
               }
          }

          ]]>
        </tests>
      </program>
    </activity>

    <p>
      The two equality operators (<c>==</c> and <c>!=</c>) are relatively
      straightforward. A couple things to note however, one is that they are
      both written with two characters. In particular the equality operator
      <c>==</c> is different than the assignment operator <c>=</c>. So if
      <c>a</c> and <c>b</c> are <c>int</c> values, <c>a == b</c> is a
      <c>boolean</c> expression, i.e. it’s value will be either <c>true</c> or
      <c>false</c>. But <c>a = b</c> is an <c>int</c> expression whose value
      will be the original value of <c>b</c> and will also have the side effect
      of assigning that value to <c>a</c>.
    </p>

    <p>
      Unlike the relational operators, the equality operators can be used with
      any kinds of values, <c>int</c>, <c>double</c>, <c>boolean</c> as well as
      reference types like <c>String</c> and other types we’ll learn about
      later. But there are some subtleties to how they work with different kinds
      of values.
    </p>

    <p>
      For <c>int</c> and <c>boolean</c> values, <c>==</c> and <c>!=</c> are
      quite straightforward. Either two <c>int</c> values are the same or they
      are not. However, we will rarely use these operators with <c>boolean</c>
      values as doing so is usually unecessary and lead to a common mistake
      which we’ll discuss in <xref ref="if-traps" />.
    </p>

    <p>
      For <c>String</c> and other reference types we’ll discuss later, they
      “work” but maybe not in the way you’d expect. We’ll discuss that in detail
      in the section on <xref ref="equality" /> in the <xref
      ref="reference-types" /> unit.
    </p>

    <p>
      And finally, the equality operators should almost never be used with
      <c>double</c> values. They do work in the sense that if two <c>double</c>
      values are exactly the same, they will be <c>==</c>. The problem is that
      because computers perform <c>double</c> math with limited precision,
      sometimes expressions that seem like they should produce mathematically
      equivalent results don’t produce exactly the same <c>double</c> values so
      even though they should be equal according to math they won’t be according
      to <c>==</c>. One of the simplest examples is:
    </p>

    <program>
      0.1 + 0.2 == 0.3 // evaluates to false!
    </program>

    <p>
      You might wonder why these are different if <c>double</c> values can store
      up to 15 decimal places of precision! Understanding exactly why would
      involve getting into quite a lot of details about how <c>double</c> values
      are represented in memory that are well beyond the AP curriculum. But
      suffice it to say that this is a fact about how modern computers work, not
      a bug in Java. As a practical matter when doing <c>double</c> math,
      instead of comparing values for exact equality we should check whether the
      difference between two values is less than some meaningful threshold. For
      instance, if we were performing some computation on measurements in meters
      and wanted to check that the answer we got was “the same” as some expected
      value, we might use an expression like the following to check that they
      are the same to a tenth of a millimeter:
    </p>

    <program>
      <![CDATA[
      Math.abs(computedMeters - expectedMeters) < 0.0001
      ]]>
    </program>

    <activity label="BooleanExps">
      <statement>
        <p>
          Drag the boolean expression from the left and drop it on what it is
          testing on the right. Click the "Check Me" button to see if you are
          correct.
        </p>
      </statement>

      <feedback>
        <p>Review the relational operators above.</p>
      </feedback>

      <cardsort>
        <match>
          <premise order="1">x &gt; 0</premise>
          <response>x is positive</response>
        </match>

        <match>
          <premise order="2">x == y</premise>
          <response>x equals y</response>
        </match>

        <match>
          <premise order="3">x &lt; 0</premise>
          <response>x is negative</response>
        </match>

        <match>
          <premise order="4">x != y</premise>
          <response>x does not equal y</response>
        </match>

        <match>
          <premise order="5">x &lt; y</premise>
          <response>x is less than y</response>
        </match>

        <match>
          <premise order="6">x &gt; y</premise>
          <response>x is greater than y</response>
        </match>

        <match>
          <premise order="7">x &gt;= y</premise>
          <response>x is greater than or equal to y</response>
        </match>
      </cardsort>
    </activity>

    <activity label="bool1">
      <statement>
        <p>
          What will the code below print out? Try to guess before you run it!
          Note that 1 equal sign (<c>=</c>) is used for assigning a value and 2
          equal signs (<c>==</c>) for testing values. Then, add 3 more lines of
          code that sets year to 15 and prints out whether age is equal to year
          and whether age is not equal to year.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
          public class BoolTest1
          {
              public static void main(String[] args)
              {
                  int age = 15;
                  int year = 14;
                  // Will this print true or false?
                  System.out.println(age == year);
                  // Will this print true or false?
                  System.out.println(age != year);

                  // 1. Add code that sets year to 15
                  // 2. Print out whether age equals year
                  // 3. Print out whether age does not equal year

              }
          }
        </code>

        <tests>
          // should pass if/when they run code
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect = "false\ntrue\ntrue\nfalse\n";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection>
    <title>Testing divisibility</title>

    <p>
      A thing that comes up often enough in both real world coding and on the AP
      exam to be worth calling out is how to use the equality operators in
      combination with the remainder operator (<c>%</c>) to test whether
      <c>int</c> values are evenly divisible by other <c>int</c> values.
    </p>

    <p>
      If <c>a</c> is evenly divisible by <c>b</c>, that just means that the
      remainder if you divide <c>a</c> by <c>b</c> is zero. So to check if
      <c>a</c> is evenly divisible by <c>b</c> (or is a multiple of <c>b</c>,
      which is another way to say the same thing) we can just write <c>a % b ==
      0</c>.
    </p>

    <table>
      <title>Divisibility recipes</title>

      <tabular>
        <col halign="left" />
        <col halign="left" />
        <row header="yes">
          <cell bottom="minor" right="minor">Expression</cell>
          <cell bottom="minor">Tests</cell>
        </row>

        <row>
          <cell bottom="minor" right="minor"><c>number % 2 == 0</c></cell>
          <cell bottom="minor"><c>number</c> is even</cell>
        </row>

        <row>
          <cell bottom="minor" right="minor"><c>number % 2 != 0</c></cell>
          <cell bottom="minor"><c>number</c> is odd.</cell>
        </row>

        <row>
          <cell right="minor"><c>number % x == 0</c></cell>
          <cell>
            <c>number</c> is evenly divisible by <c>x</c>, a.k.a. <c>number</c>
            is a multiple of <c>x</c>
          </cell>
        </row>
      </tabular>
    </table>

    <note>
      <p>
        You might think you could check if a number was odd with the expression
        <c>number % 2 == 1</c> rather than <c>number % 2 != 0</c>. However,
        because Java’s <c>%</c> operator is a remainder operator and not a true
        mathematical modulo operator, this won’t always work: when <c>number</c>
        is a negative odd number, <c>number % 2</c> is <c>-1</c> not <c>1</c>.
        Thus you should always use <c>number % 2 != 0</c> to check if
        <c>number</c> is odd.
      </p>
    </note>

    <p>
      Problems requiring use of <c>%</c> come up frequently on the AP exam. Keep
      it in mind for the following uses:
    </p>

    <ul>
      <li>
        <p>
          Checking whether a number is odd or even. If <c>num % 2 != 0</c> then
          <c>num</c> is odd and if <c>num % 2 == 0</c> then <c>num</c> is even.
        </p>
      </li>

      <li>
        <p>
          Checking if a number is evenly divisible by any other number: If
          <c>num1 % num2 == 0</c> is true then <c>num1</c> is evenly divisible
          by <c>num2</c>.
        </p>
      </li>

      <li>
        <p>
          Getting the last digit (one’s place) from an <c>int</c>: <c>num %
          10</c> gives us the rightmost digit of <c>num</c>.
        </p>
      </li>

      <li>
        <p>
          Getting the number of minutes left when you convert a total number of
          minutes to hours and minutes:
        </p>

        <program>
          int totalMinutes = 345;
          int hours = totalMinutes / 60;   // Number of whole hours, i.e. 5
          int minutes = totalMinutes % 60; // Number of minutes left over, i.e. 45
        </program>
      </li>
    </ul>

    <activity label="boolRem">
      <statement>
        <p>
          Try the expressions containing the % operator below to see how they
          can be used to check for even or odd numbers. All even numbers are
          divisible (with no remainder) by 2. Then, add another expression that
          tests to see if age1 is divisible by 3.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class BoolRem
          {
              public static void main(String[] args)
              {
                  int age1 = 15;
                  int age2 = 16;

                  System.out.println("Remainder of " + age1 + "/2 is " + (age1 % 2));
                  System.out.println("Remainder of " + age2 + "/2 is " + (age2 % 2));
                  System.out.println("Is " + age1 + " even? " + (age1 % 2 == 0));
                  System.out.println("Is " + age2 + " even? " + (age2 % 2 == 0));

                  // Add a line that prints out whether age1 is divisible by 3

              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testMain() throws IOException
              {
                  String output = getMethodOutput("main");
                  String expect =
                          "Remainder of 15/2 is 1\n"
                              + "Remainder of 16/2 is 0\n"
                              + "Is 15 even? false \n"
                              + "Is 16 even? true\ntrue\n";
                  boolean passed = getResults(expect, output, "Expected output from main", true);
                  assertTrue(passed);
              }
              @Test
              public void testBool() throws IOException
              {
                  String target = "age1 % 3 == 0";
                  boolean passed = checkCodeContains("boolean check for divisibility by 3", target);
                  assertTrue(passed);
              }

          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="math-random-in-if-statements">
    <title>Random probabilities</title>

    <p>
      Another common way to want to produce <c>boolean</c> values is at random
      with some probability. This is quite easy since <c>Math.random()</c>,
      which we first saw in <xref ref="topic-1-11-Math" />, returns a random
      number between 0.0 and 1.0 which is exactly how probabilities are usually
      expressed. (Zero probability means something definitely won’t happen;
      probability one means it definitely will.)
    </p>

    <p>
      So we use <c>Math.random()</c> in combination with the <c>&lt;</c>
      operator to write an expression that will be <c>true</c> with a given
      probability. For example, to simulate a coin flip, we can use the
      expression <c>Math.random() &lt; 0.5</c> which will be true with
      probability 0.5 or 50% of the time.
    </p>

    <program language="java">
      <code>
        <![CDATA[

        if (Math.random() < 0.5) {
            System.out.println("Heads");
        } else {
            System.out.println("Tails");
        }

        ]]>
      </code>
    </program>

    <p>
      More generally, for any probability <c>p</c> between zero and one,
      <c>Math.random() &lt; p</c> will be true with that probability.
    </p>

    <program language="java">
      <code>
        <![CDATA[

        if (Math.random() < p) {
            System.out.println("Event happened");
        } else {
            System.out.println("Event did not happen");
        }

        ]]>
      </code>
    </program>

    <p>
      The easy way to remember that it should be <c>&lt;</c> and not <c>&gt;</c>
      or <c>&lt;=</c> is to remember that <c>Math.random()</c> returns a number
      greater than or equal to <c>0.0</c> and less than <c>1.0</c>. So
      <c>Math.random() &lt; 0.0</c> is never true <c>Math.random() &lt; 1.0</c>
      always is.
    </p>

    <activity label="qrand_1">
      <title>40% chance</title>

      <statement>
        <p>Which of the following would be true about 40% of the time?</p>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>Math.random() &lt; 0.4</p>
          </statement>

          <feedback>
            <p>
              This is true about 40% of the time since Math.random returns a
              value from 0 to not quite 1.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Math.random() &gt; 0.4</p>
          </statement>

          <feedback>
            <p>This will be true about 60% of the time.</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Math.random() == 0.4</p>
          </statement>

          <feedback>
            <p>
              Do not use == with double values! Remember that Math.random can
              return any number between 0 and not quite 1 (about .99999999).
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qrand_4">
      <title>75% chance</title>

      <statement>
        <p>Which of the following would be true about 75% of the time?</p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>Math.random() &lt; 0.25</p>
          </statement>

          <feedback>
            <p>
              This is true about 25% of the time, since it will be a number from
              0 to not quite 1.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>Math.random() &gt;= 0.25</p>
          </statement>

          <feedback>
            <p>
              This is true about 75% of the time, since it will be a number from
              0 to not quite 1. Note that if the expression used &gt; rather
              than &gt;= it would be very slightly off. Generally it's best to
              write this kind of expression with &lt; and the probability of a
              true value so <c>Math.random() &lt; 0.75</c> in this case.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>Math.random() == 0.25</p>
          </statement>

          <feedback>
            <p>
              Do not use == with double values! Remember that Math.random can
              return any number between 0 and not quite 1 (about .99999999).
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="mcq-rnd-ifs">
      <statement>
        <p>
          The weather report says there is approximately 25% chance of rain
          today. Which of the following if statements would print Rain or No
          Rain to simulate a day with the correct percentages following the
          weather report?
        </p>
      </statement>

      <choices>
        <choice correct="yes">
          <statement id="mcq-rnd-ifs_opt_a">
            <program language="java">
              <code>
                <![CDATA[
                if (Math.random() < 0.25) { System.out.println("Rain"); }
                ]]>
              </code>
            </program>
          </statement>

          <feedback id="mcq-rnd-ifs_opt_a">
            <p>Correct! This code will print “Rain” 25% of the time.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="mcq-rnd-ifs_opt_b">
            <program language="java">
              <code>
                <![CDATA[
                if (Math.random() > 0.75) { System.out.println("Rain"); }
                ]]>
              </code>
            </program>
          </statement>

          <feedback id="mcq-rnd-ifs_opt_b">
            <p>
              Correct. This code will print “Rain” 25% (1 - .75) of the time.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="mcq-rnd-ifs_opt_c">
            <program language="java">
              <code>
                <![CDATA[
                if (Math.random() > 0.25) { System.out.println("Rain"); }
                ]]>
              </code>
            </program>
          </statement>

          <feedback id="mcq-rnd-ifs_opt_c">
            <p>Incorrect. This code will print “Rain” 75% of the time.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="mcq-rnd-ifs_opt_d">
            <program language="java">
              <code>
                <![CDATA[
                if (Math.random() < 0.75) { System.out.println("No Rain"); }
                ]]>
              </code>
            </program>
          </statement>

          <feedback id="mcq-rnd-ifs_opt_d">
            <p>
              Correct! This code will print “No Rain” 75% of the time, so it
              will rain 25% of the time.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="randomShapes">
      <statement>
        <p>
          Add an if/else statement that uses Math.random() to do a coin flip to
          decide whether to call yertle.turnRight() or yertle.turnLeft. Run the
          code to see the turtle draw a random shape.
        </p>
      </statement>

      <program interactive="activecode" language="java" datafile="turtleClasses.jar,turtleClasses2.jar">
        <code>
          <![CDATA[

          import java.util.*;
          import java.awt.*;

          public class RandomTurns
          {
              public static void main(String[] args)
              {
                  World world = new World(500,400);
                  Turtle yertle = new Turtle(world);

                  // This is a loop that runs 10 times to draw a random shape
                  for(int i = 1; i <= 10; i++)
                  {
                      yertle.forward(20);

                      // Write an if/else statement that uses
                      // Math.random() to do a coin flip (50%) to choose
                      // between yertle.turnRight() or turnLeft()






                  } // end of loop
                  world.show(true);
              }
          }

          ]]>
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              public RunestoneTests()
              {
                  super("RandomTurns");
              }

             @Test
             public void testCodeContainsIf()
             {
                 boolean ifCheck = checkCodeContains("if", "if");
                 assertTrue(ifCheck);
             }
             @Test
             public void testCodeContainsElse()
             {
                 boolean ifCheck2 = checkCodeContains("else", "else");
                 assertTrue(ifCheck2);
             }
             @Test
             public void testCodeContainsRandom()
             {
                 boolean ifCheck2 = checkCodeContains("Math.Random()", "Math.random()");
                 assertTrue(ifCheck2);
             }
             @Test
             public void testCodeContains5()
             {
                 boolean ifCheck2 = checkCodeContains(".5", ".5");
                 assertTrue(ifCheck2);
             }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="and-or-and-not-index-0">
    <title>Logical operators</title>

    <p>
      The other set of operators in Java that produce <c>boolean</c> values are
      the <term>logical operators</term>. These operate on <c>boolean</c> values
      to produce new <c>boolean</c> values just like the arithmetic operators
      operate on numeric values and produce numeric values.
    </p>

    <p>
      The three logical operators in Java come from <term>Boolean
      algebra</term>, a system for evaluating logical statements invented by
      <url href="https://en.wikipedia.org/wiki/George_Boole"
      visual="https://en.wikipedia.org/wiki/George_Boole">George Boole</url>, a
      19th century English mathematician most famous for his book <em>The Laws
      of Thought</em>. These days we call these three operatarors <term>logical
      and</term>, <term>logical or</term> and <term>logical not</term>. And you
      are almost certainly already completely familiar with these operators and
      how they work even if you’ve never heard of George Boole.
    </p>

    <p>
      For example, if you were looking for someone to share some chocolate ice
      cream with, you’d know that you need to find someone who likes ice cream
      and who also likes chocolate. A friend who likes ice cream but doesn’t
      like chocolate wouldn’t be interested. And another friend who likes
      chocolate but hates ice cream would also not be interested. If you
      understand that, you understand the logic of the situation which is
      expressed with logical and.
    </p>

    <p>
      A logical and combines two statements like “likes ice cream” and “likes
      chocolate”, each of which is either true or false, into a new statement
      “likes ice cream and likes chocolate” that is only true if both of the
      sub-statements are true.
    </p>

    <p>
      In Java the logical and operator is written <c>&amp;&amp;</c>. Thus if we
      have two <c>boolean</c> expressions, such as two variables
      <c>likesIceCream</c> and <c>likesChocolate</c>, we can write an expression
      that combines them with <c>&amp;&amp;</c>:
    </p>

    <program>
      <![CDATA[
      likesIceCream && likesChocolate // true if, and only if, both variables are true
      ]]>
    </program>

    <p>
      You already understand logical or if you understand that if need to get
      something off a high shelf that you can’t reach, you either need a tall
      friend or a step stool. You don’t need <em>both</em> a tall friend and a
      step stool—one or the other is fine. (Though if you did have both that
      would also work.) In Java we write logical or as <c>||</c>:
    </p>

    <program>
      haveTallFriend || haveStepStool // true if either, or both, variables are true
    </program>

    <note>
      <sidebyside widths="65% 35%" valign="middle" margins="0% 0%">
        <p>
          One place that the way we use “and” and “or” in English that doesn’t
          completely match with their sense in Boolean logic is when we use “or”
          to express a choice between two options when we can only pick one: “do
          you want to be player 1 <em>or</em> player 2?” In Boolean logic and in
          Java the or operator is called an <term>inclusive or</term> which
          means that the whole expression is true if either one or the other or
          <em>both</em> conditions are true. Logically speaking there’s also an
          <term>exclusive or</term> which is true if either sub-statement is
          true but false if they both are. There isn’t a separate exclusive or
          operator in Java but <c>!=</c> applied to <c>boolean</c> values serves
          as one.
        </p>

        <table>
          <title>Truth table of <c>!=</c> with <c>boolean</c> values</title>

          <tabular halign="center" bottom="minor" right="minor" top="minor" left="minor">
            <row header="yes">
              <cell><c>a</c></cell>
              <cell><c>b</c></cell>
              <cell><c>a != b</c></cell>
            </row>

            <row>
              <cell><c>false</c></cell>
              <cell><c>false</c></cell>
              <cell><c>false</c></cell>
            </row>

            <row>
              <cell><c>false</c></cell>
              <cell><c>true</c></cell>
              <cell><c>true</c></cell>
            </row>

            <row>
              <cell><c>true</c></cell>
              <cell><c>false</c></cell>
              <cell><c>true</c></cell>
            </row>

            <row>
              <cell><c>true</c></cell>
              <cell><c>true</c></cell>
              <cell><c>false</c></cell>
            </row>
          </tabular>
        </table>
      </sidebyside>
    </note>

    <p>
      The final logical operator, logical not covers the logic of, “You can go
      out if you’re not grounded”. If the statement “you’re grounded” is true,
      then you can’t go out. But if the statement is false, then you can. In
      other words, logical not just flips the meaning of the statement, true to
      false and false to true. Logical not is written <c>!</c> in Java and goes
      before the expression it operates on:
    </p>

    <program>
      !grounded // true if grounded is false, false otherwise
    </program>

    <p>
      You can say that <c>!grounded</c> is the <term>logical negation</term> of
      <c>grounded</c>, similar to how <m>-4</m> is the negation of <m>4</m>.
    </p>

    <activity label="compoundAnd">
      <title>Can go out?</title>

      <statement>
        <p>
          What if you want to go out and your parents say you can go out if you
          clean your room and do your homework? Run the code below and try
          different values for <c>cleanedRoom</c> and <c>didHomework</c> and see
          what they have to be for it to print <c>You can go out</c>.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          <![CDATA[

          public class Test1 {
              public static void main(String[] args) {
                  boolean cleanedRoom = true;
                  boolean didHomework = false;
                  if (cleanedRoom && didHomework) {
                      System.out.println("You can go out");
                  } else {
                      System.out.println("No, you can't go out");
                  }
              }
          }

          ]]>
        </code>

        <tests>
          <![CDATA[

          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testChangedCode()
              {
                  String origCode =
                          "public class Test1 { public static void main(String[] args){ boolean cleanedRoom ="
                              + " true; boolean didHomework = false; if (cleanedRoom && didHomework){"
                              + " System.out.println(\"You can go out\");} else { System.out.println(\"No,"
                              + " you can't go out\");}}}";

                  boolean changed = codeChanged(origCode);
                  assertTrue(changed);
              }

              @Test
              public void testMain()
              {
                  String output = getMethodOutput("main");
                  String expect = "You can go out";

                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }
          }

          ]]>
        </tests>
      </program>
    </activity>

    <activity label="compoundOr">
      <statement>
        <p>
          Suppose you want to go somewhere. You can go if you can walk there or
          if your parents aren’t using the car. Try different values for
          <c>walking</c> and <c>carIsAvailable</c> and see what the values have
          to be to print <c>You can go out</c>.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class Test2 {
              public static void main(String[] args) {
                  boolean walking = false;
                  boolean carIsAvailable = false;
                  if (walking || carIsAvailable) {
                      System.out.println("You can go out");
                  } else {
                      System.out.println("No, you can't go out");
                  }
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testChangedCode()
              {
                  String origCode =
                          "public class Test2 { public static void main(String[] args){ boolean walking ="
                              + " false; boolean carIsAvailable = false; if (walking || carIsAvailable) {"
                              + " System.out.println(\"You can go out\"); } else{System.out.println(\"No, you"
                              + " can't go out\"); }}}";

                  boolean changed = codeChanged(origCode);
                  assertTrue(changed);
              }

              @Test
              public void testMain()
              {
                  String output = getMethodOutput("main");
                  String expect = "You can go out";

                  boolean passed = getResults(expect, output, "Expected output from main");
                  assertTrue(passed);
              }
          }
        </tests>
      </program>
    </activity>

    <activity label="not-operator">
      <statement>
        <p>
          The code below says if homework is not done, you can’t go out. Try
          different values for <c>homeworkDone</c>.
        </p>
      </statement>

      <program interactive="activecode">
        <code>
          public class TestNot {
              public static void main(String[] args) {
                  boolean homeworkDone = false;
                  if (!homeworkDone) {
                      System.out.println("Sorry, you can't go out!");
                  }
              }
          }
        </code>

        <tests>
          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testChangedCode()
              {
                  String origCode =
                          "public class TestNot{public static void main(String[] args){ boolean homeworkDone"
                              + " = false; if (!homeworkDone) { System.out.println(\"Sorry, you can't go"
                              + " out!\"); } } }";

                  boolean changed = codeChanged(origCode);
                  assertTrue(changed);
              }
          }
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection>
    <title>Testing ranges</title>

    <p>
      Just like we can use the <c>==</c> and <c>%</c> operators together to test
      whether numbers are divisible by other numbers, we can combine relational
      and logical operators to test whether a number is in a certain range.
    </p>

    <p>
      In math we can write <m>0 \le x \lt 100</m> to express that <m>x</m> is in
      the range from zero (inclusive) to one hundred (exclusive). Unfortunately
      if we translate that directly to Java as <c>0 &lt;= x &lt; 100</c> we will
      get a compiler error. This is because <c>0 &lt;= x</c> produces a
      <c>boolean</c> which can’t then be an operand to the <c>&lt;</c> operator.
      Instead we need to use <c>&amp;&amp;</c> to combine two <c>boolean</c>
      expressions:
    </p>

    <program>
      <![CDATA[
      0 <= x && x < 100 // True if x is in range from 0 to 100, exclusive.
      ]]>
    </program>

    <p>
      Less frequently we may want to write an expression that is true if a
      variable is not in a particular range. That’s as easy as applying a
      <c>!</c> to the whole range expression. We need to put the range
      expression in parentheses because <c>!</c> has very high precedence.
    </p>

    <program>
      <![CDATA[
      !(0 <= x && x < 100) // True if x is outside the range from 0 to 100, exclusive.
      ]]>
    </program>

    <p>We could also write that in this logically equivalent way:</p>

    <program>
      <![CDATA[
      x < 0 || x >= 100
      ]]>
    </program>

    <activity label="compound-number-range">
      <statement>
        <p>
          Explore how &amp;&amp; and || are used with numbers below. Try
          different values for score like -10 and 110 in the code below.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
          <![CDATA[

          public class TestNum {
              public static void main(String[] args) {
                  int score = 10; // Try -10 and 110
                  if (score < 0 || score > 100) {
                      System.out.println("Score has an illegal value.");
                  }
                  if (0 <= score && score <= 100) {
                      System.out.println("Score is in the range 0-100");
                  }
              }
          }

          ]]>
        </code>

        <tests>
          <![CDATA[

          import static org.junit.Assert.*;

          import org.junit.*;

          import java.io.*;

          public class RunestoneTests extends CodeTestHelper
          {
              @Test
              public void testChangedCode()
              {
                  String origCode =
                          "public class TestNum{public static void main(String[] args){int score = 10;  if"
                              + " (score < 0 || score > 100){ System.out.println(\"Score has an illegal"
                              + " value.\");}if (score >= 0 && score <= 100){ System.out.println(\"Score is"
                              + " in the range 0-100\");}}}";

                  boolean changed = codeChanged(origCode);
                  assertTrue(changed);
              }
          }

          ]]>
        </tests>
      </program>
    </activity>
  </subsection>

  <subsection xml:id="short-circuit-evaluation">
    <title>Short Circuit Evaluation</title>

    <idx>short circuit evaluation</idx>
    <idx><h>conditional</h><h>short circuit evaluation</h></idx>
    <p>
      Both <c>&amp;&amp;</c> and <c>||</c> use <term>short circuit
      evaluation</term>. That means that the second expression (on the right of
      the operator) isn’t necessarily checked, if the result from the first
      expression is enough to tell if the compound boolean expression is true or
      false:
    </p>

    <p>
      <ul>
        <li>
          <p>
            If two boolean values/expressions are combined with a logical
            <term>or</term> (<c>||</c>) and the first expression is <c>true</c>,
            then the second expression won’t be executed, since only one needs
            to be <c>true</c> for the result to be <c>true</c>.
          </p>
        </li>

        <li>
          <p>
            If two boolean values/expressions are combined with a logical
            <term>and</term> (<c>&amp;&amp;</c>) and the first expression is
            <c>false</c>, then the second expression won’t be executed. If the
            first expression is <c>false</c>, the result will be <c>false</c>,
            since both sides of the <c>&amp;&amp;</c> need to be <c>true</c> for
            the result to be <c>true</c>.
          </p>
        </li>
      </ul>
    </p>

    <activity label="shortCircuit1">
      <statement>
        <p>
          What is printed when the following code executes and x has been set to
          0 and y to 3?
        </p>

        <program language="java">
          <code>
            <![CDATA[

            if (x > 0 && (y / x) == 3)
            {
               System.out.println("first case");
            }
            else
            {
               System.out.println("second case");
            }

            ]]>
          </code>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>first case</p>
          </statement>

          <feedback>
            <p>
              first case will only print if x is greater than 0 and it is not.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>second case</p>
          </statement>

          <feedback>
            <p>
              second case will print if x is less than or equal to zero or if y
              divided by x is not equal to 3.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>You will get a error because you can't divide by zero.</p>
          </statement>

          <feedback>
            <p>
              Since the first condition is false when x is equal to zero the
              second condition won't execute. Execution moves to the else.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="shortCircuit2">
      <statement>
        <p>
          What is printed when the following code executes and x has been set to
          zero and y is set to 3?
        </p>

        <program language="java">
          <code>
            if (x == 0 || (y / x) == 3)
            {
               System.out.println("first case");
            }
            else
            {
               System.out.println("second case");
            }
          </code>
        </program>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>first case</p>
          </statement>

          <feedback>
            <p>
              Since x is equal to zero the first expression in the complex
              conditional will be true and the (y / x) == 3 won't be evaluated,
              so it won't cause a divide by zero error. It will print "first
              case".
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>second case</p>
          </statement>

          <feedback>
            <p>
              Since x is equal to zero the first part of the complex conditional
              is true so it will print first case.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>You will get a error because you can't divide by zero.</p>
          </statement>

          <feedback>
            <p>
              You won't get an error because of short circuit evaluation. The (y
              / x) == 3 won't be evaluated since the first expression is true
              and an or is used.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="summary-19">
    <title>Summary</title>

    <p>
      <ul>
        <li>
          <p>
            (AP 2.2.A.1) Values or expressions can be compared using the
            relational operators <c>==</c> and <c>!=</c> to determine whether
            the values are the same. With primitive types, this compares the
            actual primitive values. With reference types, this compares the
            object references.
          </p>
        </li>

        <li>
          <p>
            (AP 2.2.A.2) Numeric values or expressions can be compared using the
            relational operators (<c>&lt;</c>, <c>&gt;</c>, <c>&lt;=</c>,
            <c>&gt;=</c>) to determine the relationship between the values.
          </p>
        </li>

        <li>
          <p>
            (AP 2.2.A.3) An expression involving relational operators evaluates
            to a <c>Boolean</c> value of <c>true</c> or <c>false</c>.
          </p>
        </li>

        <li>
          <p>
            The remainder operator <c>%</c> can be used to test for divisibility
            by a number. For example, <c>num % 2 == 0</c> can be used to test if
            a number is even.
          </p>
        </li>

        <li>
          <p>
            (AP 2.5.A.1) Logical operators <c>!</c> (not), <c>&amp;&amp;</c>
            (and), and <c>||</c> (or) are used with Boolean values.
          </p>

          <p>
            <ul>
              <li>
                <p>
                  <c>A &amp;&amp; B</c> is <c>true</c> if both <c>A</c> and
                  <c>B</c> are <c>true</c>.
                </p>
              </li>

              <li>
                <p>
                  <c>A || B</c> is <c>true</c> if either <c>A</c> or <c>B</c>
                  (or both) are <c>true</c>.
                </p>
              </li>

              <li>
                <p><c>!A</c> is <c>true</c> if <c>A</c> is <c>false</c>.</p>
              </li>
            </ul>
          </p>
        </li>

        <li>
          <p>
            (AP 2.5.A.1) <c>!</c> has precedence (is executed before)
            <c>&amp;&amp;</c> which has precedence over <c>||</c>. (Parentheses
            can be used to force the order of execution in a different way.)
          </p>
        </li>

        <li>
          <p>
            (AP 2.5.A.1) An expression involving logical operators evaluates to
            a Boolean value.
          </p>
        </li>

        <li>
          <p>
            (AP 2.5.A.2) <term>Short-circuit evaluation</term> occurs when the
            result of a logical operation using <c>&amp;&amp;</c> or <c>||</c>
            can be determined by evaluating only the first Boolean expression.
            In this case, the second Boolean expression is not evaluated. (If
            the first expression is <c>true</c> in an <c>||</c> operation, the
            second expression is not evaluated since the result is true. If the
            first expression is <c>false</c> in an <c>&amp;&amp;</c> operation,
            the second expression is not evaluated since the result is false.)
          </p>
        </li>
      </ul>
    </p>
  </subsection>

  <subsection xml:id="ap-practice-12">
    <title>AP Practice</title>

    <activity label="AP2-2-1">
      <statement>
        <p>Consider the following statement.</p>

        <program language="java">
          <code>
            <![CDATA[
            boolean x = (5 % 3 == 0) == (3 > 5);
            ]]>
          </code>
        </program>

        <p>What is the value of x after the statement has been executed?</p>
      </statement>

      <choices>
        <choice>
          <statement id="AP2-2-1_opt_a">
            <p>false</p>
          </statement>

          <feedback id="AP2-2-1_opt_a">
            <p>
              Although both sides of the middle == are false, false == false is
              true! Tricky!
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP2-2-1_opt_b">
            <p>true</p>
          </statement>

          <feedback id="AP2-2-1_opt_b">
            <p>
              (5 % 3 == 0) is false and (3 &gt; 5) is false, and false == false
              is true! Tricky!
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP2-2-1_opt_c">
            <p>(5 % 3 == 0)</p>
          </statement>

          <feedback id="AP2-2-1_opt_c">
            <p>The boolean x should hold true or false.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP2-2-1_opt_d">
            <p>(3 &gt; 5)</p>
          </statement>

          <feedback id="AP2-2-1_opt_d">
            <p>The boolean x should hold true or false.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP2-2-1_opt_e">
            <p>2</p>
          </statement>

          <feedback id="AP2-2-1_opt_e">
            <p>The boolean x should hold true or false.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="AP2-2-2">
      <statement>
        <p>
          Consider the following Boolean expression in which the int variables x
          and y have been properly declared and initialized.
        </p>

        <program language="java">
          <code>
            <![CDATA[
            (x >= 10) == (y < 12)
            ]]>
          </code>
        </program>

        <p>
          Which of the following values for x and y will result in the
          expression evaluating to true ?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP2-2-2_opt_a">
            <p>x = 10 and y = 12</p>
          </statement>

          <feedback id="AP2-2-2_opt_a">
            <p>
              The left side is true, but y must be less than 12 to make the
              right side true.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP2-2-2_opt_b">
            <p>x = 9 and y = 9</p>
          </statement>

          <feedback id="AP2-2-2_opt_b">
            <p>
              The left side is false (x must be greater than or equal to 10),
              but the right side is true.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP2-2-2_opt_c">
            <p>x = 10 and y = 11</p>
          </statement>

          <feedback id="AP2-2-2_opt_c">
            <p>Correct! Both sides are true!</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP2-2-2_opt_d">
            <p>x = 10 and y = 13</p>
          </statement>

          <feedback id="AP2-2-2_opt_d">
            <p>
              The left side is true, but y must be less than 12 to make the
              right side true.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP2-2-2_opt_e">
            <p>x = 9 and y = 12</p>
          </statement>

          <feedback id="AP2-2-2_opt_e">
            <p>Correct! Both sides are false! This is tricky!</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="AP-compound-bools">
      <statement>
        <p>
          Consider the following code segment. What is printed as a result of
          executing the code segment?
        </p>

        <program language="java">
          <code>
            <![CDATA[

            int x = 10;
            int y = 5;

            if (x % 2 == 0 && y % 2 == 0 || x > y)
            {
                System.out.print("First ");

                if (y * 2 == x || y > 5 && x <= 10)
                {
                   System.out.print("Second ");
                }
                else
                {
                   System.out.print("Third ");
                }
            }

            ]]>
          </code>
        </program>
      </statement>

      <choices>
        <choice>
          <statement id="AP-compound-bools_opt_a">
            <p>Nothing is printed out.</p>
          </statement>

          <feedback id="AP-compound-bools_opt_a">
            <p>Some of these conditions are true.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-compound-bools_opt_b">
            <p>First</p>
          </statement>

          <feedback id="AP-compound-bools_opt_b">
            <p>This is partially correct.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-compound-bools_opt_c">
            <p>Third</p>
          </statement>

          <feedback id="AP-compound-bools_opt_c">
            <p>
              Third cannot be printed out unless First is printed out first.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP-compound-bools_opt_d">
            <p>First Second</p>
          </statement>

          <feedback id="AP-compound-bools_opt_d">
            <p>Good tracing!</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-compound-bools_opt_e">
            <p>First Third</p>
          </statement>

          <feedback id="AP-compound-bools_opt_e">
            <p>Take another look at the second condition.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>
</section>
