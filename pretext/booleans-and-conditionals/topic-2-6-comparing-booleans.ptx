<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="topic-2-6-comparing-booleans">
  <title>Manipulating boolean expressions</title>
  <idx>De Morgan's Laws</idx>
  <idx>negation</idx>
  <idx>truth table</idx>
  <introduction>
    <p>
      Boolean expressions are at the heart of a lot of code controlling what
      happens when. And sometimes they can get a bit complex. In order to keep
      from getting overwhelmed, it’s useful to be able to manipulate and
      simplify boolean expressions.
    </p>

    <p>
      Also the AP exam almost always includes some questions that depend on your
      ability to determine whether two boolean expressions are actually
      equivalent, similar to being able to determine that two mathematical
      expressions such as <m>a(b + c)</m> and <m>ab + ac</m> are equivalent.
    </p>

    <p>
      In this section we will look at two ways of manipulating and analyzing
      boolean expressions: <term>algebraically</term> and with <term>truth
      tables</term>.
    </p>
  </introduction>

  <subsection>
    <title>Compound boolean expressions</title>
    <p>
      As with the arithmetic operators, the two logical operators
      <c>&amp;&amp;</c> and <c>||</c> each apply to only two operands and
      <c>!</c> only applies to one. But we can build compound expressions where
      the operands are other expressions using either other logical operators or
      comparison operators. We some some examples of this in the previous
      section.
    </p>

    <p>
      Once we start writing compound expressions it’s important to know what the
      precedence of the different operators are and our middle-school PEMDAS is
      no help. In Java, <c>!</c> has higher precedence than <c>&amp;&amp;</c>,
      and <c>&amp;&amp;</c> is higher than <c>||</c>. But parentheses are still
      the highest precedence so we can use them to group things the way we want
      them to be evaluated. For example <c>!a &amp;&amp; b</c> is equivalent to
      <c>(!a) &amp;&amp; b</c>. If instead we want to negate the value produced
      by the and expression we can write: <c>!(a &amp;&amp; b)</c>.
    </p>

    <p>
      Also all the logical operators are lower precedence than the comparison
      operators which is why we can write <c>0 &lt;= x &amp;&amp; x &lt; 100</c>
      rather than having to write: <c>(0 &lt;= x) &amp;&amp; (x &lt; 100)</c>.
    </p>
  </subsection>

  <subsection xml:id="simplifying-boolean-expressions">
    <title>Simplifying algebraically</title>
    <p>
      Once we start writing complex compund boolean expressions things can get
      out of hand. Sometimes this happens organically as we write code because
      we add subexpressions to an expression as we realize different cases. “I
      want to run this code when the score is greater than one-hundred. No wait,
      greater than one-hundred and bonus points are greater than ten. Well, that
      but also when the player has at least one power up and more than ten bonus
      points.” Next thing you know we’ve got this (with parentheses added for
      clarity):
    </p>

    <program>
      (score &gt; 100 &amp;&amp; bonusPoints &gt; 10) || (powerUps &gt; 1 &amp;&amp; bonusPoints &gt; 10)
    </program>

    <p>
      That’s maybe not terrible but it’s not trivial either. When we look at
      that expression how sure are we that it’s capturing exactly the cases we
      care about? Luckily there are some techniques for simplifying an
      expression like that into something that might be easier to understand.
    </p>

    <p>
      For instance, in this case we can notice that in both sides of the
      <c>||</c> the condition is something <c>&amp;&amp; bonusPoints &gt;
      10</c>. Since the whole compound expression can only be true if one side
      or the other is true but whichever side it is, <c>bonusPoints &gt; 10</c>
      will have to be true. So that means we can factor it out similar to how we
      can factor <m>a</m> out of <m>ab + ac</m> to get <m>a(b + c)</m>. That
      gives us this:
    </p>

    <program>
      bonusPoints &gt; 10 &amp;&amp; (score &gt; 100 || powerUps &gt; 1)
    </program>

    <p>
      This trick also works when we have two <c>||</c> expressions combined with
      <c>&amp;&amp;</c>. Consider for instance this expression:
    </p>

    <program>
      (score &gt; 100 || bonusPoints &gt; 10) &amp;&amp; (score &lt; 100 || bonusPoints &gt; 10)
    </program>

    <p>
      This time in order for the whole expression to be true both of the
      operands to the &amp;&amp;, i.e. the two <c>||</c> expressions have to be
      true. Since they both contain <c>bonusPoints &gt; 10</c>, if that
      subexpression is true they will each be true and therefore the whole thing
      will be true. So we can factor it out like this:
    </p>

    <program>
      bonusPoints &gt; 10 || (score &gt; 100 &amp;&amp; score &lt; 100)
    </program>

    <p>
      But now there’s an even bigger payoff. Look carefully at the second
      expression. It’s true when the score is both greater and less than one
      hundred. Which can never happen so that subexpression will always be
      <c>false</c>. So we can simplify the larger expression to:
    </p>

    <program>
      bonusPoints &gt; 10 || false
    </program>

    <p>
      And since the value of that now depends entirely on the left hand operand
      of the <c>||</c> we’ve simplified the whole original expression down to
      just:
    </p>

    <program>
      bonusPoints &gt; 10
    </program>
  </subsection>

  <subsection xml:id="de-morgan-s-laws">
    <title>De Morgan’s Laws</title>
    <p>
      De Morgan’s Laws were developed by Augustus De Morgan in the 1800s. They
      show how to simplify the negation of a complex boolean expression, which
      is when there are multiple expressions joined by an <term>and</term>
      (<c>&amp;&amp;</c>) or <term>or</term> (<c>||</c>), such as <c>(x &lt; 3)
      &amp;&amp; (y &gt; 2)</c>. When you negate one of these complex
      expressions, you can simplify it by flipping the operators and end up with
      an equivalent expression. De Morgan’s Laws state the following
      equivalencies. Here’s an easy way to remember De Morgan’s Laws: <term>move
      the NOT inside, AND becomes OR</term> and <term>move the NOT inside, OR
      becomes AND</term>.
    </p>

    <figure align="center">
      <caption>De Morgan’s Laws to simplify complex expressions</caption>
      <image source="Unit2-Selection-and-Iteration/Figures/demorgan.png" width="71%" />
    </figure>

    <p>
      In Java, De Morgan’s Laws are written with the following operators:
    </p>

    <blockquote>
      <p>
        <ul>
          <li>
            <p>
              <c>!(a &amp;&amp; b)</c> is equivalent to <c>!a || !b</c>
            </p>
          </li>

          <li>
            <p>
              <c>!(a || b)</c> is equivalent to <c>!a &amp;&amp; !b</c>
            </p>
          </li>
        </ul>
      </p>
    </blockquote>

    <p>
      Going back to our example above, !(a senior &amp;&amp; at our high school)
      is equivalent to !(a senior) or !(at our high school) using De Morgan’s
      Laws:
    </p>

    <program language="java">
      <code>
!(a &amp;&amp; b) is equivalent to !a || !b

a = "senior"
b = "at our high school"
      </code>
    </program>

    <p>
      You can also simplify negated boolean expressions that have relational
      operators like <c>&lt;</c>, <c>&gt;</c>, <c>==</c>. You can move the
      negation inside the parentheses by flipping the relational operator to its
      opposite sign. For example, not (c equals d) is the same as saying c does
      not equal d. An easy way to remember this is <term>To move the NOT, flip
      the sign</term>. Notice that <c>==</c> becomes <c>!=</c>, but <c>&lt;</c>
      becomes <c>&gt;=</c>, <c>&gt;</c> becomes <c>&lt;=</c>, <c>&lt;=</c>
      becomes <c>&gt;</c>, and <c>&gt;=</c> becomes <c>&lt;</c> where the sign
      is flipped and an equal sign may also be added or removed.
    </p>

    <blockquote>
      <p>
        <ul>
          <li>
            <p>
              <c>!(c == d)</c> is equivalent to <c>c != d</c>
            </p>
          </li>

          <li>
            <p>
              <c>!(c != d)</c> is equivalent to <c>c == d</c>
            </p>
          </li>

          <li>
            <p>
              <c>!(c &lt; d)</c> is equivalent to <c>c &gt;= d</c>
            </p>
          </li>

          <li>
            <p>
              <c>!(c &gt; d)</c> is equivalent to <c>c &lt;= d</c>
            </p>
          </li>

          <li>
            <p>
              <c>!(c &lt;= d)</c> is equivalent to <c>c &gt; d</c>
            </p>
          </li>

          <li>
            <p>
              <c>!(c &gt;= d)</c> is equivalent to <c>c &lt; d</c>
            </p>
          </li>
        </ul>
      </p>
    </blockquote>

    <p>
      Often, you can simplify boolean expressions to create equivalent
      expressions. For example, applying De Morgan’s Laws to <c>!(x &lt; 3
      &amp;&amp; y &gt; 2)</c> yields <c>!(x &lt; 3) || !(y &gt; 2)</c> as seen
      in the figure below. This can then be simplified further by flipping the
      relational operators to remove the not. So, <c>!(x &lt; 3) || !(y &gt;
      2)</c> is simplified to <c>(x &gt;= 3 || y &lt;= 2)</c> where the
      relational operators are flipped and the negation is removed. These two
      simplification steps are seen below.
    </p>

    <figure align="center">
      <caption>An example boolean expression simplified</caption>
      <image source="Unit2-Selection-and-Iteration/Figures/demorganex.png" width="71%" />
    </figure>

    <activity label="lcdmtest">
      <statement>
        <p>
          For what values of x and y will the code below print true? Try out
          different values of x and y to check your answer.
        </p>
      </statement>

      <program interactive="activecode" language="java">
        <code>
public class Test1
{
    public static void main(String[] args)
    {
        int x = 2;
        int y = 3;
        System.out.println(!(x &lt; 3 &amp;&amp; y &gt; 2));
    }
}
        </code>
        <tests>
import static org.junit.Assert.*;

import org.junit.*;

import java.io.*;

public class RunestoneTests extends CodeTestHelper
{
    @Test
    public void testChangedCode()
    {
        String origCode =
                "public class Test1 {public static void main(String[] args) { int x = 2; int y = 3;"
                    + " System.out.println(!(x &lt; 3 &amp;&amp; y &gt; 2)); } }";

        boolean changed = codeChanged(origCode);
        assertTrue(changed);
    }
}
        </tests>
      </program>
    </activity>

    <activity label="compareBool1">
      <statement>
        <p>
          What is printed when the following code executes and x equals 4 and y
          equals 3?
        </p>

        <program language="java">
          <code>
int x = 4, y = 3;
if (!(x &lt; 3 || y &gt; 2))
{
   System.out.println("first case");
}
else
{
   System.out.println("second case");
}
          </code>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>first case</p>
          </statement>

          <feedback>
            <p>
              This will be printed if x is greater or equal to 3 and y is less
              than or equal to 2. The first part is true but the second is
              false. Since the statements are joined by an and the complex
              expression is false.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>second case</p>
          </statement>

          <feedback>
            <p>
              This will be printed if x is less than 3 or y is greater than 2.
              In this case the first will be false, but the second true so since
              the statements are joined with an or the complex expression is
              true.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="compareBool2">
      <statement>
        <p>
          What is printed when the following code executes and x equals 4 and y
          equals 3?
        </p>

        <program language="java">
          <code>
int x = 4, y = 3;
if (!(x &lt; 3 &amp;&amp; y &gt; 2))
{
   System.out.println("first case");
}
else
{
   System.out.println("second case");
}
          </code>
        </program>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>first case</p>
          </statement>

          <feedback>
            <p>
              This will be printed if x is greater than or equal to 3 or y is
              less than or equal to 2. In this case x is greater than 3 so the
              first condition is true.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>second case</p>
          </statement>

          <feedback>
            <p>
              This will be printed if x is less than 3 and y is greater than 2.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="truth-tables">
    <title>Truth Tables</title>
    <p>
      The following table (also called a <term>truth table</term>) shows the
      result for <c>P &amp;&amp; Q</c> when <c>P</c> and <c>Q</c> are both
      expressions that can be <c>true</c> or <c>false</c>. An expression
      involving logical operators like <c>P &amp;&amp; Q</c> evaluates to a
      <c>boolean</c> value, <c>true</c> or <c>false</c>. As you can see below
      the result of <c>P &amp;&amp; Q</c> is only <c>true</c> if both <c>P</c>
      and <c>Q</c> are <c>true</c>. XXX
    </p>

    <table>
      <title><c>P &amp;&amp; Q</c> truth table</title>

      <tabular halign="center" bottom="minor" right="minor" top="minor" left="minor" row-headers="no">
        <row header="yes">
          <cell>P</cell>
          <cell>Q</cell>
          <cell>P &amp;&amp; Q</cell>
        </row>

        <row>
          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>false</c>
          </cell>
        </row>

        <row>
          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>false</c>
          </cell>
        </row>

        <row>
          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>?</c>
          </cell>
        </row>

        <row>
          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>
        </row>
      </tabular>
    </table>

    <activity label="truthTableFill">
      <statement>
        <p>
          The truth table above is missing one result. What is the result of
          <c>P &amp;&amp; Q</c> when <c>P=true</c> and <c>Q=false</c>?
        </p>

        <p>
          <fillin mode="string" answer="false" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>
              <p>Correct. Both values must be true for &amp;&amp; to return true.</p>
            </feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>Both values must be true for &amp;&amp; to return true.</feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <p>
      The following table shows the result for <c>P || Q</c> when <c>P</c> and
      <c>Q</c> are both expressions that can be <c>true</c> or <c>false</c>. As
      you can see below the result of <c>P || Q</c> is <c>true</c> if either
      <c>P</c> or <c>Q</c> is <c>true</c>. It is also <c>true</c> when both of
      them are <c>true</c>.
    </p>

    <table>
      <title><c>P || Q</c> truth table</title>

      <tabular halign="center" bottom="minor" right="minor" top="minor" left="minor" row-headers="no">
        <row header="yes">
          <cell>P</cell>
          <cell>Q</cell>
          <cell>P || Q</cell>
        </row>

        <row>
          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>false</c>
          </cell>
        </row>

        <row>
          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>
        </row>

        <row>
          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>
        </row>

        <row>
          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>
        </row>
      </tabular>
    </table>

    <activity label="truthTableFill2">
      <statement>
        <p>
          The truth table above is missing one result. What is the result of
          <c>P || Q</c> when <c>P=false</c> and <c>Q=true</c>?
        </p>

        <p>
          <fillin mode="string" answer="true" />
        </p>
      </statement>

      <evaluation>
        <evaluate>
          <test>
            <strcmp use-answer="yes" />
            <feedback>
              <p>
                Correct. Only one of the two has to be true with || so this will
                print true.
              </p>
            </feedback>
          </test>

          <test>
            <!-- else -->
            <feedback>If at least 1 value is true, || will return true.</feedback>
          </test>
        </evaluate>
      </evaluation>
    </activity>

    <activity label="traceCompoundBools">
      <statement>
        <p>
          What is printed when the following code executes and x has been set to
          3 and y has been set to 9?
        </p>

        <program language="java">
          <code>
if (x &gt; 0 &amp;&amp; (y / x) == 3)
{
   System.out.println("first case");
}
else
{
   System.out.println("second case");
}
          </code>
        </program>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>first case</p>
          </statement>

          <feedback>
            <p>
              first case will print if both of the conditions are true and they
              are.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>second case</p>
          </statement>

          <feedback>
            <p>second case will print either of the conditions are false.</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="traceCompoundBools2">
      <statement>
        <p>
          What is printed when the following code executes and x has been set to
          3 and y has been set to 6?
        </p>

        <program language="java">
          <code>
if (x &gt; 0 &amp;&amp; (y / x) == 3)
{
   System.out.println("first case");
}
else
{
   System.out.println("second case");
}
          </code>
        </program>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>first case</p>
          </statement>

          <feedback>
            <p>
              first case will print if both of the conditions are true, but the
              second is not.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>second case</p>
          </statement>

          <feedback>
            <p>
              second case will print if either of the conditions are false and
              the second one is (6 / 3 == 2).
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="qcbc_or">
      <statement>
        <p>
          What is printed when the following code executes and x has been set to
          3 and y has been set to 6? Notice that it is now an <term>or</term>
          (||) instead of <term>and</term> (&amp;&amp;).
        </p>

        <program language="java">
          <code>
if (x &gt; 0 || (y / x) == 3)
{
   System.out.println("first case");
}
else
{
   System.out.println("second case");
}
          </code>
        </program>
      </statement>

      <choices>
        <choice correct="yes">
          <statement>
            <p>first case</p>
          </statement>

          <feedback>
            <p>
              first case will print if either of the two conditions are true.
              The first condition is true, even though the second one isn't.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>second case</p>
          </statement>

          <feedback>
            <p>
              second case will print if both of the conditions are false, but
              the first condition is true.
            </p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>

  <subsection xml:id="truth-tables-1">
    <title>Truth Tables</title>
    <p>
      Although you do not have to memorize De Morgan’s Laws for the CSA Exam,
      you should be able to show that two boolean expressions are equivalent.
      One way to do this is by using truth tables. For example, we can show that
      <c>!(a &amp;&amp; b)</c> is equivalent to <c>!a || !b</c> by constructing
      the truth table below and seeing that they give identical results for the
      2 expressions (the last 2 columns in the table below are identical!).
    </p>

    <table>
      <title>
        Truth table comparing <c>!(a &amp;&amp; b)</c> and <c>!a || !b</c>
      </title>

      <tabular halign="center" bottom="minor" right="minor" top="minor" left="minor">
        <row header="yes">
          <cell>
            <c>a</c>
          </cell>

          <cell>
            <c>b</c>
          </cell>

          <cell>
            <c>!(a &amp;&amp; b)</c>
          </cell>

          <cell>
            <c>!a || !b</c>
          </cell>
        </row>

        <row>
          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>
        </row>

        <row>
          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>
        </row>

        <row>
          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>
        </row>

        <row>
          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>true</c>
          </cell>

          <cell>
            <c>false</c>
          </cell>

          <cell>
            <c>false</c>
          </cell>
        </row>
      </tabular>
    </table>
  </subsection>

  <subsection xml:id="summary-23">
    <title>Summary</title>
    <p>
      <ul>
        <li>
          <p>
            (AP 2.6.A.1) Two Boolean expressions are equivalent if they evaluate
            to the same value in all cases. Truth tables can be used to prove
            Boolean expressions are equivalent.
          </p>
        </li>

        <li>
          <p>
            (AP 2.6.A.2) De Morgan’s Laws can be applied to Boolean expressions
            to create equivalent ones:
          </p>

          <p>
            <ul>
              <li>
                <p>
                  <c>!(a &amp;&amp; b)</c> is equivalent to <c>!a || !b</c>
                </p>
              </li>

              <li>
                <p>
                  <c>!(a || b)</c> is equivalent to <c>!a &amp;&amp; !b</c>
                </p>
              </li>
            </ul>
          </p>
        </li>

        <li>
          <p>
            A negated expression with a relational operator can be simplified by
            flipping the relational operator to its opposite sign.
          </p>

          <p>
            <ul>
              <li>
                <p>
                  <c>!(c == d)</c> is equivalent to <c>c != d</c>
                </p>
              </li>

              <li>
                <p>
                  <c>!(c != d)</c> is equivalent to <c>c == d</c>
                </p>
              </li>

              <li>
                <p>
                  <c>!(c &lt; d)</c> is equivalent to <c>c &gt;= d</c>
                </p>
              </li>

              <li>
                <p>
                  <c>!(c &gt; d)</c> is equivalent to <c>c &lt;= d</c>
                </p>
              </li>

              <li>
                <p>
                  <c>!(c &lt;= d)</c> is equivalent to <c>c &gt; d</c>
                </p>
              </li>

              <li>
                <p>
                  <c>!(c &gt;= d)</c> is equivalent to <c>c &lt; d</c>
                </p>
              </li>
            </ul>
          </p>
        </li>

        <li>
          <p>
            (AP 2.6.B.1) Two different variables can hold references to the same
            object. Object references can be compared using <c>==</c> and
            <c>!=</c>. (Two object references are considered
            <term>aliases</term> when they both reference the same object.)
          </p>
        </li>

        <li>
          <p>
            (AP 2.6.B.2) An object reference can be compared with <c>null</c>,
            using <c>==</c> or <c>!=</c>, to determine if the reference actually
            references an object.
          </p>
        </li>

        <li>
          <p>
            (AP 2.6.B.3) Classes often define their own equals method, which can
            be used to specify the criteria for equivalency for two objects of
            the class. The equivalency of two objects is most often determined
            using attributes from the two objects.
          </p>
        </li>
      </ul>
    </p>
  </subsection>

  <subsection xml:id="ap-practice-16">
    <title>AP Practice</title>
    <activity label="apcsa-sample5">
      <statement>
        <p>
          Which of the following best describes the value of the Boolean
          expression: a &amp;&amp; !(b || a)
        </p>
      </statement>

      <choices>
        <choice>
          <statement>
            <p>The value is always true.</p>
          </statement>

          <feedback>
            <p>
              Try simplifying !(b ||a) or consider what happens if a and b are
              true.
            </p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement>
            <p>The value is always false.</p>
          </statement>

          <feedback>
            <p>
              Yes, a &amp;&amp; !(b || a) = a &amp;&amp; !b &amp;&amp; !a. Since
              (a &amp;&amp; !a) can never be true, the result will always be
              false.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              The value is true when a has the value false, and is false
              otherwise.
            </p>
          </statement>

          <feedback>
            <p>Try the expression with a = false. Is the result true?</p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              The value is true when b has the value false, and is false
              otherwise.
            </p>
          </statement>

          <feedback>
            <p>
              Try the expression with b = false with a = true and then try it
              with a = false. Is the result ever true?
            </p>
          </feedback>
        </choice>

        <choice>
          <statement>
            <p>
              The value is true when either a or b has the value true, and is
              false otherwise.
            </p>
          </statement>

          <feedback>
            <p>Try the expression with a = true. Is the result true?</p>
          </feedback>
        </choice>
      </choices>
    </activity>

    <activity label="AP-string-equality">
      <statement>
        <p>Consider the following code segment.</p>
        <program language="java">
          <code>
String message = new String("AP Practice");
String note = new String("AP Practice");
String memo = new String("memo");
int i = 5;

if (message.equals(note) &amp;&amp; !message.equals("memo"))
{
    message = note;

    if (message == note &amp;&amp; message.length() &gt; i)
    {
       i = 3;
       memo = message.substring(i);
    }
}
          </code>
        </program>

        <p>
          Which of the following expressions evaluate to <c>true</c> after the
          code segment above executes?
        </p>
      </statement>

      <choices>
        <choice>
          <statement id="AP-string-equality_opt_a">
            <p>message == note &amp;&amp; message == memo</p>
          </statement>

          <feedback id="AP-string-equality_opt_a">
            <p>Message does not refer to the same object as memo.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-string-equality_opt_b">
            <p>message.equals(note) &amp;&amp; message.equals(memo)</p>
          </statement>

          <feedback id="AP-string-equality_opt_b">
            <p>Message is not the same string as in memo.</p>
          </feedback>
        </choice>

        <choice correct="yes">
          <statement id="AP-string-equality_opt_c">
            <p>message == note &amp;&amp; memo.equals(“Practice”)</p>
          </statement>

          <feedback id="AP-string-equality_opt_c">
            <p>
              Yes, both if statements in the code above execute changing message
              to equal note and memo to equal “Practice”.
            </p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-string-equality_opt_d">
            <p>message != note || message == memo</p>
          </statement>

          <feedback id="AP-string-equality_opt_d">
            <p>Both of these are false.</p>
          </feedback>
        </choice>

        <choice>
          <statement id="AP-string-equality_opt_e">
            <p>message.equals(memo) || memo.equals(note)</p>
          </statement>

          <feedback id="AP-string-equality_opt_e">
            <p>Both of these are false.</p>
          </feedback>
        </choice>
      </choices>
    </activity>
  </subsection>
</section>
